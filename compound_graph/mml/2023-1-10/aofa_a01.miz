:: Analysis of Algorithms: An Example of a Sort Algorithm
::  by Grzegorz Bancerek
::
:: Received November 9, 2012
:: Copyright (c) 2012-2022 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies INT_1, AOFA_A00, XBOOLE_0, STRUCT_0, RELAT_1, PBOOLE, MSAFREE4,
      NAT_1, SUBSET_1, ORDINAL1, MSUALG_1, AOFA_000, ZF_MODEL, FUNCT_1,
      INCPROJ, FUNCT_2, CARD_1, GRAPHSP, AOFA_I00, QC_LANG1, MSAFREE, AOFA_A01,
      ARYTM_3, NEWTON, ABCMIZ_1, ZFMISC_1, XREAL_0, MSUALG_3, GROUP_6, REAL_1,
      MSUALG_2, TARSKI, MARGREL1, XBOOLEAN, PARTFUN1, FINSEQ_1, XXREAL_0,
      CARD_3, NUMBERS, FUNCT_7, ARYTM_1, PRELAMB, REALSET1, TREES_4, POWER,
      PROB_2, FUNCT_6, PZFMISC1, ALGSTR_4, ORDINAL4, MEMBERED, FINSET_1,
      XXREAL_2, AFINSQ_1, EXCHSORT, FUNCT_4, FUNCOP_1, FINSEQ_4, MODELC_3,
      UNIALG_1, WELLORD1, ORDERS_2, LFUZZY_0, REARRAN1, SETLIM_2, MCART_1,
      EQUATION, FOMODEL2, TREES_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, FINSET_1, WELLORD2, MCART_1,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, MARGREL1, XTUPLE_0, FUNCT_4,
      FUNCT_6, FUNCT_7, FUNCOP_1, FINSEQ_1, FINSEQ_2, FINSEQ_4, AFINSQ_1,
      CARD_1, CARD_3, POWER, MEMBERED, STRUCT_0, ORDINAL1, NAT_1, BINOP_1,
      PBOOLE, TREES_3, TREES_4, PZFMISC1, TREES_2, NUMBERS, XCMPLX_0, XXREAL_0,
      XREAL_0, XXREAL_2, INT_1, NAT_D, NEWTON, TREES_1, PROB_2, ORDERS_2,
      WAYBEL_0, LFUZZY_0, UNIALG_1, FREEALG, COMPUT_1, PUA2MSS1, MSUALG_1,
      MSUALG_2, MSUALG_3, MSAFREE, MSAFREE1, MSUALG_6, MSAFREE3, MSATERM,
      AOFA_000, EXCHSORT, MSAFREE4, AOFA_A00;
 constructors XBOOLE_0, AOFA_000, AOFA_A00, SUBSET_1, BINOP_1, ORDINAL1, NAT_1,
      INSTALG1, MSAFREE3, ZFMISC_1, NEWTON, XCMPLX_0, MSAFREE4, CATALG_1,
      AUTALG_1, POWER, PUA2MSS1, MSUALG_3, FINSEQ_4, NUMBERS, RELSET_1, REAL_1,
      MSAFREE1, PZFMISC1, PRALG_2, SQUARE_1, NAT_D, XXREAL_0, XXREAL_2,
      EXCHSORT, AFINSQ_1, WELLORD2, FUNCT_4, PARTFUN1, COMPUT_1, LFUZZY_0,
      MEMBERED, WAYBEL_0, MCART_1, MSATERM, TREES_9, TREES_2;
 registrations AOFA_000, AOFA_A00, ORDINAL1, NUMBERS, PBOOLE, MSUALG_1,
      INSTALG1, MSAFREE4, FUNCOP_1, RELSET_1, STRUCT_0, INT_1, XREAL_0,
      MSUALG_2, FUNCT_1, FINSEQ_1, XBOOLEAN, MARGREL1, XBOOLE_0, NAT_1,
      RELAT_1, MSUALG_9, POWER, MEMBERED, XXREAL_2, EXCHSORT, FINSET_1,
      AFINSQ_1, CARD_1, UNIALG_1, LFUZZY_0, TREES_3, TREES_2, VALUED_0,
      XTUPLE_0;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, MEMBERED, XBOOLE_0, RELAT_1, FUNCT_2, XXREAL_2, PBOOLE,
      AOFA_000, AOFA_A00;
 equalities FINSEQ_1, XBOOLEAN, MARGREL1, PUA2MSS1, MSUALG_1, AOFA_000,
      AOFA_A00, ORDINAL1;
 expansions TARSKI, FUNCT_2, FINSEQ_1, UNIALG_1, PBOOLE, MSUALG_3, AOFA_000,
      AOFA_A00;
 theorems TARSKI, XBOOLE_0, XBOOLE_1, ZFMISC_1, INT_1, RELAT_1, XXREAL_0,
      PARTFUN1, FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQ_4,
      FINSET_1, ORDINAL1, AFINSQ_1, FUNCOP_1, CARD_5, XBOOLEAN, MARGREL1,
      POWER, NEWTON, FIB_NUM2, NAT_1, NAT_D, PRE_FF, FUNCT_4, INT_2, XXREAL_2,
      TREES_4, TREES_1, CARD_3, FUNCT_7, PBOOLE, PRE_CIRC, MSAFREE, MSSUBFAM,
      PRALG_2, EXTENS_1, MSAFREE3, MSAFREE4, EQUATION, MSUALG_2, MSUALG_3,
      AOFA_000, AOFA_A00, EXCHSORT, MEMBERED, CARD_1, XREAL_1, LFUZZY_0,
      MSAFREE1, INSTALG1, TREES_9, SUBSET_1;
 schemes FUNCT_2, NAT_1, FINSEQ_1, RECDEF_1, AOFA_000, CLASSES1;

begin :: Exponentiation by squaring revisited

theorem Th1:
  1 mod 2 = 1 & 2 mod 2 = 0 by NAT_D:24,NAT_D:25;

theorem Th2:
  for S being non empty non void ManySortedSign
  for A being MSAlgebra over S
  for B being MSSubAlgebra of A
  for s being SortSymbol of S
  for a being set st a in (the Sorts of B).s
  holds a in (the Sorts of A).s
  proof
    let S be non empty non void ManySortedSign;
    let A be MSAlgebra over S;
    let B be MSSubAlgebra of A;
    let s be SortSymbol of S;
    the Sorts of B is MSSubset of A by MSUALG_2:def 9;
    then (the Sorts of B).s c= (the Sorts of A).s by PBOOLE:def 18,def 2;
    hence thesis;
  end;

theorem Th3:
  for I being non empty set, a,b,c being set, i being Element of I
  holds c in (i-singleton a).b iff b = i & c = a
  proof
    let I be non empty set;
    let a,b,c be set;
    let i be Element of I;
A1: (i-singleton a).i = {a} & for b being set st b in I & b <> i holds
    (i-singleton a).b = {} by AOFA_A00:6;
    dom (i-singleton a) = I by PARTFUN1:def 2;
    then
A2: for b being set st b nin I holds (i-singleton a).b = {} by FUNCT_1:def 2;
    hereby
      assume A3: c in (i-singleton a).b;
      thus b = i by A3,A1,A2;
      hence c = a by A1,A3,TARSKI:def 1;
    end;
    thus thesis by A1,TARSKI:def 1;
  end;

theorem Th4:
  for I being non empty set, a,b,c,d being set, i,j being Element of I
  holds c in ((i-singleton a)(\/)(j-singleton d)).b iff
  b = i & c = a or b = j & c = d
  proof
    let I be non empty set;
    let a,b,c,d be set;
    let i,j be Element of I;
    hereby
      assume A1: c in ((i-singleton a)(\/)(j-singleton d)).b;
      assume A2: not (b = i & c = a);
      b in dom((i-singleton a)(\/)(j-singleton d)) by A1,FUNCT_1:def 2;
      then b in I by PARTFUN1:def 2;
      then c in ((i-singleton a).b)\/((j-singleton d).b) by A1,PBOOLE:def 4;
      then c in (i-singleton a).b or c in (j-singleton d).b by XBOOLE_0:def 3;
      hence b = j & c = d by A2,Th3;
    end;
    assume A3: b = i & c = a or b = j & c = d;
    then c in (i-singleton a).b or c in (j-singleton d).b by Th3;
    then c in ((i-singleton a).b)\/((j-singleton d).b) by XBOOLE_0:def 3;
    hence c in ((i-singleton a)(\/)(j-singleton d)).b by A3,PBOOLE:def 4;
  end;

definition
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  let A be non-empty MSAlgebra over S;
  attr A is integer means: Def1:
  ex C being image of A st C is (4,1) integer bool-correct MSAlgebra over S;
end;

theorem Th5:
  for S being non empty non void ManySortedSign
  for A being non-empty MSAlgebra over S
  holds Image id the Sorts of A = the MSAlgebra of A
  proof
    let S be non empty non void ManySortedSign;
    let A be non-empty MSAlgebra over S;
    the MSAlgebra of A is strict non-empty MSSubAlgebra of A &
    id the Sorts of A is_homomorphism A,A &
    (id the Sorts of A).:.:the Sorts of A = the Sorts of A
    by EQUATION:15,MSUALG_2:5,MSUALG_3:9;
    hence Image id the Sorts of A = the MSAlgebra of A by MSUALG_3:def 12;
  end;

theorem Th6:
  for S being non empty non void ManySortedSign
  for A being non-empty MSAlgebra over S
  holds A is image of A
  proof
    let S be non empty non void ManySortedSign;
    let A be non-empty MSAlgebra over S;
    A is A-Image
    proof
      now
        take B = A;
        reconsider h = id the Sorts of A as ManySortedFunction of
        the Sorts of A, the Sorts of B;
        take h;
        thus h is_homomorphism A,B by MSUALG_3:9;
        thus the MSAlgebra of A = Image h by Th5;
      end;
      hence thesis by MSAFREE4:def 4;
    end;
    hence thesis;
  end;

registration
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  cluster integer for non-empty MSAlgebra over S;
  existence
  proof
    set C = the (4,1) integer bool-correct non-empty MSAlgebra over S;
    reconsider C1 = C as image of C by Th6;
    take C,C1; thus thesis;
  end;
end;

registration
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  let A be integer non-empty MSAlgebra over S;
  cluster bool-correct for image of A;
  existence
  proof
    consider C being image of A such that
A1: C is (4,1) integer bool-correct MSAlgebra over S by Def1;
    take C; thus thesis by A1;
  end;
end;

registration
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  let A be integer non-empty MSAlgebra over S;
  cluster (4,1) integer for bool-correct image of A;
  existence
  proof
    ex C being image of A st
    C is (4,1) integer bool-correct MSAlgebra over S by Def1;
    hence thesis;
  end;
end;

theorem Th7:
  for S being non empty non void ManySortedSign
  for A being non-empty MSAlgebra over S
  for o being OperSymbol of S, a being set, r being SortSymbol of S
  st o is_of_type a,r
  holds Den(o,A) is Function of (the Sorts of A)#.a, (the Sorts of A).r &
  Args(o,A) = (the Sorts of A)#.a & Result(o,A) = (the Sorts of A).r
  proof
    let S be non empty non void ManySortedSign;
    let A be non-empty MSAlgebra over S;
    let o be OperSymbol of S;
    let a be set;
    let r be SortSymbol of S;
    assume A1: (the Arity of S).o = a & (the ResultSort of S).o = r;
    then
A2: ((the Sorts of A)#*the Arity of S).o = (the Sorts of A)#.a by FUNCT_2:15;
    ((the Sorts of A)*the ResultSort of S).o = (the Sorts of A).r
    by A1,FUNCT_2:15;
    hence Den(o,A) is Function of (the Sorts of A)#.a, (the Sorts of A).r
    by A2;
    thus thesis by A1,FUNCT_2:15;
  end;

registration
  let S be bool-correct non empty non void BoolSignature;
  let A be bool-correct non-empty MSAlgebra over S;
  cluster -> bool-correct for non-empty MSSubAlgebra of A;
  coherence
  proof
A1: (the Sorts of A).the bool-sort of S = BOOLEAN &
    Den(In((the connectives of S).1, the carrier' of S), A).{} = TRUE &
    for x,y be boolean object holds
    Den(In((the connectives of S).2, the carrier' of S), A).<*x*> = 'not' x &
    Den(In((the connectives of S).3, the carrier' of S), A).<*x,y*> = x '&' y
    by AOFA_A00:def 32;
    let B be non-empty MSSubAlgebra of A;
    the Sorts of B is MSSubset of A by MSUALG_2:def 9;
    hence (the Sorts of B).the bool-sort of S c= BOOLEAN
    by A1,PBOOLE:def 18,def 2;
    set o1 = In((the connectives of S).1, the carrier' of S),
    o2 = In((the connectives of S).2, the carrier' of S);
    set b = the bool-sort of S;
    3 <= len the connectives of S by AOFA_A00:def 31;
    then 1 <= len the connectives of S by XXREAL_0:2;
    then 1 in dom the connectives of S by FINSEQ_3:25;
    then o1 = (the connectives of S).1 by FUNCT_1:102,SUBSET_1:def 8;
    then o1 is_of_type {},b by AOFA_A00:def 31;
    then
A2: Den(o1,B) is Function of (the Sorts of B)#.{}, (the Sorts of B).b &
    Args(o1,B) = (the Sorts of B)#.{} by Th7;
    (the Sorts of B)#.<*>the carrier of S = {{}} by PRE_CIRC:2;
    then
A3: {} in (the Sorts of B)#.{} by TARSKI:def 1;
A4: Den(o1,B).{} = Den(o1,A).{} by A2,A3,EQUATION:19
    .= TRUE by AOFA_A00:def 32;
    then
A5: TRUE in (the Sorts of B).the bool-sort of S by A2,A3,FUNCT_2:5;
A6: <*b*> in (the carrier of S)* by FINSEQ_1:def 11;
A7: dom the Sorts of B = the carrier of S by PARTFUN1:def 2;
    3 <= len the connectives of S by AOFA_A00:def 31;
    then 2 <= len the connectives of S by XXREAL_0:2;
    then 2 in dom the connectives of S by FINSEQ_3:25;
    then o2 = (the connectives of S).2 by FUNCT_1:102,SUBSET_1:def 8;
    then o2 is_of_type <*b*>,b by AOFA_A00:def 31;
    then
A8: Den(o2,B) is Function of (the Sorts of B)#.<*b*>, (the Sorts of B).b &
    Args(o2,B) = (the Sorts of B)#.<*b*> by Th7;
    then
A9: Args(o2,B) = product ((the Sorts of B)*<*b*>) by A6,FINSEQ_2:def 5
    .= product <*(the Sorts of B).b*> by A7,FINSEQ_2:34;
    then
A10: <*TRUE*> in Args(o2,B) by A5,FINSEQ_3:123;
    Den(o2,B).<*TRUE*>
    = Den(o2,A).<*TRUE*> by A9,A5,FINSEQ_3:123,EQUATION:19
    .= 'not' TRUE by AOFA_A00:def 32 .= FALSE;
    then FALSE in (the Sorts of B).b by A8,A10,FUNCT_2:5;
    hence
A11: BOOLEAN c= (the Sorts of B).b by A5,ZFMISC_1:32;
    thus Den(In((the connectives of S).1, the carrier' of S), B).{}
    = TRUE by A4;
    let x,y be boolean object;
A12: <*b,b*> in (the carrier of S)* by FINSEQ_1:def 11;
A13: x in BOOLEAN & y in BOOLEAN by MARGREL1:def 12;
    thus Den(o2, B).<*x*> = Den(o2,A).<*x*>
    by A13,A11,A9,FINSEQ_3:123,EQUATION:19
    .= 'not' x by AOFA_A00:def 32;
    set o3 = In((the connectives of S).3, the carrier' of S);
    3 <= len the connectives of S by AOFA_A00:def 31;
    then 3 in dom the connectives of S by FINSEQ_3:25;
    then o3 = (the connectives of S).3 by FUNCT_1:102,SUBSET_1:def 8;
    then o3 is_of_type <*b,b*>,b by AOFA_A00:def 31;
    then
    Den(o3,B) is Function of (the Sorts of B)#.<*b,b*>, (the Sorts of B).b &
    Args(o3,B) = (the Sorts of B)#.<*b,b*> by Th7;
    then
    Args(o3,B) = product ((the Sorts of B)*<*b,b*>) by A12,FINSEQ_2:def 5
    .= product <*(the Sorts of B).b,(the Sorts of B).b*> by A7,FINSEQ_2:125;
    hence Den(o3, B).<*x,y*> = Den(o3,A).<*x,y*>
    by A11,A13,FINSEQ_3:124,EQUATION:19
    .= x '&' y by AOFA_A00:def 32;
  end;
end;

registration
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  let A be (4,1) integer bool-correct non-empty MSAlgebra over S;
  cluster -> (4,1) integer for non-empty MSSubAlgebra of A;
  coherence
  proof
    let B be non-empty MSSubAlgebra of A;
    set n = 4;
    consider I being SortSymbol of S such that
A1: I = 1 & (the connectives of S).n is_of_type {},I &
    (the Sorts of A).I = INT &
    Den(In((the connectives of S).n, the carrier' of S), A).{} = 0 &
    Den(In((the connectives of S).(n+1), the carrier' of S), A).{} = 1 &
    for i,j being Integer holds
    Den(In((the connectives of S).(n+2), the carrier' of S), A).<*i*> = -i &
    Den(In((the connectives of S).(n+3), the carrier' of S), A).<*i,j*> = i+j &
    Den(In((the connectives of S).(n+4), the carrier' of S), A).<*i,j*> = i*j &
    (j <> 0 implies
    Den(In((the connectives of S).(n+5), the carrier' of S), A).<*i,j*>
    = i div j) &
    Den(In((the connectives of S).(n+6), the carrier' of S), A).<*i,j*>
    = IFGT(i,j,FALSE,TRUE) by AOFA_A00:def 50;
    reconsider I as integer SortSymbol of S by A1,AOFA_A00:def 40;
    take I;
    thus I = 1 & (the connectives of S).n is_of_type {},I by A1;
    the Sorts of B is MSSubset of A by MSUALG_2:def 9;
    hence (the Sorts of B).I c= INT by A1,PBOOLE:def 18,def 2;
    n+6 <= len the connectives of S & 4 <= 10 by AOFA_A00:def 39;
    then n <= len the connectives of S & n+1 <= len the connectives of S &
    1 <= 5 by XXREAL_0:2;
    then n in dom the connectives of S & n+1 in dom the connectives of S
    by FINSEQ_3:25;
    then reconsider o1 = (the connectives of S).n,
    o2 = (the connectives of S).(n+1) as OperSymbol of S by FUNCT_1:102;
    o1 is_of_type {},I & o2 is_of_type {},I by AOFA_A00:53;
    then
A2: Den(o1,B) is Function of (the Sorts of B)#.{}, (the Sorts of B).I &
    Den(o2,B) is Function of (the Sorts of B)#.{}, (the Sorts of B).I &
    Args(o1,B) = (the Sorts of B)#.{} & Args(o2,B) = (the Sorts of B)#.{}
    by Th7;
    (the Sorts of B)#.<*>the carrier of S = {{}} by PRE_CIRC:2;
    then
A3: {} in (the Sorts of B)#.{} by TARSKI:def 1;
    then
A4: Den(o1,B).{} in (the Sorts of B).I & Den(o2,B).{} in (the Sorts of B).I
    by A2,FUNCT_2:5;
A5: Den(o1,B).{} = Den(o1,A).{} by A2,A3,EQUATION:19
    .= 0 by A1,SUBSET_1:def 8;
A6: Den(o2,B).{} = Den(o2,A).{} by A2,A3,EQUATION:19
    .= 1 by A1,SUBSET_1:def 8;
    defpred P[Nat] means $1 in (the Sorts of B).I & -$1 in (the Sorts of B).I;
A7: P[0] by A2,A3,A5,FUNCT_2:5;
    n+6 <= len the connectives of S & 4 <= 10 by AOFA_A00:def 39;
    then n+2 <= len the connectives of S & n+3 <= len the connectives of S &
    1 <= 6 & 1 <= 7 by XXREAL_0:2;
    then n+2 in dom the connectives of S & n+3 in dom the connectives of S
    by FINSEQ_3:25;
    then reconsider o3 = (the connectives of S).(n+2),
    o4 = (the connectives of S).(n+3) as OperSymbol of S by FUNCT_1:102;
    o3 is_of_type <*I*>,I & o4 is_of_type <*I,I*>,I by AOFA_A00:53;
    then
A8: Den(o3,B) is Function of (the Sorts of B)#.<*I*>, (the Sorts of B).I &
    Den(o4,B) is Function of (the Sorts of B)#.<*I,I*>, (the Sorts of B).I &
    Args(o3,B) = (the Sorts of B)#.<*I*> &
    Args(o4,B) = (the Sorts of B)#.<*I,I*> by Th7;
A9: dom the Sorts of B = the carrier of S by PARTFUN1:def 2;
    <*I*> is Element of (the carrier of S)* by FINSEQ_1:def 11;
    then
A10: Args(o3,B) = product ((the Sorts of B)*<*I*>) by A8,FINSEQ_2:def 5
    .= product <*(the Sorts of B).I*> by A9,FINSEQ_2:34;
    <*I,I*> is Element of (the carrier of S)* by FINSEQ_1:def 11;
    then
A11: Args(o4,B) = product ((the Sorts of B)*<*I,I*>) by A8,FINSEQ_2:def 5
    .= product <*(the Sorts of B).I,(the Sorts of B).I*> by A9,FINSEQ_2:125;
A12: for i being Nat st P[i] holds P[i+1]
    proof let i be Nat;
      assume
A13:   P[i];
      then
A14:   <*i,1*> in Args(o4,B) by A6,A4,A11,FINSEQ_3:124;
      Den(o4,B).<*i,1*> = Den(o4,A).<*i,1*>
      by A13,A6,A4,A11,FINSEQ_3:124,EQUATION:19
      .= Den(In(o4,the carrier' of S),A).<*i,1*> by SUBSET_1:def 8
      .= i+1 by A1;
      hence
A15:   i+1 in (the Sorts of B).I by A14,A8,FUNCT_2:5;
      then
A16:   <*i+1*> in Args(o3,B) by A10,FINSEQ_3:123;
      Den(o3,B).<*i+1*> = Den(o3,A).<*i+1*> by A15,A10,FINSEQ_3:123,EQUATION:19
      .= Den(In(o3,the carrier' of S),A).<*i+1*> by SUBSET_1:def 8
      .= -(i+1) by A1;
      hence -(i+1) in (the Sorts of B).I by A16,A8,FUNCT_2:5;
    end;
A17: for i being Nat holds P[i] from NAT_1:sch 2(A7,A12);
    thus
A18: INT c= (the Sorts of B).I
    proof let x be Integer;
      x in INT by INT_1:def 2;
      then consider n being Nat such that
A19:   x = n or x = -n by INT_1:def 1;
      thus thesis by A17,A19;
    end;
    thus Den(In((the connectives of S).n, the carrier' of S), B).{} = 0 &
    Den(In((the connectives of S).(n+1), the carrier' of S), B).{} = 1
    by A5,A6,SUBSET_1:def 8;
    let i,j be Integer;
A20: i in INT & j in INT by INT_1:def 2;
    <*i*> in Args(o3,B) by A20,A18,A10,FINSEQ_3:123;
    then <*i*> in Args(In(o3,the carrier' of S),B) by SUBSET_1:def 8;
    hence
    Den(In((the connectives of S).(n+2), the carrier' of S), B).<*i*>
    = Den(In((the connectives of S).(n+2), the carrier' of S), A).<*i*>
    by EQUATION:19 .= -i by A1;
    <*i,j*> in Args(o4,B) by A11,A20,A18,FINSEQ_3:124;
    then <*i,j*> in Args(In(o4,the carrier' of S),B) by SUBSET_1:def 8;
    hence
    Den(In((the connectives of S).(n+3), the carrier' of S), B).<*i,j*>
    = Den(In((the connectives of S).(n+3), the carrier' of S), A).<*i,j*>
    by EQUATION:19 .= i+j by A1;
    n+6 <= len the connectives of S & 4 <= 10 by AOFA_A00:def 39;
    then n+4 <= len the connectives of S & n+5 <= len the connectives of S &
    1 <= 8 & 1 <= 9 by XXREAL_0:2;
    then n+4 in dom the connectives of S & n+5 in dom the connectives of S
    by FINSEQ_3:25;
    then reconsider o5 = (the connectives of S).(n+4),
    o6 = (the connectives of S).(n+5) as OperSymbol of S by FUNCT_1:102;
    o5 is_of_type <*I,I*>,I & o6 is_of_type <*I,I*>,I by AOFA_A00:53;
    then
A21: Args(o5,B) = (the Sorts of B)#.<*I,I*> &
    Args(o6,B) = (the Sorts of B)#.<*I,I*> by Th7;
    then <*i,j*> in Args(o5,B) by A8,A11,A20,A18,FINSEQ_3:124;
    then <*i,j*> in Args(In(o5,the carrier' of S),B) by SUBSET_1:def 8;
    hence
    Den(In((the connectives of S).(n+4), the carrier' of S), B).<*i,j*>
    = Den(In((the connectives of S).(n+4), the carrier' of S), A).<*i,j*>
    by EQUATION:19 .= i*j by A1;
    hereby assume
A22:   j <> 0;
      <*i,j*> in Args(o6,B) by A8,A11,A20,A18,A21,FINSEQ_3:124;
      then <*i,j*> in Args(In(o6,the carrier' of S),B) by SUBSET_1:def 8;
      hence
      Den(In((the connectives of S).(n+5), the carrier' of S), B).<*i,j*>
      = Den(In((the connectives of S).(n+5), the carrier' of S), A).<*i,j*>
      by EQUATION:19 .= i div j by A22,A1;
    end;
    n+6 <= len the connectives of S & 4 <= 10 by AOFA_A00:def 39;
    then n+6 in dom the connectives of S by FINSEQ_3:25;
    then reconsider o7 = (the connectives of S).(n+6) as OperSymbol of S
    by FUNCT_1:102;
    o7 is_of_type <*I,I*>,the bool-sort of S by AOFA_A00:53;
    then
    Args(o7,B) = (the Sorts of B)#.<*I,I*> by Th7;
    then <*i,j*> in Args(o7,B) by A8,A11,A20,A18,FINSEQ_3:124;
    then <*i,j*> in Args(In(o7,the carrier' of S),B) by SUBSET_1:def 8;
    hence
    Den(In((the connectives of S).(n+6), the carrier' of S), B).<*i,j*>
    = Den(In((the connectives of S).(n+6), the carrier' of S), A).<*i,j*>
    by EQUATION:19 .= IFGT(i,j,FALSE,TRUE) by A1;
  end;
end;

registration
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster Free(S,X) -> integer for non-empty MSAlgebra over S;
  coherence
  proof let F be non-empty MSAlgebra over S;
    assume
A1: F = Free(S,X);
    set A = the (4,1) integer bool-correct non-empty MSAlgebra over S;
    reconsider G = FreeGen X as GeneratorSet of F by A1,MSAFREE3:31;
    set f = the ManySortedFunction of G, the Sorts of A;
    FreeGen X is free & F = FreeMSA X by A1,MSAFREE3:31;
    then consider h being ManySortedFunction of F,A such that
A2: h is_homomorphism F,A & h||G = f by MSAFREE:def 5;
    reconsider C = Image h as image of F by A2,MSAFREE4:def 4;
    take C; thus C is (4,1) integer bool-correct MSAlgebra over S;
  end;
end;

theorem Th8:
  for S being non empty non void ManySortedSign
  for A1,A2,B1 being MSAlgebra over S, B2 being non-empty MSAlgebra over S
  st the MSAlgebra of A1 = the MSAlgebra of A2 &
  the MSAlgebra of B1 = the MSAlgebra of B2
  for h1 being ManySortedFunction of A1,B1
  for h2 being ManySortedFunction of A2,B2 st h1 = h2 &
  h1 is_epimorphism A1,B1 holds h2 is_epimorphism A2,B2
  by MSAFREE4:30;

registration
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster vf-free integer for all_vars_including inheriting_operations
  free_in_itself (X,S)-terms non-empty VarMSAlgebra over S;
  existence
  proof
    set A = Free(S,X);
    consider V being ManySortedMSSet of the Sorts of A,the Sorts of A,
    B being all_vars_including inheriting_operations free_in_itself
    (X,S)-terms VarMSAlgebra over S such that
A1: B = VarMSAlgebra(#the Sorts of A, the Charact of A, V#) &
    B is vf-free by AOFA_A00:39;
    take B; thus B is vf-free by A1;
    consider C being image of A such that
A2: C is (4,1) integer bool-correct MSAlgebra over S by Def1;
    consider h being ManySortedFunction of A,C such that
A3: h is_epimorphism A,C by MSAFREE4:def 5;
    reconsider g = h as ManySortedFunction of B,C by A1;
    the MSAlgebra of C = the MSAlgebra of C;
    then reconsider D = C as image of B by A1,A3,Th8,MSAFREE4:def 5;
    take D; thus thesis by A2;
  end;
end;

definition
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations (X,S)-terms
  MSAlgebra over S;
  func FreeGen T -> non-empty GeneratorSet of T equals FreeGen X;
  coherence by MSAFREE4:45;
end;

registration
  let S be non empty non void ManySortedSign;
  let X0 be countable non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations free_in_itself
  (X0,S)-terms MSAlgebra over S;
  cluster FreeGen T -> (Equations(S, T))-free non-empty;
  coherence by MSAFREE4:75;
end;

definition
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations (X,S)-terms
  MSAlgebra over S;
  let G be GeneratorSet of T;
  attr G is basic means: Def3: FreeGen T c= G;
  let s be SortSymbol of S;
  let x be Element of G.s;
  attr x is pure means: Def4: x in (FreeGen T).s;
end;

registration
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations (X,S)-terms
  MSAlgebra over S;
  cluster FreeGen T -> basic;
  coherence;
end;

registration
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations (X,S)-terms
  MSAlgebra over S;
  cluster basic for non-empty GeneratorSet of T;
  existence
  proof
    reconsider G = FreeGen X as non-empty GeneratorSet of T by MSAFREE4:45;
    take G; thus FreeGen T c= G;
  end;
end;

registration
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations (X,S)-terms
  MSAlgebra over S;
  let G be basic GeneratorSet of T;
  let s be SortSymbol of S;
  cluster pure for Element of G.s;
  existence
  proof
    set x = the Element of (FreeGen T).s;
    x in (FreeGen T).s & (FreeGen T).s c= G.s by Def3,PBOOLE:def 2;
    then reconsider x as Element of G.s;
    take x; thus x in (FreeGen T).s;
  end;
end;

theorem
  for S being non empty non void ManySortedSign
  for X being non-empty ManySortedSet of the carrier of S
  for T being all_vars_including inheriting_operations (X,S)-terms
  MSAlgebra over S
  for G being basic GeneratorSet of T
  for s being SortSymbol of S
  for a being set holds a is pure Element of G.s iff a in (FreeGen T).s
  proof
    let S be non empty non void ManySortedSign;
    let X be non-empty ManySortedSet of the carrier of S;
    let T be all_vars_including inheriting_operations (X,S)-terms
    MSAlgebra over S;
    let G be basic GeneratorSet of T;
    let s be SortSymbol of S;
    let a be set;
    (FreeGen T).s c= G.s by Def3,PBOOLE:def 2;
    hence thesis by Def4;
  end;

definition
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations free_in_itself (X,S)-terms
  MSAlgebra over S;
  let G be GeneratorSystem over S,X,T;
  attr G is basic means: Def5: the generators of G is basic;
end;

registration
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations free_in_itself (X,S)-terms
  MSAlgebra over S;
  cluster basic for GeneratorSystem over S,X,T;
  existence
  proof
    set Y = the basic non-empty GeneratorSet of T;
    set SV = the ManySortedFunction of Y, FreeGen X;
    set ST = the ManySortedMSSet of Y, the carrier of S;
    take G = GeneratorSystem(#Y,SV,ST#);
    thus the generators of G is basic;
  end;
end;

registration
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations free_in_itself (X,S)-terms
  MSAlgebra over S;
  let G be basic GeneratorSystem over S,X,T;
  cluster the generators of G -> basic;
  coherence by Def5;
end;

reserve
  S for (4,1) integer bool-correct non empty non void BoolSignature,
  X for non-empty ManySortedSet of the carrier of S,
  T for vf-free integer all_vars_including inheriting_operations free_in_itself
  (X,S)-terms VarMSAlgebra over S,
  C for (4,1) integer bool-correct non-empty image of T,
  G for basic GeneratorSystem over S,X,T,
  A for IfWhileAlgebra of the generators of G,
  I for integer SortSymbol of S,
  x,y,z,m for pure (Element of (the generators of G).I),
  b for pure (Element of (the generators of G).the bool-sort of S),
  t,t1,t2 for Element of T,I,
  P for Algorithm of A,
  s,s1,s2 for Element of C-States(the generators of G);

definition
  let S be bool-correct non empty non void BoolSignature;
  let A be non-empty MSAlgebra over S;
  func \falseA -> Element of A, the bool-sort of S equals \not\trueA;
  coherence;
end;

reserve
  f for ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G, b);

theorem Th10:
  \falseC = FALSE
  proof
    \trueC = TRUE by AOFA_A00:def 32;
    hence \falseC = 'not' TRUE by AOFA_A00:def 32 .= FALSE;
  end;

definition
  let S be bool-correct non empty non void BoolSignature;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations free_in_itself (X,S)-terms
  MSAlgebra over S;
  let G be GeneratorSystem over S,X,T;
  let b be Element of (the generators of G).the bool-sort of S;
  let C be image of T;
  let A be preIfWhileAlgebra;
  let f be ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G, b);
  let s be Element of C-States(the generators of G);
  let P be Algorithm of A;
  redefine func f.(s,P) -> Element of C-States(the generators of G);
  coherence
  proof
    thus f.(s,P) is Element of C-States(the generators of G);
  end;
end;

definition
  let S be non empty non void ManySortedSign;
  let T be non-empty MSAlgebra over S;
  let G be non-empty GeneratorSet of T;
  let s be SortSymbol of S;
  let x be Element of G.s;
  func @x -> Element of T,s equals x;
  coherence
  proof
    G.s c= (the Sorts of T).s & x in G.s by PBOOLE:def 18,def 2;
    hence x is Element of (the Sorts of T).s;
  end;
end;

definition
  let S,X,T,G,A,b,I,t1,t2;
  func b leq(t1, t2, A) -> Algorithm of A equals b:=(leq(t1,t2),A);
  coherence;
  func b gt(t1, t2, A) -> Algorithm of A equals b:=(\not(leq(t1,t2)),A);
  coherence;
end;

definition
  let S,X,T,I;
  func \2(T,I) -> Element of T,I equals \1(T,I)+\1(T,I);
  coherence;
end;

definition
  let S,X,T,G,A,b,I,t;
  func t is_odd(b,A) -> Algorithm of A equals b gt(t mod \2(T,I),\0(T,I),A);
  coherence;
  func t is_even(b,A) -> Algorithm of A equals b leq(t mod \2(T,I),\0(T,I),A);
  coherence;
end;

registration
  let S,X,T,G,C,I,s;
  let x be Element of (the generators of G).I;
  cluster s.I.x -> integer;
  coherence
  proof
    (the Sorts of C).I = INT & s is ManySortedFunction of the generators of G,
    the Sorts of C by AOFA_A00:48,55;
    then s.I is Function of (the generators of G).I, INT by PBOOLE:def 15;
    then s.I.x in INT by FUNCT_2:5;
    hence thesis;
  end;
end;

registration
  let S,X,T,G,C,I,s,t;
  cluster t value_at(C,s) -> integer;
  coherence
  proof
    (the Sorts of C).I = INT by AOFA_A00:55;
    hence thesis;
  end;
end;

reserve u for ManySortedFunction of FreeGen T, the Sorts of C;

registration
  let S,X,T,C,I,u,t;
  cluster t value_at(C,u) -> integer;
  coherence
  proof
    (the Sorts of C).I = INT by AOFA_A00:55;
    hence thesis;
  end;
end;

registration
  let S,X,T,G,C,s;
  let t be Element of T, the bool-sort of S;
  cluster t value_at(C,s) -> boolean;
  coherence
  proof
    (the Sorts of C).the bool-sort of S = BOOLEAN by AOFA_A00:def 32;
    hence thesis;
  end;
end;

registration
  let S,X,T,C,u;
  let t be Element of T, the bool-sort of S;
  cluster t value_at(C,u) -> boolean;
  coherence
  proof
    (the Sorts of C).the bool-sort of S = BOOLEAN by AOFA_A00:def 32;
    hence thesis;
  end;
end;

theorem Th11:
  for o being OperSymbol of S st
  o = In((the connectives of S).1, the carrier' of S)
  holds o = (the connectives of S).1 &
  the_arity_of o = {} & the_result_sort_of o = the bool-sort of S
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).1, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 1 <= len the connectives of S by XXREAL_0:2;
    then 1 in dom the connectives of S by FINSEQ_3:25;
    hence o = (the connectives of S).1 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type {}, the bool-sort of S by AOFA_A00:def 31;
    hence the_arity_of o = {} & the_result_sort_of o = the bool-sort of S;
  end;

theorem Th12:
  for o being OperSymbol of S st
  o = In((the connectives of S).2, the carrier' of S)
  holds o = (the connectives of S).2 &
  the_arity_of o = <*the bool-sort of S*> &
  the_result_sort_of o = the bool-sort of S
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).2, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 2 <= len the connectives of S by XXREAL_0:2;
    then 2 in dom the connectives of S by FINSEQ_3:25;
    hence o = (the connectives of S).2 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*the bool-sort of S*>, the bool-sort of S
    by AOFA_A00:def 31;
    hence the_arity_of o = <*the bool-sort of S*> &
    the_result_sort_of o = the bool-sort of S;
  end;

theorem Th13:
  for o being OperSymbol of S st
  o = In((the connectives of S).3, the carrier' of S)
  holds o = (the connectives of S).3 &
  the_arity_of o = <*the bool-sort of S, the bool-sort of S*> &
  the_result_sort_of o = the bool-sort of S
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).3, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 3 <= len the connectives of S by XXREAL_0:2;
    then 3 in dom the connectives of S by FINSEQ_3:25;
    hence o = (the connectives of S).3 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*the bool-sort of S, the bool-sort of S*>,
    the bool-sort of S by AOFA_A00:def 31;
    hence the_arity_of o = <*the bool-sort of S, the bool-sort of S*> &
    the_result_sort_of o = the bool-sort of S;
  end;

theorem Th14:
  for o being OperSymbol of S st
  o = In((the connectives of S).4, the carrier' of S)
  holds the_arity_of o = {} & the_result_sort_of o = I
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).4, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 4 <= len the connectives of S by XXREAL_0:2;
    then 4 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).4 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type {}, I by AOFA_A00:53;
    hence the_arity_of o = {} & the_result_sort_of o = I;
  end;

theorem Th15:
  for o being OperSymbol of S st
  o = In((the connectives of S).5, the carrier' of S)
  holds the_arity_of o = {} & the_result_sort_of o = I
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).5, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 5 <= len the connectives of S by XXREAL_0:2;
    then 5 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).5 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type {}, I by AOFA_A00:53;
    hence the_arity_of o = {} & the_result_sort_of o = I;
  end;

theorem Th16:
  for o being OperSymbol of S st
  o = In((the connectives of S).6, the carrier' of S)
  holds the_arity_of o = <*I*> & the_result_sort_of o = I
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).6, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 6 <= len the connectives of S by XXREAL_0:2;
    then 6 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).6 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*I*>, I by AOFA_A00:53;
    hence the_arity_of o = <*I*> & the_result_sort_of o = I;
  end;

theorem Th17:
  for o being OperSymbol of S st
  o = In((the connectives of S).7, the carrier' of S)
  holds the_arity_of o = <*I,I*> & the_result_sort_of o = I
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).7, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 7 <= len the connectives of S by XXREAL_0:2;
    then 7 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).7 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*I,I*>, I by AOFA_A00:53;
    hence the_arity_of o = <*I,I*> & the_result_sort_of o = I;
  end;

theorem Th18:
  for o being OperSymbol of S st
  o = In((the connectives of S).8, the carrier' of S)
  holds the_arity_of o = <*I,I*> & the_result_sort_of o = I
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).8, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 8 <= len the connectives of S by XXREAL_0:2;
    then 8 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).8 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*I,I*>, I by AOFA_A00:53;
    hence the_arity_of o = <*I,I*> & the_result_sort_of o = I;
  end;

theorem Th19:
  for o being OperSymbol of S st
  o = In((the connectives of S).9, the carrier' of S)
  holds the_arity_of o = <*I,I*> & the_result_sort_of o = I
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).9, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 9 <= len the connectives of S by XXREAL_0:2;
    then 9 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).9 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*I,I*>, I by AOFA_A00:53;
    hence the_arity_of o = <*I,I*> & the_result_sort_of o = I;
  end;

theorem Th20:
  for o being OperSymbol of S st
  o = In((the connectives of S).10, the carrier' of S)
  holds the_arity_of o = <*I,I*> & the_result_sort_of o = the bool-sort of S
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).10, the carrier' of S);
    4+6 <= len the connectives of S by AOFA_A00:def 39;
    then 10 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).10 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*I,I*>, the bool-sort of S by AOFA_A00:53;
    hence the_arity_of o = <*I,I*> & the_result_sort_of o = the bool-sort of S;
  end;

theorem Th21:
  for S being non empty non void ManySortedSign
  for o being OperSymbol of S st the_arity_of o = {}
  for A being MSAlgebra over S holds Args(o,A) = {{}}
  proof
    let S be non empty non void ManySortedSign;
    let o be OperSymbol of S;
    assume A1: the_arity_of o = {};
    let A be MSAlgebra over S;
    thus Args(o,A) = product ((the Sorts of A)*the_arity_of o) by PRALG_2:3
    .= {{}} by A1,CARD_3:10;
  end;

theorem Th22:
  for S being non empty non void ManySortedSign
  for a being SortSymbol of S
  for o being OperSymbol of S st the_arity_of o = <*a*>
  for A being MSAlgebra over S holds
  Args(o,A) = product <*(the Sorts of A).a*>
  proof
    let S be non empty non void ManySortedSign;
    let a be SortSymbol of S;
    let o be OperSymbol of S;
    assume A1: the_arity_of o = <*a*>;
    let A be MSAlgebra over S;
A2: dom the Sorts of A = the carrier of S by PARTFUN1:def 2;
    thus Args(o,A) = product ((the Sorts of A)*the_arity_of o) by PRALG_2:3
    .= product <*(the Sorts of A).a*> by A1,A2,FINSEQ_2:34;
  end;

theorem Th23:
  for S being non empty non void ManySortedSign
  for a,b being SortSymbol of S
  for o being OperSymbol of S st the_arity_of o = <*a,b*>
  for A being MSAlgebra over S holds
  Args(o,A) = product <*(the Sorts of A).a, (the Sorts of A).b*>
  proof
    let S be non empty non void ManySortedSign;
    let a,b be SortSymbol of S;
    let o be OperSymbol of S;
    assume A1: the_arity_of o = <*a,b*>;
    let A be MSAlgebra over S;
A2: dom the Sorts of A = the carrier of S by PARTFUN1:def 2;
    thus Args(o,A) = product ((the Sorts of A)*the_arity_of o) by PRALG_2:3
    .= product <*(the Sorts of A).a, (the Sorts of A).b*>
    by A1,A2,FINSEQ_2:125;
  end;

theorem Th24:
  for S being non empty non void ManySortedSign
  for a,b,c being SortSymbol of S
  for o being OperSymbol of S st the_arity_of o = <*a,b,c*>
  for A being MSAlgebra over S holds
  Args(o,A) = product <*(the Sorts of A).a, (the Sorts of A).b,
  (the Sorts of A).c*>
  proof
    let S be non empty non void ManySortedSign;
    let a,b,c be SortSymbol of S;
    let o be OperSymbol of S;
    assume A1: the_arity_of o = <*a,b,c*>;
    let A be MSAlgebra over S;
A2: dom the Sorts of A = the carrier of S by PARTFUN1:def 2;
    thus Args(o,A) = product ((the Sorts of A)*the_arity_of o) by PRALG_2:3
    .= product <*(the Sorts of A).a, (the Sorts of A).b, (the Sorts of A).c*>
    by A1,A2,FINSEQ_2:126;
  end;

theorem Th25:
  for S being non empty non void ManySortedSign
  for A,B being non-empty MSAlgebra over S
  for s being SortSymbol of S
  for a being Element of A,s
  for h being ManySortedFunction of A,B
  for o being OperSymbol of S st the_arity_of o = <*s*>
  for p being Element of Args(o,A)
  st p = <*a*> holds h#p = <*h.s.a*>
  proof
    let S be non empty non void ManySortedSign;
    let A,B be non-empty MSAlgebra over S;
    let s be SortSymbol of S;
    let a be Element of A,s;
    let h be ManySortedFunction of A,B;
    let o be OperSymbol of S such that
A1: the_arity_of o = <*s*>;
    let p be Element of Args(o,A);
    assume A2: p = <*a*>;
A3: dom p = dom the_arity_of o & dom(h#p) = dom the_arity_of o by MSUALG_3:6;
    then
A4: dom(h#p) = Seg 1 by A2,FINSEQ_1:38;
    then
A5: len p = 1 & len (h#p) = 1 by A3,FINSEQ_1:def 3;
    1 in Seg 1;
    then (h#p).1 = h.((the_arity_of o)/.1).(p.1) by A3,A4,MSUALG_3:def 6
    .= h.s.(p.1) by A1,FINSEQ_4:16 .= h.s.a by A2,FINSEQ_1:40;
    hence h#p = <*h.s.a*> by A5,FINSEQ_1:40;
  end;

theorem Th26:
  for S being non empty non void ManySortedSign
  for A,B being non-empty MSAlgebra over S
  for s1,s2 being SortSymbol of S
  for a being Element of A,s1, b being Element of A,s2
  for h being ManySortedFunction of A,B
  for o being OperSymbol of S st the_arity_of o = <*s1,s2*>
  for p being Element of Args(o,A)
  st p = <*a,b*> holds h#p = <*h.s1.a, h.s2.b*>
  proof
    let S be non empty non void ManySortedSign;
    let A,B be non-empty MSAlgebra over S;
    let s1,s2 be SortSymbol of S;
    let a be Element of A,s1, b be Element of A,s2;
    let h be ManySortedFunction of A,B;
    let o be OperSymbol of S such that
A1: the_arity_of o = <*s1,s2*>;
    let p be Element of Args(o,A);
    assume A2: p = <*a,b*>;
A3: dom p = dom the_arity_of o & dom(h#p) = dom the_arity_of o by MSUALG_3:6;
    then
A4: dom(h#p) = Seg 2 by A2,FINSEQ_1:89;
    then
A5: len <*a,b*> = 2 & len (h#p) = 2 by A2,A3,FINSEQ_1:def 3;
    1 in Seg 2;
    then
A6: (h#p).1 = h.((the_arity_of o)/.1).(p.1) by A3,A4,MSUALG_3:def 6
    .= h.s1.(p.1) by A1,FINSEQ_4:17 .= h.s1.a by A2,FINSEQ_1:44;
    2 in Seg 2;
    then (h#p).2 = h.((the_arity_of o)/.2).(p.2) by A3,A4,MSUALG_3:def 6
    .= h.s2.(p.2) by A1,FINSEQ_4:17 .= h.s2.b by A2,FINSEQ_1:44;
    hence h#p = <*h.s1.a, h.s2.b*> by A5,A6,FINSEQ_1:44;
  end;

theorem Th27:
  for S being non empty non void ManySortedSign
  for A,B being non-empty MSAlgebra over S
  for s1,s2,s3 being SortSymbol of S
  for a being Element of A,s1, b being Element of A,s2, c being Element of A,s3
  for h being ManySortedFunction of A,B
  for o being OperSymbol of S st the_arity_of o = <*s1,s2,s3*>
  for p being Element of Args(o,A)
  st p = <*a,b,c*> holds h#p = <*h.s1.a,h.s2.b,h.s3.c*>
  proof
    let S be non empty non void ManySortedSign;
    let A,B be non-empty MSAlgebra over S;
    let s1,s2,s3 be SortSymbol of S;
    let a be Element of A,s1;
    let b be Element of A,s2;
    let c be Element of A,s3;
    let h be ManySortedFunction of A,B;
    let o be OperSymbol of S such that
A1: the_arity_of o = <*s1,s2,s3*>;
    let p be Element of Args(o,A);
    assume A2: p = <*a,b,c*>;
A3: dom p = dom the_arity_of o & dom(h#p) = dom the_arity_of o by MSUALG_3:6;
    then
A4: dom(h#p) = Seg 3 by A2,FINSEQ_1:89;
    then
A5: len p = 3 & len (h#p) = 3 by A3,FINSEQ_1:def 3;
    1 in Seg 3;
    then
A6: (h#p).1 = h.((the_arity_of o)/.1).(p.1) by A3,A4,MSUALG_3:def 6
    .= h.s1.(p.1) by A1,FINSEQ_4:18 .= h.s1.a by A2,FINSEQ_1:45;
    2 in Seg 3;
    then
A7: (h#p).2 = h.((the_arity_of o)/.2).(p.2) by A3,A4,MSUALG_3:def 6
    .= h.s2.(p.2) by A1,FINSEQ_4:18 .= h.s2.b by A2,FINSEQ_1:45;
    3 in Seg 3;
    then (h#p).3 = h.((the_arity_of o)/.3).(p.3) by A3,A4,MSUALG_3:def 6
    .= h.s3.(p.3) by A1,FINSEQ_4:18 .= h.s3.c by A2,FINSEQ_1:45;
    hence h#p = <*h.s1.a,h.s2.b,h.s3.c*> by A5,A6,A7,FINSEQ_1:45;
  end;

theorem Th28:
  for h being ManySortedFunction of T,C st h is_homomorphism T,C
  for a being SortSymbol of S
  for t being Element of T,a
  holds t value_at(C,h||FreeGen T) = h.a.t
  proof
    let h be ManySortedFunction of T,C;
    assume A1: h is_homomorphism T,C;
    set s = h||FreeGen T;
    let a be SortSymbol of S;
    let t be Element of T,a;
    FreeGen T is_transformable_to the Sorts of C by MSAFREE4:21;
    then
A2: doms s = FreeGen T by MSSUBFAM:17;
    thus t value_at(C,s) = h.a.t by A2,A1,AOFA_A00:def 21;
  end;

theorem Th29:
  for h being ManySortedFunction of T,C
  st h is_homomorphism T,C & s = h||the generators of G
  for a being SortSymbol of S
  for t being Element of T,a
  holds t value_at(C,s) = h.a.t
  proof
    let h be ManySortedFunction of T,C;
    assume A1: h is_homomorphism T,C;
    assume A2: s = h||the generators of G;
    let a be SortSymbol of S;
    let t be Element of T,a;
A3: s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    the generators of G is_transformable_to the Sorts of C by MSAFREE4:21;
    then
A4: doms s = the generators of G by A3,MSSUBFAM:17;
    thus t value_at(C,s) = h.a.t by A4,A1,A2,AOFA_A00:def 21;
  end;

theorem Th30:
  \trueT value_at(C,s) = TRUE
  proof
A1: s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A2: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
    the generators of G is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
    doms s = the generators of G by A1,MSSUBFAM:17;
    then consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A3: f is_homomorphism T,C & Q = doms s & s = f||Q &
    \trueT value_at(C,s) = f.(the bool-sort of S).\trueT by A2,AOFA_A00:def 21;
    set o = In((the connectives of S).1, the carrier' of S);
A4: o = (the connectives of S).1 &
    the_arity_of o = {} & the_result_sort_of o = the bool-sort of S by Th11;
    then
    Args(o,T) = {{}} by Th21;
    then reconsider p = {} as Element of Args(o,T) by TARSKI:def 1;
    dom(f#p) = {} & dom p = {} by A4,MSUALG_3:6;
    then
A5: p = f#p;
    f.(the bool-sort of S).\trueT
    = \trueC by A5,A3,A4
    .= TRUE by AOFA_A00:def 32;
    hence thesis by A3;
  end;

theorem Th31:
  for t being Element of T, the bool-sort of S holds
  \nott value_at(C,s) = \not(t value_at(C,s))
  proof
    let t be Element of T, the bool-sort of S;
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
A2: (\nott) value_at(C,s) = f.(the bool-sort of S).(\nott) by A1,Th29;
    set o = In((the connectives of S).2, the carrier' of S);
A3: the_arity_of o = <*the bool-sort of S*> &
    the_result_sort_of o = the bool-sort of S by Th12;
    then Args(o,T) = product <*(the Sorts of T).the bool-sort of S*> by Th22;
    then reconsider p = <*t*> as Element of Args(o,T) by FINSEQ_3:123;
    thus (\nott) value_at(C,s) = Den(o,C).(f#p) by A1,A2,A3
    .= Den(o,C).<*f.(the bool-sort of S).t*> by A3,Th25
    .= \not(t value_at(C,s)) by A1,Th29;
  end;

theorem
  for a being boolean object
  for t being Element of T, the bool-sort of S holds
  \nott value_at(C,s) = 'not' a iff t value_at(C,s) = a
  proof
    let a be boolean object;
    let t be Element of T, the bool-sort of S;
    hereby
      assume \nott value_at(C,s) = 'not' a;
      then \not(t value_at(C,s)) = 'not' a by Th31;
      then 'not' (t value_at(C,s)) = 'not' a by AOFA_A00:def 32;
      hence t value_at(C,s) = a;
    end;
    assume A1: t value_at(C,s) = a;
    \not(t value_at(C,s)) = \nott value_at(C,s) by Th31;
    hence \nott value_at(C,s) = 'not' a by A1,AOFA_A00:def 32;
  end;

theorem Th33:
  for a being Element of C, the bool-sort of S
  for x being boolean object holds
  \nota = 'not' x iff a = x
  proof
    let a be Element of C, the bool-sort of S;
    a in (the Sorts of C).the bool-sort of S;
    then a in BOOLEAN by AOFA_A00:def 32;
    then reconsider b = a as boolean object;
    let x be boolean object;
    hereby
      assume \nota = 'not' x;
      then 'not' b = 'not' x by AOFA_A00:def 32;
      hence a = x;
    end;
    assume a = x;
    hence \nota = 'not' x by AOFA_A00:def 32;
  end;

theorem
  (\falseT) value_at(C,s) = FALSE
  proof
    thus (\falseT) value_at(C,s) = \not((\trueT) value_at(C,s)) by Th31
    .= 'not' ((\trueT) value_at(C,s)) by AOFA_A00:def 32 .= 'not' TRUE by Th30
    .= FALSE;
end;

theorem
  for t1,t2 being Element of T, the bool-sort of S holds
  t1\andt2 value_at(C,s) = (t1 value_at(C,s))\and(t2 value_at(C,s))
  proof
    let t1,t2 be Element of T, the bool-sort of S;
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
A2: t1 value_at(C,s) = f.(the bool-sort of S).t1 by A1,Th29;
A3: t1\andt2 value_at(C,s) = f.(the bool-sort of S).(t1\andt2) by A1,Th29;
    set o = In((the connectives of S).3, the carrier' of S);
A4: the_arity_of o = <*the bool-sort of S,the bool-sort of S*> &
    the_result_sort_of o = the bool-sort of S by Th13;
    then Args(o,T) = product <*(the Sorts of T).the bool-sort of S,
    (the Sorts of T).the bool-sort of S*> by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t1\andt2) value_at(C,s) = Den(o,C).(f#p)
    by A1,A3,A4
    .= Den(o,C).<*f.(the bool-sort of S).t1,f.(the bool-sort of S).t2*>
    by A4,Th26
    .= (t1 value_at(C,s))\and(t2 value_at(C,s)) by A2,A1,Th29;
  end;

theorem Th36:
  \0(T,I) value_at(C,s) = 0
  proof
A1: s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A2: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
    the generators of G is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
    doms s = the generators of G by A1,MSSUBFAM:17;
    then consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A3: f is_homomorphism T,C & Q = doms s & s = f||Q &
    \0(T,I) value_at(C,s) = f.I.\0(T,I) by A2,AOFA_A00:def 21;
    set o = In((the connectives of S).4, the carrier' of S);
A4: the_arity_of o = {} & the_result_sort_of o = I by Th14;
    then
    Args(o,T) = {{}} by Th21;
    then reconsider p = {} as Element of Args(o,T) by TARSKI:def 1;
    dom(f#p) = {} & dom p = {} by A4,MSUALG_3:6;
    then
A5: p = f#p;
    f.I.\0(T,I)
    = \0(C,I) by A5,A3,A4 .= 0 by AOFA_A00:55;
    hence thesis by A3;
  end;

theorem Th37:
  \1(T,I) value_at(C,s) = 1
  proof
A1: s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A2: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
    the generators of G is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
    doms s = the generators of G by A1,MSSUBFAM:17;
    then consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A3: f is_homomorphism T,C & Q = doms s & s = f||Q &
    \1(T,I) value_at(C,s) = f.I.\1(T,I) by A2,AOFA_A00:def 21;
    set o = In((the connectives of S).5, the carrier' of S);
A4: the_arity_of o = {} & the_result_sort_of o = I by Th15;
    then
    Args(o,T) = {{}} by Th21;
    then reconsider p = {} as Element of Args(o,T) by TARSKI:def 1;
    dom(f#p) = {} & dom p = {} by A4,MSUALG_3:6;
    then
A5: p = f#p;
    f.I.\1(T,I)
    = \1(C,I) by A5,A3,A4 .= 1 by AOFA_A00:55;
    hence thesis by A3;
  end;

theorem Th38:
  (-t) value_at(C,s) = -(t value_at(C,s))
  proof
A1: s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A2: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
    the generators of G is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
A3: doms s = the generators of G by A1,MSSUBFAM:17;
    then consider f1 being ManySortedFunction of T,C,
    Q1 being GeneratorSet of T such that
A4: f1 is_homomorphism T,C & Q1 = doms s & s = f1||Q1 &
    t value_at(C,s) = f1.I.t by A2,AOFA_A00:def 21;
    consider f2 being ManySortedFunction of T,C,
    Q2 being GeneratorSet of T such that
A5: f2 is_homomorphism T,C & Q2 = doms s & s = f2||Q2 &
    (-t) value_at(C,s) = f2.I.(-t) by A2,A3,AOFA_A00:def 21;
    set o = In((the connectives of S).6, the carrier' of S);
A6: the_arity_of o = <*I*> & the_result_sort_of o = I by Th16;
    then Args(o,T) = product <*(the Sorts of T).I*> by Th22;
    then reconsider p = <*t*> as Element of Args(o,T) by FINSEQ_3:123;
    thus (-t) value_at(C,s) = Den(o,C).(f2#p) by A5,A6
    .= Den(o,C).<*f2.I.t*> by A6,Th25
    .= -(t value_at(C,s)) by A4,A5,EXTENS_1:19;
  end;

theorem Th39:
  (t1+t2) value_at(C,s) = (t1 value_at(C,s))+(t2 value_at(C,s))
  proof
A1: s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A2: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
    the generators of G is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
A3: doms s = the generators of G by A1,MSSUBFAM:17;
    then consider f1 being ManySortedFunction of T,C,
    Q1 being GeneratorSet of T such that
A4: f1 is_homomorphism T,C & Q1 = doms s & s = f1||Q1 &
    t1 value_at(C,s) = f1.I.t1 by A2,AOFA_A00:def 21;
    consider f2 being ManySortedFunction of T,C,
    Q2 being GeneratorSet of T such that
A5: f2 is_homomorphism T,C & Q2 = doms s & s = f2||Q2 &
    t2 value_at(C,s) = f2.I.t2 by A2,A3,AOFA_A00:def 21;
    consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A6: f is_homomorphism T,C & Q = doms s & s = f||Q &
    (t1+t2) value_at(C,s) = f.I.(t1+t2) by A2,A3,AOFA_A00:def 21;
A7: f = f1 & f = f2 by A4,A5,A6,EXTENS_1:19;
    set o = In((the connectives of S).7, the carrier' of S);
A8: the_arity_of o = <*I,I*> & the_result_sort_of o = I by Th17;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t1+t2) value_at(C,s) = Den(o,C).(f#p) by A6,A8
    .= (t1 value_at(C,s))+(t2 value_at(C,s)) by A4,A5,A7,A8,Th26;
  end;

theorem Th40:
  \2(T,I) value_at (C,s) = 2
  proof
A1: \1(T,I) value_at(C,s) = 1 by Th37;
    thus \2(T,I) value_at(C,s)
    = (\1(T,I) value_at(C,s))+(\1(T,I) value_at(C,s)) by Th39
    .= 2 by A1,AOFA_A00:55;
  end;

theorem Th41:
  (t1-t2) value_at(C,s) = (t1 value_at(C,s))-(t2 value_at(C,s))
  proof
    thus (t1-t2) value_at(C,s) = (t1 value_at(C,s))+((-t2) value_at(C,s))
    by Th39
    .= (t1 value_at(C,s))-(t2 value_at(C,s)) by Th38;
  end;

theorem Th42:
  (t1*t2) value_at(C,s) = (t1 value_at(C,s))*(t2 value_at(C,s))
  proof
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
A2: t2 value_at(C,s) = f.I.t2 by A1,Th29;
A3: (t1*t2) value_at(C,s) = f.I.(t1*t2) by A1,Th29;
    set o = In((the connectives of S).8, the carrier' of S);
A4: the_arity_of o = <*I,I*> & the_result_sort_of o = I by Th18;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t1*t2) value_at(C,s) = Den(o,C).(f#p) by A1,A3,A4
    .= Den(o,C).<*f.I.t1,f.I.t2*> by A4,Th26
    .= (t1 value_at(C,s))*(t2 value_at(C,s)) by A1,A2,Th29;
  end;

theorem Th43:
  (t1 div t2) value_at(C,s) = (t1 value_at(C,s))div(t2 value_at(C,s))
  proof
A1: s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A2: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
    the generators of G is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
A3: doms s = the generators of G by A1,MSSUBFAM:17;
    then consider f1 being ManySortedFunction of T,C,
    Q1 being GeneratorSet of T such that
A4: f1 is_homomorphism T,C & Q1 = doms s & s = f1||Q1 &
    t1 value_at(C,s) = f1.I.t1 by A2,AOFA_A00:def 21;
    consider f2 being ManySortedFunction of T,C,
    Q2 being GeneratorSet of T such that
A5: f2 is_homomorphism T,C & Q2 = doms s & s = f2||Q2 &
    t2 value_at(C,s) = f2.I.t2 by A2,A3,AOFA_A00:def 21;
    consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A6: f is_homomorphism T,C & Q = doms s & s = f||Q &
    (t1 div t2) value_at(C,s) = f.I.(t1 div t2) by A2,A3,AOFA_A00:def 21;
A7: f = f1 & f = f2 by A4,A5,A6,EXTENS_1:19;
    set o = In((the connectives of S).9, the carrier' of S);
A8: the_arity_of o = <*I,I*> & the_result_sort_of o = I by Th19;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t1 div t2) value_at(C,s) = Den(o,C).(f#p) by A6,A8
    .= (t1 value_at(C,s))div(t2 value_at(C,s)) by A4,A5,A7,A8,Th26;
  end;

theorem Th44:
  (t1 mod t2) value_at(C,s) = (t1 value_at(C,s)) mod (t2 value_at(C,s))
  proof
    thus (t1 mod t2) value_at(C,s) = (t1-(t1 div t2)*t2) value_at(C,s)
    .= (t1 value_at(C,s))-(((t1 div t2)*t2) value_at(C,s)) by Th41
    .= (t1 value_at(C,s))-(((t1 div t2) value_at(C,s))*(t2 value_at(C,s)))
    by Th42
    .= (t1 value_at(C,s)) mod (t2 value_at(C,s)) by Th43;
  end;

theorem Th45:
  leq(t1,t2) value_at(C,s) = leq(t1 value_at(C,s), t2 value_at(C,s))
  proof
A1: s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A2: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
    the generators of G is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
A3: doms s = the generators of G by A1,MSSUBFAM:17;
    then consider f1 being ManySortedFunction of T,C,
    Q1 being GeneratorSet of T such that
A4: f1 is_homomorphism T,C & Q1 = doms s & s = f1||Q1 &
    t1 value_at(C,s) = f1.I.t1 by A2,AOFA_A00:def 21;
    consider f2 being ManySortedFunction of T,C,
    Q2 being GeneratorSet of T such that
A5: f2 is_homomorphism T,C & Q2 = doms s & s = f2||Q2 &
    t2 value_at(C,s) = f2.I.t2 by A2,A3,AOFA_A00:def 21;
    consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A6: f is_homomorphism T,C & Q = doms s & s = f||Q &
    leq(t1,t2) value_at(C,s) = f.(the bool-sort of S).leq(t1,t2)
    by A2,A3,AOFA_A00:def 21;
A7: f = f1 & f = f2 by A4,A5,A6,EXTENS_1:19;
    set o = In((the connectives of S).10, the carrier' of S);
A8: the_arity_of o = <*I,I*> & the_result_sort_of o = the bool-sort of S
    by Th20;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus leq(t1,t2) value_at(C,s) = Den(o,C).(f#p) by A6,A8
    .= leq(t1 value_at(C,s), t2 value_at(C,s)) by A4,A5,A7,A8,Th26;
  end;

theorem Th46:
  \trueT value_at(C,u) = TRUE
  proof
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
    FreeGen T is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
    doms u = FreeGen T by MSSUBFAM:17;
    then consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A2: f is_homomorphism T,C & Q = doms u & u = f||Q &
    \trueT value_at(C,u) = f.(the bool-sort of S).\trueT by A1,AOFA_A00:def 21;
    set o = In((the connectives of S).1, the carrier' of S);
A3: o = (the connectives of S).1 &
    the_arity_of o = {} & the_result_sort_of o = the bool-sort of S by Th11;
    then
    Args(o,T) = {{}} by Th21;
    then reconsider p = {} as Element of Args(o,T) by TARSKI:def 1;
    dom(f#p) = {} & dom p = {} by A3,MSUALG_3:6;
    then
A4: p = f#p;
    f.(the bool-sort of S).\trueT = \trueC by A4,A2,A3
    .= TRUE by AOFA_A00:def 32;
    hence thesis by A2;
  end;

theorem Th47:
  for t being Element of T, the bool-sort of S holds
  \nott value_at(C,u) = \not(t value_at(C,u))
  proof
    let t be Element of T, the bool-sort of S;
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
A2: (\nott) value_at(C,u) = f.(the bool-sort of S).(\nott) by A1,Th28;
    set o = In((the connectives of S).2, the carrier' of S);
A3: the_arity_of o = <*the bool-sort of S*> &
    the_result_sort_of o = the bool-sort of S by Th12;
    then Args(o,T) = product <*(the Sorts of T).the bool-sort of S*> by Th22;
    then reconsider p = <*t*> as Element of Args(o,T) by FINSEQ_3:123;
    thus (\nott) value_at(C,u) = Den(o,C).(f#p) by A1,A2,A3
    .= Den(o,C).<*f.(the bool-sort of S).t*> by A3,Th25
    .= \not(t value_at(C,u)) by A1,Th28;
  end;

theorem
  for a being boolean object
  for t being Element of T, the bool-sort of S holds
  \nott value_at(C,u) = 'not' a iff t value_at(C,u) = a
  proof
    let a be boolean object;
    let t be Element of T, the bool-sort of S;
    hereby
      assume \nott value_at(C,u) = 'not' a;
      then \not(t value_at(C,u)) = 'not' a by Th47;
      then 'not' (t value_at(C,u)) = 'not' a by AOFA_A00:def 32;
      hence t value_at(C,u) = a;
    end;
    assume A1: t value_at(C,u) = a;
    \not(t value_at(C,u)) = \nott value_at(C,u) by Th47;
    hence \nott value_at(C,u) = 'not' a by A1,AOFA_A00:def 32;
  end;

theorem
  (\falseT) value_at(C,u) = FALSE
  proof
    thus (\falseT) value_at(C,u) = \not((\trueT) value_at(C,u)) by Th47
    .= 'not' ((\trueT) value_at(C,u)) by AOFA_A00:def 32 .= 'not' TRUE by Th46
    .= FALSE;
  end;

theorem
  for t1,t2 being Element of T, the bool-sort of S holds
  t1\andt2 value_at(C,u) = (t1 value_at(C,u))\and(t2 value_at(C,u))
  proof
    let t1,t2 be Element of T, the bool-sort of S;
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
A2: t1 value_at(C,u) = f.(the bool-sort of S).t1 by A1,Th28;
A3: t1\andt2 value_at(C,u) = f.(the bool-sort of S).(t1\andt2) by A1,Th28;
    set o = In((the connectives of S).3, the carrier' of S);
A4: the_arity_of o = <*the bool-sort of S,the bool-sort of S*> &
    the_result_sort_of o = the bool-sort of S by Th13;
    then Args(o,T) = product <*(the Sorts of T).the bool-sort of S,
    (the Sorts of T).the bool-sort of S*> by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t1\andt2) value_at(C,u) = Den(o,C).(f#p)
    by A1,A3,A4
    .= Den(o,C).<*f.(the bool-sort of S).t1,f.(the bool-sort of S).t2*>
    by A4,Th26
    .= (t1 value_at(C,u))\and(t2 value_at(C,u)) by A2,A1,Th28;
  end;

theorem
  \0(T,I) value_at(C,u) = 0
  proof
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
    FreeGen T is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
    doms u = FreeGen T by MSSUBFAM:17;
    then consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A2: f is_homomorphism T,C & Q = doms u & u = f||Q &
    \0(T,I) value_at(C,u) = f.I.\0(T,I) by A1,AOFA_A00:def 21;
    set o = In((the connectives of S).4, the carrier' of S);
A3: the_arity_of o = {} & the_result_sort_of o = I by Th14;
    then
    Args(o,T) = {{}} by Th21;
    then reconsider p = {} as Element of Args(o,T) by TARSKI:def 1;
    dom(f#p) = {} & dom p = {} by A3,MSUALG_3:6;
    then
A4: p = f#p;
    f.I.\0(T,I) = \0(C,I) by A4,A2,A3 .= 0 by AOFA_A00:55;
    hence thesis by A2;
  end;

theorem Th52:
  \1(T,I) value_at(C,u) = 1
  proof
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
    FreeGen T is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
    doms u = FreeGen T by MSSUBFAM:17;
    then consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A2: f is_homomorphism T,C & Q = doms u & u = f||Q &
    \1(T,I) value_at(C,u) = f.I.\1(T,I) by A1,AOFA_A00:def 21;
    set o = In((the connectives of S).5, the carrier' of S);
A3: the_arity_of o = {} & the_result_sort_of o = I by Th15;
    then
    Args(o,T) = {{}} by Th21;
    then reconsider p = {} as Element of Args(o,T) by TARSKI:def 1;
    dom(f#p) = {} & dom p = {} by A3,MSUALG_3:6;
    then
A4: p = f#p;
    f.I.\1(T,I) = \1(C,I) by A4,A2,A3 .= 1 by AOFA_A00:55;
    hence thesis by A2;
  end;

theorem Th53:
  (-t) value_at(C,u) = -(t value_at(C,u))
  proof
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
    FreeGen T is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
A2: doms u = FreeGen T by MSSUBFAM:17;
    then consider f1 being ManySortedFunction of T,C,
    Q1 being GeneratorSet of T such that
A3: f1 is_homomorphism T,C & Q1 = doms u & u = f1||Q1 &
    t value_at(C,u) = f1.I.t by A1,AOFA_A00:def 21;
    consider f2 being ManySortedFunction of T,C,
    Q2 being GeneratorSet of T such that
A4: f2 is_homomorphism T,C & Q2 = doms u & u = f2||Q2 &
    (-t) value_at(C,u) = f2.I.(-t) by A1,A2,AOFA_A00:def 21;
    set o = In((the connectives of S).6, the carrier' of S);
A5: the_arity_of o = <*I*> & the_result_sort_of o = I by Th16;
    then Args(o,T) = product <*(the Sorts of T).I*> by Th22;
    then reconsider p = <*t*> as Element of Args(o,T) by FINSEQ_3:123;
    thus (-t) value_at(C,u) = Den(o,C).(f2#p) by A4,A5
    .= Den(o,C).<*f2.I.t*> by A5,Th25
    .= -(t value_at(C,u)) by A3,A4,EXTENS_1:19;
  end;

theorem Th54:
  (t1+t2) value_at(C,u) = (t1 value_at(C,u))+(t2 value_at(C,u))
  proof
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
    FreeGen T is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
A2: doms u = FreeGen T by MSSUBFAM:17;
    then consider f1 being ManySortedFunction of T,C,
    Q1 being GeneratorSet of T such that
A3: f1 is_homomorphism T,C & Q1 = doms u & u = f1||Q1 &
    t1 value_at(C,u) = f1.I.t1 by A1,AOFA_A00:def 21;
    consider f2 being ManySortedFunction of T,C,
    Q2 being GeneratorSet of T such that
A4: f2 is_homomorphism T,C & Q2 = doms u & u = f2||Q2 &
    t2 value_at(C,u) = f2.I.t2 by A1,A2,AOFA_A00:def 21;
    consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A5: f is_homomorphism T,C & Q = doms u & u = f||Q &
    (t1+t2) value_at(C,u) = f.I.(t1+t2) by A1,A2,AOFA_A00:def 21;
A6: f = f1 & f = f2 by A3,A4,A5,EXTENS_1:19;
    set o = In((the connectives of S).7, the carrier' of S);
A7: the_arity_of o = <*I,I*> & the_result_sort_of o = I by Th17;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t1+t2) value_at(C,u) = Den(o,C).(f#p) by A5,A7
    .= Den(o,C).<*f.I.t1,f.I.t2*> by A7,Th26
    .= (t1 value_at(C,u))+(t2 value_at(C,u)) by A3,A4,A6;
  end;

theorem
  \2(T,I) value_at (C,u) = 2
  proof
A1: \1(T,I) value_at(C,u) = 1 by Th52;
    thus \2(T,I) value_at(C,u)
    = (\1(T,I) value_at(C,u))+(\1(T,I) value_at(C,u)) by Th54
    .= 2 by A1,AOFA_A00:55;
  end;

theorem Th56:
  (t1-t2) value_at(C,u) = (t1 value_at(C,u))-(t2 value_at(C,u))
  proof
    thus (t1-t2) value_at(C,u) = (t1 value_at(C,u))+((-t2) value_at(C,u))
    by Th54
    .= (t1 value_at(C,u))-(t2 value_at(C,u)) by Th53;
  end;

theorem Th57:
  (t1*t2) value_at(C,u) = (t1 value_at(C,u))*(t2 value_at(C,u))
  proof
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
A2: t2 value_at(C,u) = f.I.t2 by A1,Th28;
A3: (t1*t2) value_at(C,u) = f.I.(t1*t2) by A1,Th28;
    set o = In((the connectives of S).8, the carrier' of S);
A4: the_arity_of o = <*I,I*> & the_result_sort_of o = I by Th18;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t1*t2) value_at(C,u) = Den(o,C).(f#p) by A1,A3,A4
    .= Den(o,C).<*f.I.t1,f.I.t2*> by A4,Th26
    .= (t1 value_at(C,u))*(t2 value_at(C,u)) by A1,A2,Th28;
  end;

theorem Th58:
  (t1 div t2) value_at(C,u) = (t1 value_at(C,u))div(t2 value_at(C,u))
  proof
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
    FreeGen T is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
A2: doms u = FreeGen T by MSSUBFAM:17;
    then consider f1 being ManySortedFunction of T,C,
    Q1 being GeneratorSet of T such that
A3: f1 is_homomorphism T,C & Q1 = doms u & u = f1||Q1 &
    t1 value_at(C,u) = f1.I.t1 by A1,AOFA_A00:def 21;
    consider f2 being ManySortedFunction of T,C,
    Q2 being GeneratorSet of T such that
A4: f2 is_homomorphism T,C & Q2 = doms u & u = f2||Q2 &
    t2 value_at(C,u) = f2.I.t2 by A1,A2,AOFA_A00:def 21;
    consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A5: f is_homomorphism T,C & Q = doms u & u = f||Q &
    (t1 div t2) value_at(C,u) = f.I.(t1 div t2) by A1,A2,AOFA_A00:def 21;
A6: f = f1 & f = f2 by A3,A4,A5,EXTENS_1:19;
    set o = In((the connectives of S).9, the carrier' of S);
A7: the_arity_of o = <*I,I*> & the_result_sort_of o = I by Th19;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t1 div t2) value_at(C,u) = Den(o,C).(f#p) by A5,A7
    .= (t1 value_at(C,u))div(t2 value_at(C,u)) by A3,A4,A6,A7,Th26;
  end;

theorem
  (t1 mod t2) value_at(C,u) = (t1 value_at(C,u)) mod (t2 value_at(C,u))
  proof
    thus (t1 mod t2) value_at(C,u) = (t1-(t1 div t2)*t2) value_at(C,u)
    .= (t1 value_at(C,u))-(((t1 div t2)*t2) value_at(C,u)) by Th56
    .= (t1 value_at(C,u))-(((t1 div t2) value_at(C,u))*(t2 value_at(C,u)))
    by Th57
    .= (t1 value_at(C,u)) mod (t2 value_at(C,u)) by Th58;
  end;

theorem
  leq(t1,t2) value_at(C,u) = leq(t1 value_at(C,u), t2 value_at(C,u))
  proof
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
    FreeGen T is_transformable_to the Sorts of C
    by MSAFREE4:21;
    then
A2: doms u = FreeGen T by MSSUBFAM:17;
    then consider f1 being ManySortedFunction of T,C,
    Q1 being GeneratorSet of T such that
A3: f1 is_homomorphism T,C & Q1 = doms u & u = f1||Q1 &
    t1 value_at(C,u) = f1.I.t1 by A1,AOFA_A00:def 21;
    consider f2 being ManySortedFunction of T,C,
    Q2 being GeneratorSet of T such that
A4: f2 is_homomorphism T,C & Q2 = doms u & u = f2||Q2 &
    t2 value_at(C,u) = f2.I.t2 by A1,A2,AOFA_A00:def 21;
    consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A5: f is_homomorphism T,C & Q = doms u & u = f||Q &
    leq(t1,t2) value_at(C,u) = f.(the bool-sort of S).leq(t1,t2)
    by A1,A2,AOFA_A00:def 21;
A6: f = f1 & f = f2 by A3,A4,A5,EXTENS_1:19;
    set o = In((the connectives of S).10, the carrier' of S);
A7: the_arity_of o = <*I,I*> & the_result_sort_of o = the bool-sort of S
    by Th20;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus leq(t1,t2) value_at(C,u) = Den(o,C).(f#p) by A5,A7
    .= leq(t1 value_at(C,u), t2 value_at(C,u)) by A3,A4,A6,A7,Th26;
  end;

theorem Th61:
  for a being SortSymbol of S
  for x being Element of (the generators of G).a holds
  @x value_at(C,s) = s.a.x
  proof
    let a be SortSymbol of S;
    let x be Element of (the generators of G).a;
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider h being ManySortedFunction of T,C such that
A1: h is_homomorphism T,C & s = h||the generators of G by AOFA_A00:def 19;
    @x value_at(C,s) = h.a.x by A1,Th29 .= ((h.a)|((the generators of G).a)).x
    by FUNCT_1:49;
    hence @x value_at(C,s) = s.a.x by A1,MSAFREE:def 1;
  end;

theorem Th62:
  for a being SortSymbol of S
  for x being pure Element of (the generators of G).a
  for u being ManySortedFunction of FreeGen T, the Sorts of C holds
  @x value_at(C,u) = u.a.x
  proof
    let a be SortSymbol of S;
    let x be pure Element of (the generators of G).a;
    let u be ManySortedFunction of FreeGen T, the Sorts of C;
    consider h being ManySortedFunction of T,C such that
A1: h is_homomorphism T,C & u = h||FreeGen T by MSAFREE4:46;
    FreeGen T is_transformable_to the Sorts of C by MSAFREE4:21;
    then
A2: doms u = FreeGen T by MSSUBFAM:17;
    then consider f being ManySortedFunction of T,C,
    Q being GeneratorSet of T such that
A3: f is_homomorphism T,C & Q = doms u & u = f||Q & @x value_at(C,u) = f.a.@x
    by A1,AOFA_A00:def 21;
    @x value_at(C,u) = h.a.x by A1,A2,A3,EXTENS_1:19
    .= ((h.a)|((FreeGen T).a)).x by Def4,FUNCT_1:49;
    hence @x value_at(C,u) = u.a.x by A1,MSAFREE:def 1;
  end;

theorem Th63:
  for i,j being Integer, a,b being Element of C,I st a = i & b = j
  holds a-b = i-j
  proof
    let i,j be Integer;
    let a,b be Element of C,I;
    assume A1: a = i;
    assume b = j;
    then -b = -j by AOFA_A00:55;
    then a+-b = i+-j by A1,AOFA_A00:55;
    hence a-b = i-j;
  end;

theorem Th64:
  for i,j being Integer, a,b being Element of C,I st a = i & b = j & j <> 0
  holds a mod b = i mod j
  proof
    let i,j be Integer;
    let a,b be Element of C,I;
    assume A1: a = i;
    assume A2: b = j;
    assume A3: j <> 0;
    then a div b = i div j by A1,A2,AOFA_A00:55;
    then (a div b)*b = (i div j)*j by A2,AOFA_A00:55;
    then a-(a div b)*b = i-(i div j)*j by A1,Th63;
    hence a mod b = i mod j by A3,INT_1:def 10;
  end;

theorem Th65:
  G is C-supported & f in C-Execution(A,b,\falseC) implies
  for a being SortSymbol of S, x being pure Element of (the generators of G).a
  for t being Element of T,a
  holds
  f.(s,x:=(t,A)).a.x = t value_at(C,s) &
  (for z being pure Element of (the generators of G).a st z <> x
  holds f.(s, x:=(t,A)).a.z = s.a.z) &
  for b being SortSymbol of S st a <> b holds
  (for z being pure Element of (the generators of G).b holds
  f.(s, x:=(t,A)).b.z = s.b.z)
  proof
    assume
A1: G is C-supported;
    assume
A2: f in C-Execution(A,b,\falseC);
    let a be SortSymbol of S;
    let x be pure Element of (the generators of G).a;
    let t be Element of T,a;
    reconsider x0 = @x as Element of G,a by AOFA_A00:def 22;
    thus
    f.(s, x:=(t,A)).a.x = succ(s,x0,t value_at(C,s)).a.x by A2,AOFA_A00:def 28
    .= t value_at(C,s) by A1,AOFA_A00:def 27;
    hereby
      let z be pure Element of (the generators of G).a; assume
A3:   z <> x;
A4:   x in (FreeGen T).a & z in (FreeGen T).a &
      FreeGen X is ManySortedSubset of the generators of G
      by A1,Def4;
      then vf @x = a-singleton(x) & FreeGen X c= the generators of G
      by AOFA_A00:41,PBOOLE:def 18;
      then (vf @x).a = {x} & (FreeGen X).a c= (the generators of G).a
      by AOFA_A00:6;
      then
A5:   z nin (vf @x).a & @x is Element of G,a
      by A3,TARSKI:def 1,AOFA_A00:def 22;
      thus f.(s, x:=(t,A)).a.z = succ(s,x0,t value_at(C,s)).a.z
      by A2,AOFA_A00:def 28
      .= s.a.z by A1,A3,A5,A4,AOFA_A00:def 27;
    end;
    let b be SortSymbol of S; assume
A6: a <> b;
    hereby
      let z be pure Element of (the generators of G).b;
A7:   x in (FreeGen T).a & z in (FreeGen T).b &
      FreeGen X is ManySortedSubset of the generators of G
      by A1,Def4;
      then vf @x = a-singleton(x) & FreeGen X c= the generators of G
      by AOFA_A00:41,PBOOLE:def 18;
      then
A8:   z nin (vf @x).b & @x is Element of G,a
      by A6,AOFA_A00:6,AOFA_A00:def 22;
      thus f.(s, x:=(t,A)).b.z = succ(s,x0,t value_at(C,s)).b.z
      by A2,AOFA_A00:def 28
      .= s.b.z by A1,A6,A8,A7,AOFA_A00:def 27;
    end;
  end;

theorem Th66:
  G is C-supported & f in C-Execution(A,b,\falseC) implies
  (t1 value_at(C,s) < t2 value_at(C,s) iff
  f.(s, b gt(t2,t1,A)) in (\falseC)-States(the generators of G,b)) &
  (t1 value_at(C,s) <= t2 value_at(C,s) iff
  f.(s, b leq(t1,t2,A)) in (\falseC)-States(the generators of G,b)) &
  (for x holds f.(s, b gt(t1,t2,A)).I.x = s.I.x &
  f.(s, b leq(t1,t2,A)).I.x = s.I.x) &
  for c being pure Element of (the generators of G).the bool-sort of S
  st c <> b holds
  f.(s, b gt(t1,t2,A)).(the bool-sort of S).c = s.(the bool-sort of S).c &
  f.(s, b leq(t1,t2,A)).(the bool-sort of S).c = s.(the bool-sort of S).c
  proof assume
A1: G is C-supported & f in C-Execution(A,b,\falseC);
A2: f.(s, b gt(t2,t1,A)) is ManySortedFunction of the generators of G,
    the Sorts of C by AOFA_A00:48;
    reconsider b0 = @b as Element of G, the bool-sort of S
    by AOFA_A00:def 22;
A3: \not(leq(t2,t1)) value_at (C,s)
    = \not(leq(t2,t1) value_at(C,s)) by Th31
    .= \not(leq(t2 value_at(C,s), t1 value_at(C,s))) by Th45;
    then
A4: f.(s, b gt(t2,t1,A)).(the bool-sort of S).b
    = succ(s, b0, \not(leq(t2 value_at(C,s), t1 value_at(C,s)))).
    (the bool-sort of S).b by A1,AOFA_A00:def 28
    .= \not(leq(t2 value_at(C,s), t1 value_at(C,s))) by A1,AOFA_A00:def 27;
A5: 'not' FALSE = TRUE & TRUE <> FALSE &
    for x being boolean object holds x <> FALSE iff x = TRUE
    by XBOOLEAN:def 3;
    \trueC = TRUE by AOFA_A00:def 32;
    then
A6: \falseC = 'not' TRUE by AOFA_A00:def 32 .= FALSE;
    t1 value_at(C,s) < t2 value_at(C,s) iff
    leq(t2 value_at(C,s), t1 value_at(C,s)) = FALSE by AOFA_A00:55;
    then t1 value_at(C,s) < t2 value_at(C,s) iff
    \notleq(t2 value_at(C,s), t1 value_at(C,s)) <> \falseC by A6,A3,A5,Th33;
    hence (t1 value_at(C,s) < t2 value_at(C,s) iff
    f.(s, b gt(t2,t1,A)) in (\falseC)-States(the generators of G,b))
    by A2,A4,AOFA_A00:def 20;
A7: f.(s, b leq(t1,t2,A)) is ManySortedFunction of the generators of G,
    the Sorts of C by AOFA_A00:48;
    leq(t1,t2) value_at (C,s)
    = leq(t1 value_at(C,s), t2 value_at(C,s)) by Th45;
    then
A8: f.(s, b leq(t1,t2,A)).(the bool-sort of S).b
    = succ(s, b0, leq(t1 value_at(C,s), t2 value_at(C,s))).
    (the bool-sort of S).b by A1,AOFA_A00:def 28
    .= leq(t1 value_at(C,s), t2 value_at(C,s)) by A1,AOFA_A00:def 27;
    \trueC = TRUE by AOFA_A00:def 32;
    then
A9: \falseC = 'not' TRUE by AOFA_A00:def 32 .= FALSE;
    t1 value_at(C,s) <= t2 value_at(C,s) iff
    leq(t1 value_at(C,s), t2 value_at(C,s)) <> \falseC
    by A9,AOFA_A00:55;
    hence t1 value_at(C,s) <= t2 value_at(C,s) iff
    f.(s, b leq(t1,t2,A)) in (\falseC)-States(the generators of G,b)
    by A7,A8,AOFA_A00:def 20;
    b in (FreeGen T).the bool-sort of S by Def4;
    then
A10: vf b0 = (the bool-sort of S)-singleton(b) by AOFA_A00:41;
    hereby let x;
A11:   I <> the bool-sort of S by AOFA_A00:53;
A12:   x in (FreeGen T).I by Def4;
A13:   x nin (vf b0).I by A10,A11,AOFA_A00:6;
      thus f.(s, b gt(t1,t2,A)).I.x
      = succ(s,b0,\notleq(t1,t2)value_at(C,s)).I.x by A1,AOFA_A00:def 28
      .= s.I.x by A11,A12,A13,A1,AOFA_A00:def 27;
      thus f.(s, b leq(t1,t2,A)).I.x
      = succ(s,b0,leq(t1,t2)value_at(C,s)).I.x by A1,AOFA_A00:def 28
      .= s.I.x by A11,A12,A13,A1,AOFA_A00:def 27;
    end;
    let c be pure Element of (the generators of G).the bool-sort of S;
    assume A14: c <> b;
    (vf b0).the bool-sort of S = {b} by A10,AOFA_A00:6;
    then
A15: c nin (vf b0).the bool-sort of S by A14,TARSKI:def 1;
A16: c in (FreeGen T).the bool-sort of S by Def4;
    thus f.(s, b gt(t1,t2,A)).(the bool-sort of S).c
    = succ(s,b0,\notleq(t1,t2)value_at(C,s)).(the bool-sort of S).c
    by A1,AOFA_A00:def 28
    .= s.(the bool-sort of S).c by A14,A15,A16,A1,AOFA_A00:def 27;
    thus f.(s, b leq(t1,t2,A)).(the bool-sort of S).c
    = succ(s,b0,leq(t1,t2)value_at(C,s)).(the bool-sort of S).c
    by A1,AOFA_A00:def 28
    .= s.(the bool-sort of S).c by A14,A15,A16,A1,AOFA_A00:def 27;
  end;

registration
  let i,j be Real;
  let a,b be boolean object;
  cluster IFGT(i,j,a,b) -> boolean;
  coherence by XXREAL_0:def 11;
end;

theorem Th67:
  G is C-supported & f in C-Execution(A,b,\falseC) implies
  f.(s, t is_odd(b,A)).(the bool-sort of S).b = (t value_at(C,s)) mod 2 &
  f.(s, t is_even(b,A)).(the bool-sort of S).b = ((t value_at(C,s))+1) mod 2 &
  for z holds f.(s, t is_odd(b,A)).I.z = s.I.z &
  f.(s, t is_even(b,A)).I.z = s.I.z
  proof assume
A1: G is C-supported & f in C-Execution(A,b,\falseC);
    reconsider b0 = @b as Element of G,the bool-sort of S by AOFA_A00:def 22;
A2: \2(T,I) value_at(C,s) = 2 & \0(T,I) value_at(C,s) = 0 by Th36,Th40;
    then
A3: (t value_at(C,s)) mod (\2(T,I) value_at(C,s))
    = (t value_at(C,s)) mod 2 by Th64;
    then
A4: leq((t value_at(C,s)) mod (\2(T,I) value_at(C,s)),
    \0(T,I) value_at(C,s))
    = IFGT((t value_at(C,s)) mod 2, 0, FALSE, TRUE) by A2,AOFA_A00:55;
    reconsider Z = IFGT((t value_at(C,s)) mod 2, 0, FALSE, TRUE) as boolean
    object;
A5: f.(s, t is_odd(b,A)).(the bool-sort of S).b
    = succ(s,b0,\notleq(t mod \2(T,I),\0(T,I)) value_at(C,s))
    .(the bool-sort of S).b by A1,AOFA_A00:def 28
    .= \notleq(t mod \2(T,I),\0(T,I)) value_at(C,s) by A1,AOFA_A00:def 27
    .= \not(leq(t mod \2(T,I),\0(T,I)) value_at(C,s)) by Th31
    .= \notleq((t mod \2(T,I)) value_at(C,s),\0(T,I) value_at(C,s)) by Th45
    .= \notleq((t value_at(C,s)) mod (\2(T,I) value_at(C,s)),
    \0(T,I) value_at(C,s)) by Th44
    .= 'not' Z by A4,AOFA_A00:def 32;
    hereby
      per cases by PRE_FF:6;
      suppose
A6:     (t value_at(C,s)) mod 2 = 0;
        hence f.(s, t is_odd(b,A)).(the bool-sort of S).b
        = 'not' TRUE by A5,XXREAL_0:def 11
        .= (t value_at(C,s)) mod 2 by A6;
      end;
      suppose
A7:     (t value_at(C,s)) mod 2 = 1;
        hence f.(s, t is_odd(b,A)).(the bool-sort of S).b
        = 'not' FALSE by A5,XXREAL_0:def 11
        .= (t value_at(C,s)) mod 2 by A7;
      end;
    end;
A8: f.(s, t is_even(b,A)).(the bool-sort of S).b
    = succ(s,b0,leq(t mod \2(T,I),\0(T,I)) value_at(C,s))
    .(the bool-sort of S).b by A1,AOFA_A00:def 28
    .= leq(t mod \2(T,I),\0(T,I)) value_at(C,s) by A1,AOFA_A00:def 27
    .= leq((t mod \2(T,I)) value_at(C,s),\0(T,I) value_at(C,s)) by Th45
    .= leq((t value_at(C,s)) mod (\2(T,I) value_at(C,s)),
    \0(T,I) value_at(C,s)) by Th44
    .= IFGT((t value_at(C,s)) mod 2, 0, FALSE, TRUE) by A3,A2,AOFA_A00:55;
    hereby
      per cases by PRE_FF:6;
      suppose
A9:     (t value_at(C,s)) mod 2 = 0;
        hence f.(s, t is_even(b,A)).(the bool-sort of S).b
        = (0+1) mod 2 by Th1,A8,XXREAL_0:def 11
        .= ((t value_at(C,s))+1) mod 2 by A9,Th1,NAT_D:66;
      end;
      suppose
A10:     (t value_at(C,s)) mod 2 = 1;
        hence f.(s, t is_even(b,A)).(the bool-sort of S).b
        = 1+1 mod 2 by Th1,A8,XXREAL_0:def 11
        .= ((t value_at(C,s))+1) mod 2 by A10,Th1,NAT_D:66;
      end;
    end;
    let z;
A11: I <> the bool-sort of S by AOFA_A00:53;
    b in (FreeGen T).the bool-sort of S by Def4;
    then (vf @b) = (the bool-sort of S)-singleton(b) by AOFA_A00:41;
    then
A12: z nin (vf @b).I by A11,AOFA_A00:6;
A13: z in (FreeGen T).I by Def4;
    thus f.(s, t is_odd(b,A)).I.z
    = succ(s,b0,\notleq(t mod \2(T,I),\0(T,I)) value_at(C,s)).I.z
    by A1,AOFA_A00:def 28
    .= s.I.z by A1,A11,A12,A13,AOFA_A00:def 27;
    thus f.(s, t is_even(b,A)).I.z
    = succ(s,b0,leq(t mod \2(T,I),\0(T,I)) value_at(C,s)).I.z
    by A1,AOFA_A00:def 28
    .= s.I.z by A1,A11,A12,A13,AOFA_A00:def 27;
  end;

definition
  let S,X,T,G,A;
  attr A is elementary means
  rng the assignments of A c= ElementaryInstructions A;
end;

theorem Th68:
  A is elementary implies
  for a being SortSymbol of S
  for x being Element of (the generators of G).a
  for t being Element of T,a holds
  x:=(t,A) in ElementaryInstructions A
  proof assume
A1: rng the assignments of A c= ElementaryInstructions A;
    let a be SortSymbol of S;
    let x be Element of (the generators of G).a;
    let t be Element of T,a;
    [x,t] in [:(the generators of G).a,(the Sorts of T).a:] by ZFMISC_1:87;
    then [x,t] in [|the generators of G, the Sorts of T|].a &
    dom [|the generators of G, the Sorts of T|] = the carrier of S
    by PARTFUN1:def 2,PBOOLE:def 16;
    then x:=(t,A) in rng the assignments of A by FUNCT_2:4,CARD_5:2;
    hence thesis by A1;
   end;

registration
  let S,X,T,G;
  cluster elementary for strict IfWhileAlgebra of the generators of G;
  existence
  proof
    set W = the infinite IfWhileAlgebra of the generators of G;
    set f = the Function of Union [|the generators of G, the Sorts of T|],
    ElementaryInstructions W;
    reconsider f as Function of Union [|the generators of G, the Sorts of T|],
    the carrier of W by FUNCT_2:7;
    set A = ProgramAlgStr(#the carrier of W, the charact of W, f#);
    set X = the generators of G;
    set J = S;
    A is partial quasi_total non-empty non empty; then
    reconsider A as partial quasi_total non-empty non empty strict
    ProgramAlgStr over J,T,X;
    A is with_empty-instruction with_catenation with_if-instruction
    with_while-instruction
    by AOFA_000:def 10,AOFA_000:def 11,AOFA_000:def 12,AOFA_000:def 13; then
    reconsider A as with_empty-instruction with_catenation with_if-instruction
    with_while-instruction
    partial quasi_total non-empty non empty strict ProgramAlgStr over J,T,X;
    A is non degenerated well_founded ECIW-strict infinite
    proof
      hereby let I1,I2 be Element of A;
        reconsider J1 = I1, J2 = I2 as Element of W;
        EmptyIns A = EmptyIns W & I1\;I2 = J1\;J2;
        hence (I1 <> EmptyIns A implies I1\;I2 <> I2) &
        (I2 <> EmptyIns A implies I1\;I2 <> I1) &
        (I1 <> EmptyIns A or I2 <> EmptyIns A implies I1\;I2 <> EmptyIns A)
        by AOFA_000:def 24;
      end;
      hereby let C,I1,I2 be Element of A;
        reconsider C1 = C, J1 = I1, J2 = I2 as Element of W;
        if-then-else(C,I1,I2) = if-then-else(C1,J1,J2) &
        EmptyIns W = EmptyIns A;
        hence if-then-else(C,I1,I2) <> EmptyIns A by AOFA_000:def 24;
      end;
      hereby let C,I be Element of A;
        reconsider C1 = C, J = I as Element of W;
        EmptyIns A = EmptyIns W & while(C,I) = while(C1,J);
        hence while(C,I) <> EmptyIns A by AOFA_000:def 24;
      end;
      hereby let I1,I2,C,J1,J2 be Element of A;
        reconsider C1 = C, K1 = I1, K2 = I2, L1 = J1, L2 = J2 as Element of W;
        if-then-else(C,J1,J2) = if-then-else(C1,L1,L2) & I1\;I2 = K1\;K2 &
        EmptyIns W = EmptyIns A;
        hence I1 = EmptyIns A or I2 = EmptyIns A or
        I1\;I2 <> if-then-else(C,J1,J2) by AOFA_000:def 24;
      end;
      hereby let I1,I2,C,J be Element of A;
        reconsider C1 = C, K1 = I1, K2 = I2, L = J as Element of W;
        EmptyIns W = EmptyIns A & I1\;I2 = K1\;K2 & while(C,J) = while(C1,L);
        hence I1 <> EmptyIns A & I2 <> EmptyIns A implies I1\;I2 <> while(C,J)
        by AOFA_000:def 24;
      end;
      hereby let C1,I1,I2,C2,J be Element of A;
        reconsider C3 = C1, K1 = I1, K2 = I2, C4 = C2, L = J as Element of W;
        while(C2,J) = while(C4,L) &
        if-then-else(C1,I1,I2) = if-then-else(C3,K1,K2);
        hence if-then-else(C1,I1,I2) <> while(C2,J) by AOFA_000:def 24;
      end;
      thus A is well_founded
      proof
A1:     the UAStr of W = the UAStr of A; then
        ElementaryInstructions W = ElementaryInstructions A &
        ElementaryInstructions W is GeneratorSet of W
        by AOFA_A00:43,AOFA_000:def 25;
        hence ElementaryInstructions A is GeneratorSet of A
        by A1,AOFA_A00:46;
      end;
      the UAStr of A = the UAStr of W; then
      signature A = signature W by AOFA_A00:47;
      hence signature A = ECIW-signature by AOFA_000:def 27;
      the UAStr of A = the UAStr of W;
      hence ElementaryInstructions A is infinite by AOFA_A00:43;
    end;
    then reconsider A as infinite strict IfWhileAlgebra of X;
    take A;
    the UAStr of A = the UAStr of W; then
    ElementaryInstructions A = ElementaryInstructions W by AOFA_A00:43;
    hence rng the assignments of A c= ElementaryInstructions A
    by RELAT_1:def 19;
  end;
end;

registration
  let S,X,T,G;
  let A be elementary IfWhileAlgebra of the generators of G;
  let a be SortSymbol of S;
  let x be Element of (the generators of G).a;
  let t be Element of T,a;
  cluster x:=(t,A) -> absolutely-terminating;
  coherence
  proof
    x:=(t,A) in ElementaryInstructions A by Th68;
    hence thesis by AOFA_000:95;
  end;
end;

theorem
  for A being elementary IfWhileAlgebra of the generators of G
  for f being ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G,b) holds
  G is C-supported & f in C-Execution(A,b,\falseC) &
  (ex d being Function st d.x = 1 & d.y = 2 & d.m = 3) implies
         y:=(\1(T,I),A)\;
         while(b gt(@m, \0(T,I), A),
           if-then(@m is_odd(b,A), y:=(@y*@x,A))\;
           m:=(@m div \2(T,I),A)\; x:=(@x*@x,A))
  is_terminating_wrt f, {s: s.I.m >= 0}
proof
  let A be elementary IfWhileAlgebra of the generators of G;
  let f be ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G,b);
  assume
A1: G is C-supported & f in C-Execution(A,b,\falseC);
  set ST = C-States(the generators of G);
  set TV = (\falseC)-States(the generators of G,b);
  set P = {s: s.I.m >= 0};
  given d being Function such that
A2: d.x = 1 and
A3: d.y = 2 and
A4: d.m = 3;
A5: I <> the bool-sort of S by AOFA_A00:53;
  set W = b gt(@m, \0(T,I),A);
A6: y:=(\1(T,I),A) is_terminating_wrt f, P by AOFA_000:107;
  deffunc F(Element of ST) = In($1.I.m, NAT);
  defpred R[Element of ST] means $1.I.m > 0;
  set K = if-then(@m is_odd(b,A), y:=(@y*@x,A));
  set J = K\; m:=(@m div \2(T,I),A)\; x:=(@x*@x,A);
A7: f complies_with_if_wrt TV by AOFA_000:def 32;
A8: P is_invariant_wrt W,f
  proof
    let s be Element of ST;
    assume s in P;
    then
A9: ex s1 being Element of ST st s = s1 & s1.I.m >= 0;
    f.(s, W).I.m = s.I.m by A1,Th66;
    hence f.(s, W) in P by A9;
  end;
A10: for s being Element of ST st s in P & f.(f.(s,J),W) in TV
    holds f.(s,J) in P
  proof
    let s be Element of ST such that
    s in P;
A11: \0(T,I) value_at(C,f.(s,J)) = 0 by Th36;
    assume f.(f.(s,J),W) in TV;
    then @m value_at(C,f.(s,J)) > \0(T,I) value_at(C,f.(s,J)) by A1,Th66;
    then f.(s,J).I.m > 0 by A11,Th61;
    hence thesis;
  end;
A12: m <> y by A4,A3;
A13: P is_invariant_wrt y:=(\1(T,I),A), f
  proof
    let s;
    assume s in P;
    then
A14: ex s9 being Element of ST st s = s9 & s9.I.m >= 0;
    f.(s, y:=(\1(T,I),A)).I.m = s.I.m by A12,A1,Th65;
    hence f.(s, y:=(\1(T,I),A)) in P by A14;
  end;
A15: m <> x by A4,A2;
A16: for s st f.(s,W) in P holds f iteration_terminates_for J\;W, f.(s,W)
  proof
A17: for s being Element of ST st R[s] holds (R[f.(s,J\;W)] iff f.(s,J\;W)
    in TV) & F(f.(s,J\;W)) < F(s)
    proof
      let s be Element of ST such that
A18:  s.I.m > 0;
A19:  F(s) = s.I.m by A18,SUBSET_1:def 8,INT_1:3;
      set q1 = f.(s,K);
      set q0 = f.(s, @m is_odd(b,A));
      set sJ = f.(s,J);
      set sC = f.(sJ,W);
A20:  f.(s,J\;W) = sC by AOFA_000:def 29;
A21:   sC.I.m = sJ.I.m & \0(T,I) value_at(C,sC) = 0 by Th36,A5,A1,Th65;
A22:   @m value_at(C,sJ) = sJ.I.m & \0(T,I) value_at(C,sJ) = 0 by Th36,Th61;
      thus R[f.(s,J\;W)] iff f.(s,J\;W) in TV by A21,A20,A22,A1,Th66;
      set q2 = f.(q1,m:=(@m div \2(T,I),A));
      set q3 = f.(q2,x:=(@x*@x,A));
A23:  q1 = f.(q0, y:=(@y*@x,A)) or q1 = f.(q0, EmptyIns A)
      by A7;
A24:   @m value_at(C,q1) = q1.I.m by Th61;
A25:   \2(T,I) value_at(C,q1) = 2 by Th40;
      q2 = f.(s,K\;m:=(@m div \2(T,I),A)) by AOFA_000:def 29;
      then q3 = f.(s,J) by AOFA_000:def 29;
      then
A26:  sJ.I.m = q2.I.m by A15,A1,Th65
        .= (@m div \2(T,I)) value_at(C,q1) by A1,Th65
        .= (@m value_at(C,q1)) div (\2(T,I) value_at(C,q1)) by Th43
        .= (q1.I.m) div 2 by A24,A25,AOFA_A00:55
        .= (q0.I.m) div 2 by A12,A23,A1,Th65,AOFA_000:def 28
        .= (s.I.m) div 2 by A5,Th65,A1;
A27:  sC.I.m = sJ.I.m by A1,Th66;
      then sC.I.m in NAT by A18,A26,INT_1:3,61;
      then F(sC) = sC.I.m by SUBSET_1:def 8;
      hence thesis by A18,A27,A20,A26,A19,INT_1:56;
    end;
    let s0 be Element of ST such that
    f.(s0,W) in P;
    set s1 = f.(s0,W);
A28: s0.I.m = @m value_at(C,s0) & \0(T,I) value_at(C,s0) = 0 by Th36,Th61;
    then
A29: s0.I.m <= 0 implies s1 nin TV by A1,Th66;
    s0.I.m > 0 implies s1 in TV by A28,A1,Th66;
    then
A30: f.(s0,W) in TV iff R[f.(s0,W)] by A29,A1,Th66;
    thus f iteration_terminates_for J\;W, f.(s0,W) from AOFA_000:sch 3(A30,A17
    );
  end;
  J is_terminating_wrt f,P by AOFA_000:107;
  then while(b gt(@m, \0(T,I), A), if-then(@m is_odd(b,A), y:=(@y*@x,A))\;
  m:=(@m div \2(T,I),A)\; x:=(@x*@x,A) )
  is_terminating_wrt f, P by A8,A10,A16,AOFA_000:104,118;
  hence thesis by A6,A13,AOFA_000:111;
end;

theorem
  G is C-supported &
  (ex d being Function st d.b = 0 & d.x = 1 & d.y = 2 & d.m = 3) implies
  for s being Element of C-States(the generators of G)
  for n being Nat st n = s.I.m holds
   f in C-Execution(A,b,\falseC) implies
   f.(s, y:=(\1(T,I),A)\;
         while(b gt(@m, \0(T,I), A),
           if-then(@m is_odd(b,A), y:=(@y*@x,A))\;
           m:=(@m div \2(T,I),A)\; x:=(@x*@x,A)) ).I.y
   = (s.I.x)|^n
   proof
     assume
A1:  G is C-supported;
     given d being Function such that
A2:  d.b = 0 & d.x = 1 & d.y = 2 & d.m = 3;
     let s;
     let n be Nat;
     assume that
A3:  n = s.I.m and
A4:  f in C-Execution(A,b,\falseC);
     set Q = S;
     set S = C-States(the generators of G);
     set W = T; set g = f;
     set T = (\falseC)-States(the generators of G, b);
     set s0 = f.(s, y:=(\1(W,I),A));
A5:  f complies_with_if_wrt T by AOFA_000:def 32;
     defpred R[Element of S] means $1.I.m > 0;
     set Z = C;
     set C = b gt(@m, \0(W,I), A);
     defpred P[Element of S] means
     (s.I.x)|^n = ($1.I.y)*(($1.I.x)to_power($1.I.m)) &
     $1.I.m >= 0;
     deffunc F(Element of S) = In($1.I.m, NAT);
     set Y = I;
     set I = if-then(@m is_odd(b,A), y:=(@y*@x,A));
     set J = I\; m:=(@m div \2(W,Y),A)\; x:=(@x*@x,A);
A6:  m <> y by A2;
     then
A7:  s0.Y.m = s.Y.m by A1,A4,Th65;
A8:  for s being Element of S st P[s] holds P[g.(s,C) qua Element of S] &
     (g.(s,C) in T iff R[g.(s,C) qua Element of S])
     proof
       let s be Element of S such that
A9:    P[s];
       set s1 = g.(s, C);
A10:   s1.Y.x = s.Y.x by A1,A4,Th66;
       s1.Y.m = s.Y.m by A1,A4,Th66;
       hence P[g.(s,C) qua Element of S] by A1,A4,A9,A10,Th66;
A11:    \0(W,Y) value_at(Z,s) = 0 & @m value_at(Z,s) = s.Y.m by Th36,Th61;
       then
A12:   s.Y.m <= 0 implies s1 nin T by A1,A4,Th66;
       s.Y.m > 0 implies s1 in T by A11,A1,A4,Th66;
       hence thesis by A1,A4,A12,Th66;
     end;
A13: s0.Y.y = \1(W,Y) value_at(Z,s) by A1,A4,Th65 .= 1 by Th37;
     set fs = g.(s0, while(C,J));
     set s1 = g.(s0,C);
A14: (fs.Y.x) to_power 0 = 1 by POWER:24;
A15: m <> x by A2;
A16: for s being Element of S st R[s] holds (R[g.(s,J\;C) qua Element of S] iff
     g.(s,J\;C) in T) & F(g.(s,J\;C) qua Element of S) < F(s)
     proof
       let s be Element of S such that
A17:   s.Y.m > 0;
A18:   F(s) = s.Y.m by A17,SUBSET_1:def 8,INT_1:3;
       set q1 = g.(s,I);
       set q0 = g.(s, @m is_odd(b,A));
       set sJ = g.(s,J);
       set sC = g.(sJ,C);
A19:   g.(s,J\;C) = sC by AOFA_000:def 29;
A20:    \0(W,Y) value_at(Z,sJ) = 0 & @m value_at(Z,sJ) = sJ.Y.m by Th36,Th61;
       then
A21:   sJ.Y.m <= 0 implies sC nin T by A1,A4,Th66;
       sJ.Y.m > 0 implies sC in T by A20,A1,A4,Th66;
       hence R[g.(s,J\;C) qua Element of S] iff g.(s,J\;C) in T
       by A21,A19,A1,A4,Th66;
       set q2 = g.(q1,m:=(@m div \2(W,Y), A));
       set q3 = g.(q2,x:=(@x*@x,A));
A22:   q1 = g.(q0, y:=(@y*@x,A)) or q1 = g.(q0, EmptyIns A)
       by A5;
A23:    @m value_at(Z,q1) = q1.Y.m & \2(W,Y)value_at(Z,q1) = 2 by Th61,Th40;
       q2 = g.(s,I\;m:=(@m div \2(W,Y), A)) by AOFA_000:def 29;
       then q3 = g.(s,J) by AOFA_000:def 29;
       then
A24:   sJ.Y.m = q2.Y.m by A1,A4,A15,Th65
       .= (@m div \2(W,Y))value_at(Z,q1) by A1,A4,Th65
       .= (@m value_at(Z,q1)) div (\2(W,Y)value_at(Z,q1)) by Th43
       .= (q1.Y.m) div 2 by A23,AOFA_A00:55
       .= (q0.Y.m) div 2 by A1,A4,A6,A22,Th65,AOFA_000:def 28
       .= (s.Y.m) div 2 by A1,A4,Th67;
A25:   sC.Y.m = sJ.Y.m by A1,A4,Th66;
       then sC.Y.m in NAT by A17,A24,INT_1:3,61;
       then F(sC qua Element of S) = sC.Y.m by SUBSET_1:def 8;
       hence thesis by A17,A25,A19,A24,A18,INT_1:56;
     end;
     set q = s;
A26: x <> y by A2;
A27: for s being Element of S st P[s] & s in T & R[s]
     holds P[g.(s,J) qua Element of S]
     proof
       let s be Element of S such that
A28:   P[s] and
       s in T and
       R[s];
       reconsider sm = s.Y.m as Element of NAT by A28,INT_1:3;
       s.Y.m = ((sm) div 2)*2+((sm) mod 2) by NEWTON:66;
       then
A29:   (q.Y.x)|^n = (s.Y.y)*(((s.Y.x)to_power((sm div 2)*2))*
       ((s.Y.x)to_power(sm mod 2))) by A28,FIB_NUM2:5
       .= (s.Y.y)*((s.Y.x)to_power(sm mod 2))*((s.Y.x)to_power((sm div 2)*2))
       .= (s.Y.y)*((s.Y.x)to_power(sm mod 2))*
       (((s.Y.x)to_power 2) to_power (sm div 2)) by NEWTON:9
       .= (s.Y.y)*((s.Y.x)to_power(sm mod 2))*
       (((s.Y.x)*(s.Y.x)) to_power (sm div 2)) by NEWTON:81;
       set q1 = g.(s,I);
       set q0 = g.(s, @m is_odd(b,A));
       set sJ = g.(s,J);
       set q2 = g.(q1,m:=(@m div \2(W,Y), A));
       set q3 = g.(q2,x:=(@x*@x,A));
A30:   q1 = g.(q0, y:=(@y*@x,A)) or q1 = g.(q0, EmptyIns A)
       by A5;
A31:   q2.Y.x = q1.Y.x by A1,A4,A15,Th65
       .= q0.Y.x by A1,A4,A26,A30,Th65,AOFA_000:def 28;
A32:   q2.Y.y = q1.Y.y by A1,A4,A6,Th65;
A33:   q0.Y.y = s.Y.y by A1,A4,Th67;
A34:   q0.Y.x = s.Y.x by A1,A4,Th67;
       q2 = g.(s,I\;m:=(@m div \2(W,Y), A)) by AOFA_000:def 29;
       then
A35:   q3 = g.(s,J) by AOFA_000:def 29;
       then
A36:   sJ.Y.y = q2.Y.y by A1,A4,A26,Th65;
A37:   sm div 2 = s.Y.m div 2;
A38:   now
A39:      @m value_at(Z,s) = s.Y.m by Th61;
         then
A40:     q0.(the bool-sort of Q).b = (s.Y.m) mod 2 by A1,A4,Th67;
         per cases by A37,A40,NAT_D:12;
         suppose
A41:       q0.(the bool-sort of Q).b = FALSE;
           q0 is ManySortedFunction of the generators of G, the Sorts of Z &
           \falseZ = FALSE by Th10,AOFA_A00:48;
           then q0 nin T by A41,AOFA_A00:def 20;
           then q1 = g.(q0, EmptyIns A) by A5;
           then
A42:       q1.Y.y = q0.Y.y by AOFA_000:def 28;
A43:       (s.Y.y)*1 = s.Y.y;
           (s.Y.x)to_power 0 = 1 by POWER:24;
           hence (s.Y.y)*((s.Y.x)to_power(sm mod 2)) = sJ.Y.y
           by A1,A4,A39,A36,A32,A33,A41,A42,A43,Th67;
         end;
         suppose
A44:       q0.(the bool-sort of Q).b = TRUE;
A45:        @y value_at(Z,q0) = q0.Y.y & @x value_at(Z,q0) = q0.Y.x by Th61;
           q0 is ManySortedFunction of the generators of G, the Sorts of Z &
           \falseZ = FALSE by Th10,AOFA_A00:48;
           then q0 in T by A44,AOFA_A00:def 20;
           then q1 = g.(q0, y:=(@y*@x,A)) by A5;
           then
A46:       q1.Y.y = (@y*@x) value_at(Z,q0) by A1,A4,Th65
           .= (@y value_at(Z,q0))*(@x value_at(Z,q0)) by Th42
           .= (q0.Y.y)*(q0.Y.x) by A45,AOFA_A00:55;
           (s.Y.x)to_power 1 = s.Y.x & @m value_at(Z,s) = s.Y.m
           by Th61,POWER:25;
           hence (s.Y.y)*((s.Y.x)to_power(sm mod 2)) = sJ.Y.y
           by A1,A4,A34,A36,A32,A33,A44,A46,Th67;
         end;
       end;
A47:    @m value_at(Z,q1) = q1.Y.m & \2(W,Y) value_at(Z,q1) = 2 by Th61,Th40;
A48:    sJ.Y.m = q2.Y.m by A1,A4,A15,A35,Th65
       .= (@m div \2(W,Y)) value_at(Z,q1) by A1,A4,Th65
       .= (@m value_at(Z,q1))div(\2(W,Y) value_at(Z,q1)) by Th43
       .= (q1.Y.m) div 2 by A47,AOFA_A00:55
       .= (q0.Y.m) div 2 by A1,A4,A6,A30,Th65,AOFA_000:def 28
       .= (s.Y.m) div 2 by A1,A4,Th67;
A49:    @x value_at(Z,q2) = q2.Y.x by Th61;
       sJ.Y.x = (@x*@x) value_at(Z,q2) by A1,A4,A35,Th65
       .= (@x value_at(Z,q2))*(@x value_at(Z,q2)) by Th42
       .= (q2.Y.x)*(q2.Y.x) by A49,AOFA_A00:55;
       hence thesis by A48,A29,A31,A34,A38;
     end;
     @m value_at(Z,s0) = s0.Y.m & \0(W,Y) value_at(Z,s0) = 0 &
     s1.Y.m = s0.Y.m by A1,A4,Th36,Th61,Th66;
     then
A50: g.(s0,C) in T iff R[g.(s0,C) qua Element of S] by A1,A4,Th66;
A51: g iteration_terminates_for J\;C, g.(s0,C) from AOFA_000:sch 3(A50, A16);
     s0.Y.x = s.Y.x by A1,A4,A26,Th65;
     then
A52: P[s0 qua Element of S] by A3,A7,A13,POWER:41;
A53: P[g.(s0,while(C,J)) qua Element of S] &
     not R[g.(s0,while(C,J)) qua Element of S]
     from AOFA_000:sch 5(A52,A51,A27,A8);
     then fs.Y.m = 0;
     hence thesis by A53,A14,AOFA_000:def 29;
   end;

begin :: Calculation of maximum

registration
  let X be non empty set;
  let f be FinSequence of X^omega;
  let x be Nat;
  cluster f.x -> Sequence-like finite Function-like Relation-like;
  coherence
  proof
    x in dom f or x nin dom f;
    then f.x in X^omega or f.x = <%>X by FUNCT_1:def 2,102;
    hence thesis;
  end;
end;

registration
  let X be non empty set;
  cluster -> Function-yielding for FinSequence of X^omega;
  coherence;
end;

registration
  let i be Nat;
  let f be i-based finite array;
  let a,x be set;
  cluster f+*(a,x) -> i-based finite segmental;
  coherence
  proof
A1: dom(f+*(a,x)) = dom f by FUNCT_7:30;
    then
    (for b being Ordinal st b in dom (f+*(a,x)) holds i in dom f & i c= b) &
    ex c,b being Ordinal st dom (f+*(a,x)) = c\b by EXCHSORT:def 1,def 2;
    hence thesis by A1,FINSET_1:10,EXCHSORT:def 1,def 2;
  end;
end;

registration
  let X be non empty set;
  let f be X-valued Function;
  let a be set;
  let x be Element of X;
  cluster f+*(a,x) -> X-valued;
  coherence
  proof
    let y be object; assume y in rng (f+*(a,x));
    then consider z being object such that
A1: z in dom (f+*(a,x)) & y = (f+*(a,x)).z by FUNCT_1:def 3;
A2: dom (f+*(a,x)) = dom f & (z = a or z <> a) by FUNCT_7:30;
    then y = x or y = f.z by A1,FUNCT_7:31,32;
    hence thesis by A1,A2,FUNCT_1:102;
  end;
end;

scheme Sch1{X()->non empty set,
            j()->Nat,
            B()->set,
            F(set,set,set)->set,
            A(set)->set}:
  ex f being FinSequence of X()^omega st
  len f = j() & (f.1 = B() or j() = 0) &
  for i being Nat st 1 <= i & i < j() holds f.(i+1) = F(f.i,i,A(i))
  provided
A1: for a being 0-based finite array of X()
  for i being Nat st 1 <= i & i < j()
  for x being Element of X() holds
  F(a,i,x) is 0-based finite array of X()
  and
A2: B() is 0-based finite array of X()
  and
A3: for i being Nat st i < j() holds A(i) in X()
  proof
    defpred P[set,set,set] means $3 = F($2,$1,A($1));
A4: for n being Nat st 1 <= n & n < j()
    for x being set ex y being set st P[n,x,y];
    consider f being FinSequence such that
A5: len f = j() & (f.1 = B() or j() = 0) &
    for i being Nat st 1 <= i & i < j() holds P[i,f.i,f.(i+1)]
    from RECDEF_1:sch 3(A4);
    defpred Q[Nat] means 1 <= $1 & $1 <= j() implies f.$1 in X()^omega;
A6: Q[0];
A7: now let i be Nat;
      assume
A8:   Q[i];
      thus Q[i+1]
      proof
        assume
A9:     1 <= i+1 & i+1 <= j();
        reconsider x = A(i) as Element of X() by A3,A9,NAT_1:13;
        per cases;
        suppose i = 0;
          hence f.(i+1) in X()^omega by A2,A5,A9,AFINSQ_1:def 7;
        end;
        suppose i > 0;
          then
A10:       i >= 1+0 & i in NAT by NAT_1:13,ORDINAL1:def 12;
          f.(i+1) = F(f.i,i,x) & f.i is 0-based finite array of X()
          by A8,A10,A5,A9,NAT_1:13;
          then f.(i+1) is 0-based finite array of X() by A1,A9,A10,NAT_1:13;
          hence f.(i+1) in X()^omega by AFINSQ_1:def 7;
        end;
      end;
    end;
A11: for i being Nat holds Q[i] from NAT_1:sch 2(A6,A7);
    rng f c= X()^omega
    proof
      let x be object;
      assume x in rng f;
      then consider y being object such that
A12:   y in dom f & x = f.y by FUNCT_1:def 3;
      reconsider y as Nat by A12;
      1 <= y & y <= j() by A12,A5,FINSEQ_3:25;
      hence x in X()^omega by A11,A12;
    end;
    then reconsider f as FinSequence of X()^omega by FINSEQ_1:def 4;
    take f;
    thus len f = j() & (f.1 = B() or j() = 0) by A5;
    let i be Nat;
    assume 1 <= i & i < j();
    hence thesis by A5;
  end;

theorem Th71:
  for S being (11,1,1)-array non empty non void BoolSignature
  for J,L being set, K being SortSymbol of S
  st (the connectives of S).11 is_of_type <*J,L*>, K
  holds J = the_array_sort_of S &
  for I being integer SortSymbol of S holds the_array_sort_of S <> I
  proof
    let S be (11,1,1)-array non empty non void BoolSignature;
    let J0,L0 be set, K0 be SortSymbol of S;
    assume A1: (the connectives of S).11 is_of_type <*J0,L0*>, K0;
    consider J,K,L being Element of S such that
A2: L = 1 & K = 1 & J <> L & J <> K &
    (the connectives of S).11 is_of_type <*J,K*>, L &
    (the connectives of S).(11+1) is_of_type <*J,K,L*>, J &
    (the connectives of S).(11+2) is_of_type <*J*>, K &
    (the connectives of S).(11+3) is_of_type <*K,L*>, J by AOFA_A00:def 51;
A3: the_array_sort_of S = J by A2;
    thus J0 = <*J0,L0*>.1 by FINSEQ_1:44
    .= (the Arity of S).((the connectives of S).11).1 by A1
    .= <*J,K*>.1 by A2
    .= the_array_sort_of S by A3,FINSEQ_1:44;
    thus thesis by A2,AOFA_A00:def 40;
  end;

theorem Th72:
  for S being 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
  bool-correct non empty non void BoolSignature
  for I being integer SortSymbol of S
  for A being (4,1) integer (11,1,1)-array bool-correct non-empty
  MSAlgebra over S
  for a,b being Element of A,I st a = 0
  holds init.array(a,b) = {}
  proof
    let S be 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
    bool-correct non empty non void BoolSignature;
    let I be integer SortSymbol of S;
    let A be (4,1) integer (11,1,1)-array bool-correct non-empty
    MSAlgebra over S;
    let a,b be Element of A,I;
    assume A1: a = 0;
    set o = (the connectives of S).14;
    consider J,K being Element of S such that
A2: K = 1 & (the connectives of S).11 is_of_type <*J,1*>, K &
    (the Sorts of A).J = ((the Sorts of A).K)^omega &
    (the Sorts of A).1 = INT &
    (for a being 0-based finite array of (the Sorts of A).K holds
    (for i being Integer st i in dom a holds
    Den((the connectives of S)/.11,A).<*a,i*> = a.i &
    for x being Element of A,K holds
    Den((the connectives of S)/.(11+1),A).<*a,i,x*> = a+*(i,x)) &
    Den((the connectives of S)/.(11+2),A).<*a*> = card a) &
    for i being Integer, x being Element of A,K st i >= 0 holds
    Den((the connectives of S)/.(11+3),A).<*i,x*> = Segm(i)-->x
      by AOFA_A00:def 52;
A3: I = 1 by AOFA_A00:def 40;
    11+3 <= len the connectives of S by AOFA_A00:def 51;
    then 14 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S)/.14 & o in the carrier' of S
    by FUNCT_1:102,PARTFUN1:def 6;
    hence init.array(a,b) = Den((the connectives of S)/.14, A).<*a,b*>
    by SUBSET_1:def 8
    .= Segm(0 qua set)-->b by A1,A2,A3
    .= {};
  end;

theorem Th73:
  for S being (11,1,1)-array 11 array-correct bool-correct non empty non void
  BoolSignature
  for I being integer SortSymbol of S holds
  the_array_sort_of S <> I &
  (the connectives of S).11 is_of_type <*the_array_sort_of S,I*>, I &
  (the connectives of S).(11+1) is_of_type <*the_array_sort_of S,I,I*>,
  the_array_sort_of S &
  (the connectives of S).(11+2) is_of_type <*the_array_sort_of S*>, I &
  (the connectives of S).(11+3) is_of_type <*I,I*>, the_array_sort_of S
  proof
    let S be (11,1,1)-array 11 array-correct bool-correct non empty
    non void BoolSignature;
    let I be integer SortSymbol of S;
    consider J,K,L being Element of S such that
A1: L = 1 & K = 1 & J <> L & J <> K &
    (the connectives of S).11 is_of_type <*J,K*>, L &
    (the connectives of S).(11+1) is_of_type <*J,K,L*>, J &
    (the connectives of S).(11+2) is_of_type <*J*>, K &
    (the connectives of S).(11+3) is_of_type <*K,L*>, J by AOFA_A00:def 51;
    the_array_sort_of S = J & I = 1 by A1,AOFA_A00:def 40;
    hence thesis by A1;
  end;

theorem Th74:
  for S being 1-1-connectives (11,1,1)-array 11 array-correct (4,1) integer
  bool-correct non empty non void BoolSignature
  for I being integer SortSymbol of S
  for A being (11,1,1)-array (4,1) integer bool-correct non-empty
  MSAlgebra over S
  holds (the Sorts of A).the_array_sort_of S = INT^omega &
  (for i,j being Element of A,I st i is non negative Integer
  holds init.array(i,j) = Segm(i)-->j) &
  for a being Element of (the Sorts of A).the_array_sort_of S
  holds length(a,I) = card a &
  for i being Element of A,I
  for f being Function st f = a & i in dom f
  holds a.(i) = f.i &
  for x being Element of A,I holds (a,i)<-x = f+*(i,x)
  proof
    let S be 1-1-connectives (11,1,1)-array 11 array-correct (4,1) integer
    bool-correct non empty non void BoolSignature;
    let I be integer SortSymbol of S;
    let A be (11,1,1)-array (4,1) integer bool-correct non-empty
    MSAlgebra over S;
    consider J,K being Element of S such that
A1: K = 1 & (the connectives of S).11 is_of_type <*J,1*>, K &
    (the Sorts of A).J = ((the Sorts of A).K)^omega &
    (the Sorts of A).1 = INT &
    (for a being 0-based finite array of (the Sorts of A).K holds
    (for i being Integer st i in dom a holds
    Den((the connectives of S)/.11,A).<*a,i*> = a.i &
    for x being Element of A,K holds
    Den((the connectives of S)/.(11+1),A).<*a,i,x*> = a+*(i,x)) &
    Den((the connectives of S)/.(11+2),A).<*a*> = card a) &
    for i being Integer, x being Element of A,K st i >= 0 holds
    Den((the connectives of S)/.(11+3),A).<*i,x*> = Segm(i)-->x
      by AOFA_A00:def 52;
    thus (the Sorts of A).the_array_sort_of S = INT^omega by A1,Th71;
    11+3 <= len the connectives of S by AOFA_A00:def 51;
    then 11 <= len the connectives of S &
    12 <= len the connectives of S &
    13 <= len the connectives of S &
    14 <= len the connectives of S by XXREAL_0:2;
    then 11 in dom the connectives of S &
    12 in dom the connectives of S &
    13 in dom the connectives of S &
    14 in dom the connectives of S by FINSEQ_3:25;
    then
A2: (the connectives of S).11 in the carrier' of S &
    (the connectives of S).12 in the carrier' of S &
    (the connectives of S).13 in the carrier' of S &
    (the connectives of S).14 in the carrier' of S &
    (the connectives of S).11 = (the connectives of S)/.11 &
    (the connectives of S).12 = (the connectives of S)/.12 &
    (the connectives of S).13 = (the connectives of S)/.13 &
    (the connectives of S).14 = (the connectives of S)/.14
    by FUNCT_1:102,PARTFUN1:def 6;
A3: I = 1 by AOFA_A00:def 40;
    hereby
      let i,j be Element of A,I;
      reconsider ii = i as Integer by A3;
      assume
      i is non negative Integer;
      then
A4:   ii >= 0 & I = K by A1,AOFA_A00:def 40;
      thus init.array(i,j) = Den((the connectives of S)/.14,A).<*ii,j*>
      by A2,SUBSET_1:def 8
      .= Segm(i)-->j by A1,A4;
    end;
    let a be Element of (the Sorts of A).the_array_sort_of S;
    J = the_array_sort_of S by A1,Th71;
    then reconsider b = a as XFinSequence of INT by A1;
    thus length(a,I)
    = Den((the connectives of S)/.13,A).<*b*> by A2,SUBSET_1:def 8
    .= card a by A1;
    let i be Element of A,I;
    let f be Function;
    assume A5: f = a & i in dom f;
    thus a.(i) = Den((the connectives of S)/.11,A).<*a,i*> by A2,SUBSET_1:def 8
    .= b.i by A1,A5,A3
    .= f.i by A5;
    let x be Element of A,I;
    thus (a,i)<-x = Den((the connectives of S)/.12,A).<*b,i,x*>
    by A2,SUBSET_1:def 8
    .= f+*(i,x) by A1,A3,A5;
  end;

registration
  let a be 0-based finite array;
  cluster len-a -> finite;
  coherence
  proof
    len a = len-a by EXCHSORT:24;
    hence thesis;
  end;
end;

registration
  let S be 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
  bool-correct non empty non void BoolSignature;
  let A be (11,1,1)-array (4,1) integer bool-correct non-empty
  MSAlgebra over S;
  cluster -> (11,1,1)-array for non-empty MSSubAlgebra of A;
  coherence
  proof
    let Q be non-empty MSSubAlgebra of A;
    set I = the integer SortSymbol of S;
A1: (the Sorts of Q).I = INT by AOFA_A00:55;
    then reconsider 00 = 0 as Element of Q,I by INT_1:def 2;
    reconsider 0a = 00 as Element of A,I by Th2;
    consider J,K being Element of S such that
A2: K = 1 & (the connectives of S).11 is_of_type <*J,1*>, K &
    (the Sorts of A).J = ((the Sorts of A).K)^omega &
    (the Sorts of A).1 = INT &
    (for a being 0-based finite array of (the Sorts of A).K holds
    (for i being Integer st i in dom a holds
    Den((the connectives of S)/.11,A).<*a,i*> = a.i &
    for x being Element of A,K holds
    Den((the connectives of S)/.(11+1),A).<*a,i,x*> = a+*(i,x)) &
    Den((the connectives of S)/.(11+2),A).<*a*> = card a) &
    for i being Integer, x being Element of A,K st i >= 0 holds
    Den((the connectives of S)/.(11+3),A).<*i,x*> = Segm(i)-->x
      by AOFA_A00:def 52;
    consider J1,K1,L1 being Element of S such that
A3: L1 = 1 & K1 = 1 & J1 <> L1 & J1 <> K1 &
    (the connectives of S).11 is_of_type <*J1,K1*>, L1 &
    (the connectives of S).(11+1) is_of_type <*J1,K1,L1*>, J1 &
    (the connectives of S).(11+2) is_of_type <*J1*>, K1 &
    (the connectives of S).(11+3) is_of_type <*K1,L1*>, J1 by AOFA_A00:def 51;
A4: I = 1 by AOFA_A00:def 40;
A5: the_array_sort_of S = J & the_array_sort_of S = J1 by A3,A2,Th71;
A6: for a being 0-based finite array of INT holds
    a in (the Sorts of Q).the_array_sort_of S
    proof
      let a be 0-based finite array of INT;
      set o = In((the connectives of S).14, the carrier' of S);
      11+3 <= len the connectives of S by AOFA_A00:def 51;
      then 14 in dom the connectives of S by FINSEQ_3:25;
      then o = (the connectives of S).14 by FUNCT_1:102,SUBSET_1:def 8;
      then the_arity_of o = <*K,K*> by A3,A2;
      then
A7:   Args(o,Q) = product <*INT,INT*> & 0 in INT
      by A2,A4,A1,Th23,INT_1:def 2;
      per cases;
      suppose len a = 0;
        then a = <%>INT;
        then a = init.array(0a,0a) by Th72
        .= init.array(00,00) by A7,FINSEQ_3:124,EQUATION:19;
        hence a in (the Sorts of Q).the_array_sort_of S;
      end;
      suppose
A8:     len a <> 0;
        deffunc F(array, Integer, set) = $1+*($2,$3);
        deffunc G(Integer) = a.($1);
        set j = len a;
A9:     for a being 0-based finite array of INT
        for i being Nat st 1 <= i & i < j
        for x being Element of INT holds
        F(a,i,x) is 0-based finite array of INT;
        set B = Segm((len a qua set))-->a.0;
A10:     B is 0-based finite array of INT;
A11:     for i being Nat st i<j holds G(i) in INT
           by AFINSQ_1:86,FUNCT_1:102;
        consider f being FinSequence of INT^omega such that
A12:     len f = j & (f.1 = B or j = 0) &
        for i being Nat st 1 <= i & i < j holds f.(i+1) = F(f.i,i,G(i))
        from Sch1(A9,A10,A11);
        reconsider f as Function-yielding FinSequence of INT^omega;
        defpred Q[Nat] means $1 <= len a implies
        ($1 <> 0 implies len (f.$1) = j) &
        for i being Nat st i < $1 holds a.i = f.$1.i;
A13:     Q[0];
A14:     now let i be Nat; assume
A15:       Q[i];
          thus Q[i+1]
          proof assume
A16:         i+1 <= len a;
            per cases;
            suppose
A17:           i = 0;
              thus i+1 <> 0 implies len(f.(i+1)) = j
              by A12,A16,A17;
              let k be Nat;
              assume k < i+1;
              then k <= 0 & k >= 0 by A17,NAT_1:13;
              then
A18:           k = 0;
              then k < len a by A16;
              hence a.k = f.(i+1).k
                  by A17,A12,A18,FUNCOP_1:7,AFINSQ_1:86;
            end;
            suppose
A19:           i > 0;
              then
A20:           i >= 0+1 & i < j by A16,NAT_1:13;
              then
A21:           f.(i+1) = F(f.i,i,G(i)) by A12;
              thus i+1 <> 0 implies len(f.(i+1)) = j
              by A15,A19,A21,A16,NAT_1:13,FUNCT_7:30;
              let k be Nat;
              assume k < i+1;
              then
A22:           k <= i & k < j by A16,XXREAL_0:2,NAT_1:13;
              per cases by A22,XXREAL_0:1;
              suppose k = i;
                then f.(i+1) = f.i+*(k,a.k) & k in dom (f.i)
                by A15,A12,A20,AFINSQ_1:86;
                hence a.k = f.(i+1).k by FUNCT_7:31;
              end;
              suppose
A23:             k < i;
A24:             f.(i+1) = f.i+*(i,a.i) & k in dom (f.i)
                by A20,A12,A15,A22,AFINSQ_1:86;
                thus a.k = (f.i).k by A15,A23,A16,NAT_1:13 .= f.(i+1).k
                by A23,A24,FUNCT_7:32;
              end;
            end;
          end;
        end;
A25:     for i being Nat holds Q[i] from NAT_1:sch 2(A13,A14);
        then
        (len a <> 0 implies len (f.len a) = j)
        & for i being Nat st i < len a holds a.i = (f.len a).i;
        then
A26:     f.len a = a by A8,AFINSQ_1:9;
        defpred R[Nat] means 1 <= $1 & $1 <= len a implies
        f.$1 in (the Sorts of Q).the_array_sort_of S;
A27:     R[0];
A28:     now let i be Nat;
          assume
A29:       R[i];
          thus R[i+1]
          proof
            assume
A30:         1 <= i+1 & i+1 <= len a;
            then
A31:         i < len a by NAT_1:13;
            per cases by NAT_1:14;
            suppose
A32:           i >= 1;
              then reconsider fi = f.i as Element of Q, the_array_sort_of S
              by A29,A30,NAT_1:13;
              fi in (the Sorts of A).J by A5,Th2;
              then reconsider ff = fi as finite Sequence of INT by A2;
              reconsider ii = i as Element of (the Sorts of Q).I
              by A1,INT_1:def 2;
              reconsider a = G(i) as Element of (the Sorts of Q).I
              by A1,A11,A30,NAT_1:13;
              reconsider b = a, ia = ii as Element of (the Sorts of A).I
              by Th2;
              reconsider fj = fi as Element of A, the_array_sort_of S by Th2;
              f.(i+1) = F(f.i,i,G(i)) & (1=0+1 implies i > 0) &
              f.i in (the Sorts of Q).the_array_sort_of S
              by A29,A32,A12,A30,NAT_1:13;
              then
              len (f.i) = j by A31,A25;
              then
A33:           i in dom ff by A31,AFINSQ_1:86;
              11+3 <= len the connectives of S by AOFA_A00:def 51;
              then 12 <= len the connectives of S by XXREAL_0:2;
              then 12 in dom the connectives of S by FINSEQ_3:25;
              then
A34:           (the connectives of S).12 = (the connectives of S)/.12 &
              (the connectives of S).12 in the carrier' of S
              by PARTFUN1:def 6,FUNCT_1:102;
              then the_arity_of ((the connectives of S)/.12)
              = <*the_array_sort_of S, I, I*> by A3,A4;
              then
A35:           Args((the connectives of S)/.12, Q) = product <*(the Sorts of Q)
              .the_array_sort_of S, (the Sorts of Q).I, (the Sorts of Q).I*>
              by Th24;
              f.(i+1) = ff+*(i,a) by A32,A12,A30,NAT_1:13
              .= Den((the connectives of S)/.12, A).<*fj,ia,b*>
              by A4,A2,A33
              .= Den((the connectives of S)/.12, Q).<*fi,ii,a*>
              by A35,FINSEQ_3:125,EQUATION:19
              .= (fi,ii)<-a by A34,SUBSET_1:def 8;
              hence f.(i+1) in (the Sorts of Q).the_array_sort_of S;
            end;
            suppose
A36:           i = 0;
              reconsider a0 = a.0, ii = j as Element of Q, I
              by A1,INT_1:def 2;
              reconsider b0 = a0, ia = ii as Element of A, I by Th2;
              11+3 <= len the connectives of S by AOFA_A00:def 51;
              then 14 in dom the connectives of S by FINSEQ_3:25;
              then
A37:           (the connectives of S).14 = (the connectives of S)/.14 &
              (the connectives of S).14 in the carrier' of S
              by PARTFUN1:def 6,FUNCT_1:102;
              then the_arity_of ((the connectives of S)/.14) = <*I, I*>
              by A3,A4;
              then
A38:           Args((the connectives of S)/.14, Q)
              = product <*(the Sorts of Q).I, (the Sorts of Q).I*>
              by Th23;
              f.(i+1) = Den((the connectives of S)/.14, A).<*ia,b0*>
              by A36,A12,A8,A4,A2
              .= Den((the connectives of S)/.14, Q).<*ii,a0*>
              by A38,FINSEQ_3:124,EQUATION:19
              .= init.array(ii,a0) by A37,SUBSET_1:def 8;
              hence thesis;
            end;
          end;
        end;
A39:     for i being Nat holds R[i] from NAT_1:sch 2(A27,A28);
        0 < len a by A8;
        then 0+1 <= len a by NAT_1:13;
        hence a in (the Sorts of Q).the_array_sort_of S by A26,A39;
      end;
    end;
    take J,K;
    thus K = 1 by A2;
    thus (the connectives of S).11 is_of_type <*J,1*>, K by A2;
    the Sorts of Q is MSSubset of A by MSUALG_2:def 9;
    hence (the Sorts of Q).J c= ((the Sorts of Q).K)^omega
    by A1,A4,A2,PBOOLE:def 2,def 18;
    thus
A40: ((the Sorts of Q).K)^omega c= (the Sorts of Q).J
    by A5,A6,A1,A4,A2;
    thus (the Sorts of Q).1 = INT by AOFA_A00:55,A4;
    hereby
      let a be 0-based finite array of (the Sorts of Q).K;
A41:   a in ((the Sorts of Q).K)^omega by AFINSQ_1:def 7;
      hereby let i be Integer; assume
A42:     i in dom a;
A43:     i in INT by INT_1:def 2;
        11+3 <= len the connectives of S by AOFA_A00:def 51;
        then 11 <= len the connectives of S by XXREAL_0:2;
        then 11 in dom the connectives of S by FINSEQ_3:25;
        then
        (the connectives of S).11 = (the connectives of S)/.11 &
        (the connectives of S).11 in the carrier' of S
        by PARTFUN1:def 6,FUNCT_1:102;
        then the_arity_of ((the connectives of S)/.11)
        = <*the_array_sort_of S, I*> by A3,A4;
        then
A44:     Args((the connectives of S)/.11, Q) = product <*(the Sorts of Q)
        .the_array_sort_of S, (the Sorts of Q).I*> by Th23;
        thus Den((the connectives of S)/.11,Q).<*a,i*>
        = Den((the connectives of S)/.11,A).<*a,i*>
        by A44,A41,A40,A43,A5,A1,FINSEQ_3:124,EQUATION:19
        .= a.i by A42,A1,A4,A2;
        let x be Element of Q,K;
        11+3 <= len the connectives of S by AOFA_A00:def 51;
        then 12 <= len the connectives of S by XXREAL_0:2;
        then 12 in dom the connectives of S by FINSEQ_3:25;
        then
        (the connectives of S).12 = (the connectives of S)/.12 &
        (the connectives of S).12 in the carrier' of S
        by PARTFUN1:def 6,FUNCT_1:102;
        then the_arity_of ((the connectives of S)/.12)
        = <*the_array_sort_of S, I, I*> by A3,A4;
        then
A45:     Args((the connectives of S)/.12, Q) = product <*(the Sorts of Q)
        .the_array_sort_of S, (the Sorts of Q).I, (the Sorts of Q).I*>
        by Th24;
        thus Den((the connectives of S)/.(11+1),Q).<*a,i,x*>
        = Den((the connectives of S)/.(11+1),A).<*a,i,x*>
        by A45,A1,A41,A40,A2,A5,A4,A43,FINSEQ_3:125,EQUATION:19
        .= a+*(i,x) by A1,A4,A2,A42;
      end;
      11+3 <= len the connectives of S by AOFA_A00:def 51;
      then 13 <= len the connectives of S by XXREAL_0:2;
      then 13 in dom the connectives of S by FINSEQ_3:25;
      then
      (the connectives of S).13 = (the connectives of S)/.13 &
      (the connectives of S).13 in the carrier' of S
      by PARTFUN1:def 6,FUNCT_1:102;
      then the_arity_of ((the connectives of S)/.13)
      = <*the_array_sort_of S*> by A3;
      then
A46:   Args((the connectives of S)/.13, Q) = product <*(the Sorts of Q)
      .the_array_sort_of S*> by Th22;
      thus Den((the connectives of S)/.(11+2),Q).<*a*>
      = Den((the connectives of S)/.(11+2),A).<*a*>
      by A46,A41,A40,A5,FINSEQ_3:123,EQUATION:19
      .= card a by A1,A4,A2;
    end;
    let i be Integer, x be Element of Q,K; assume
A47: i >= 0;
A48: i in INT by INT_1:def 2;
    11+3 <= len the connectives of S by AOFA_A00:def 51;
    then 14 in dom the connectives of S by FINSEQ_3:25;
    then
    (the connectives of S).14 = (the connectives of S)/.14 &
    (the connectives of S).14 in the carrier' of S
    by PARTFUN1:def 6,FUNCT_1:102;
    then the_arity_of ((the connectives of S)/.14)
    = <*I, K*> by A3,A2,A4;
    then
A49: Args((the connectives of S)/.14, Q) = product <*(the Sorts of Q).I,
    (the Sorts of Q).K*> by Th23;
    thus Den((the connectives of S)/.(11+3),Q).<*i,x*>
    = Den((the connectives of S)/.(11+3),A).<*i,x*>
    by A49,A48,A1,FINSEQ_3:124,EQUATION:19
    .= Segm(i)-->x by A47,A1,A4,A2;
  end;
end;

definition
  let S be 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
  bool-correct non empty non void BoolSignature;
  let A be non-empty MSAlgebra over S;
  attr A is integer-array means: Def14:
  ex C being image of A st
  C is (4,1) integer (11,1,1)-array bool-correct MSAlgebra over S;
end;

registration
  let S be 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
  bool-correct non empty non void BoolSignature;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster Free(S,X) -> integer-array for non-empty MSAlgebra over S;
  coherence
  proof let F be non-empty MSAlgebra over S;
    assume
A1: F = Free(S,X);
    set A = the (4,1) integer (11,1,1)-array bool-correct non-empty
    MSAlgebra over S;
    reconsider G = FreeGen X as GeneratorSet of F by A1,MSAFREE3:31;
    set f = the ManySortedFunction of G, the Sorts of A;
    FreeGen X is free & F = FreeMSA X by A1,MSAFREE3:31;
    then consider h being ManySortedFunction of F,A such that
A2: h is_homomorphism F,A & h||G = f by MSAFREE:def 5;
    reconsider C = Image h as image of F by A2,MSAFREE4:def 4;
    take C; thus thesis;
  end;
end;

registration
  let S be 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
  bool-correct non empty non void BoolSignature;
  cluster integer-array -> integer for non-empty MSAlgebra over S;
  coherence;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster vf-free integer-array for all_vars_including inheriting_operations
  free_in_itself (X,S)-terms non-empty strict
  VarMSAlgebra over S;
  existence
  proof
    set A = Free(S,X);
    consider V being ManySortedMSSet of the Sorts of A,the Sorts of A,
    B being all_vars_including inheriting_operations free_in_itself
    (X,S)-terms VarMSAlgebra over S such that
A1: B = VarMSAlgebra(#the Sorts of A, the Charact of A, V#) &
    B is vf-free by AOFA_A00:39;
    reconsider B as all_vars_including inheriting_operations free_in_itself
    (X,S)-terms strict VarMSAlgebra over S by A1;
    take B; thus B is vf-free by A1;
    consider C being image of A such that
A2: C is (4,1) integer (11,1,1)-array bool-correct MSAlgebra over S by Def14;
    consider h being ManySortedFunction of A,C such that
A3: h is_epimorphism A,C by MSAFREE4:def 5;
    reconsider g = h as ManySortedFunction of B,C by A1;
    the MSAlgebra of C = the MSAlgebra of C;
    then reconsider D = C as image of B by A1,A3,Th8,MSAFREE4:def 5;
    take D; thus thesis by A2;
  end;
end;

registration
  let S be 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
  bool-correct non empty non void BoolSignature;
  cluster integer-array for non-empty MSAlgebra over S;
  existence
  proof
    set A = the integer-array non-empty VarMSAlgebra over S;
    take A;
    thus thesis;
  end;
end;

registration
  let S be 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
  bool-correct non empty non void BoolSignature;
  let A be integer-array non-empty MSAlgebra over S;
  cluster (4,1) integer (11,1,1)-array for bool-correct image of A;
  existence
  proof
    consider C being image of A such that
A1: C is (4,1) integer (11,1,1)-array bool-correct MSAlgebra over S by Def14;
    thus thesis by A1;
  end;
end;

reserve
  S for 1-1-connectives (4,1) integer (11,1,1)-array 11 array-correct
  bool-correct non empty non void BoolSignature,
  X for non-empty ManySortedSet of the carrier of S,
  T for vf-free all_vars_including inheriting_operations free_in_itself
  (X,S)-terms integer-array non-empty VarMSAlgebra over S,
  C for (11,1,1)-array (4,1) integer bool-correct non-empty image of T,
  G for basic GeneratorSystem over S,X,T,
  A for IfWhileAlgebra of the generators of G,
  I for integer SortSymbol of S,
  x,y,m,i for pure (Element of (the generators of G).I),
  M,N for pure (Element of (the generators of G).the_array_sort_of S),
  b for pure (Element of (the generators of G).the bool-sort of S),
  s,s1 for (Element of C-States(the generators of G));

registration
  let S;
  let A be (11,1,1)-array bool-correct non-empty MSAlgebra over S;
  cluster -> Relation-like Function-like
  for Element of (the Sorts of A).the_array_sort_of S;
  coherence
  proof
    let M be Element of (the Sorts of A).the_array_sort_of S;
    set I = the integer SortSymbol of S;
    consider J,K being Element of S such that
A1: K = 1 & (the connectives of S).11 is_of_type <*J,1*>, K &
    (the Sorts of A).J = ((the Sorts of A).K)^omega &
    (the Sorts of A).1 = INT &
    (for a being 0-based finite array of (the Sorts of A).K holds
    (for i being Integer st i in dom a holds
    Den((the connectives of S)/.11,A).<*a,i*> = a.i &
    for x being Element of A,K holds
    Den((the connectives of S)/.(11+1),A).<*a,i,x*> = a+*(i,x)) &
    Den((the connectives of S)/.(11+2),A).<*a*> = card a) &
    for i being Integer, x being Element of A,K st i >= 0 holds
    Den((the connectives of S)/.(11+3),A).<*i,x*> = Segm(i)-->x
      by AOFA_A00:def 52;
    J = the_array_sort_of S by A1,Th71;
    hence thesis by A1;
  end;
end;

registration
  let S;
  let A be (11,1,1)-array bool-correct non-empty MSAlgebra over S;
  cluster -> finite Sequence-like
  for Element of (the Sorts of A).the_array_sort_of S;
  coherence
  proof
    let M be Element of (the Sorts of A).the_array_sort_of S;
    set I = the integer SortSymbol of S;
    consider J,K being Element of S such that
A1: K = 1 & (the connectives of S).11 is_of_type <*J,1*>, K &
    (the Sorts of A).J = ((the Sorts of A).K)^omega &
    (the Sorts of A).1 = INT &
    (for a being 0-based finite array of (the Sorts of A).K holds
    (for i being Integer st i in dom a holds
    Den((the connectives of S)/.11,A).<*a,i*> = a.i &
    for x being Element of A,K holds
    Den((the connectives of S)/.(11+1),A).<*a,i,x*> = a+*(i,x)) &
    Den((the connectives of S)/.(11+2),A).<*a*> = card a) &
    for i being Integer, x being Element of A,K st i >= 0 holds
    Den((the connectives of S)/.(11+3),A).<*i,x*> = Segm(i)-->x
      by AOFA_A00:def 52;
    J = the_array_sort_of S by A1,Th71;
    hence thesis by A1;
  end;
end;

theorem Th75:
  for o being OperSymbol of S st
  o = In((the connectives of S).11, the carrier' of S)
  holds the_arity_of o = <*the_array_sort_of S,I*> &
  the_result_sort_of o = I
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).11, the carrier' of S);
    11+3 <= len the connectives of S by AOFA_A00:def 51;
    then 11 <= len the connectives of S by XXREAL_0:2;
    then 11 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).11 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*the_array_sort_of S,I*>, I by Th73;
    hence the_arity_of o = <*the_array_sort_of S,I*> &
    the_result_sort_of o = I;
  end;

theorem Th76:
  for o being OperSymbol of S st
  o = In((the connectives of S).12, the carrier' of S)
  holds the_arity_of o = <*the_array_sort_of S,I,I*> &
  the_result_sort_of o = the_array_sort_of S
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).12, the carrier' of S);
    11+3 <= len the connectives of S by AOFA_A00:def 51;
    then 12 <= len the connectives of S by XXREAL_0:2;
    then 12 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).12 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*the_array_sort_of S,I,I*>, the_array_sort_of S
    by Th73;
    hence the_arity_of o = <*the_array_sort_of S,I,I*> &
    the_result_sort_of o = the_array_sort_of S;
  end;

theorem Th77:
  for o being OperSymbol of S st
  o = In((the connectives of S).13, the carrier' of S)
  holds the_arity_of o = <*the_array_sort_of S*> &
  the_result_sort_of o = I
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).13, the carrier' of S);
    11+3 <= len the connectives of S by AOFA_A00:def 51;
    then 13 <= len the connectives of S by XXREAL_0:2;
    then 13 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).13 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*the_array_sort_of S*>, I by Th73;
    hence the_arity_of o = <*the_array_sort_of S*> &
    the_result_sort_of o = I;
  end;

theorem Th78:
  for o being OperSymbol of S st
  o = In((the connectives of S).14, the carrier' of S)
  holds the_arity_of o = <*I,I*> &
  the_result_sort_of o = the_array_sort_of S
  proof
    let o be OperSymbol of S;
    assume A1: o = In((the connectives of S).14, the carrier' of S);
    11+3 <= len the connectives of S by AOFA_A00:def 51;
    then 14 in dom the connectives of S by FINSEQ_3:25;
    then o = (the connectives of S).14 by A1,FUNCT_1:102,SUBSET_1:def 8;
    then o is_of_type <*I,I*>, the_array_sort_of S by Th73;
    hence the_arity_of o = <*I,I*> &
    the_result_sort_of o = the_array_sort_of S;
  end;

theorem Th79:
  for t being Element of T, the_array_sort_of S holds
  for t1 being Element of T, I holds
  t.(t1) value_at(C,s) = (t value_at(C,s)).(t1 value_at(C,s))
  proof
    let t be Element of T, the_array_sort_of S;
    let t1 be Element of T, I;
    set o = In((the connectives of S).11, the carrier' of S);
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
A2: t value_at(C,s) = f.(the_array_sort_of S).t by A1,Th29;
A3: (t.t1) value_at(C,s) = f.I.(t.t1) by A1,Th29;
A4: the_arity_of o = <*the_array_sort_of S,I*> &
    the_result_sort_of o = I by Th75;
    then Args(o,T) = product <*(the Sorts of T).the_array_sort_of S,
    (the Sorts of T).I*> by Th23;
    then reconsider p = <*t,t1*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t.t1) value_at(C,s) = Den(o,C).(f#p) by A1,A3,A4
    .= Den(o,C).<*f.(the_array_sort_of S).t,f.I.t1*> by A4,Th26
    .= (t value_at(C,s)).(t1 value_at(C,s)) by A1,A2,Th29;
  end;

theorem Th80:
  for t being Element of T, the_array_sort_of S holds
  for t1,t2 being Element of T, I holds
  (t,t1)<-t2 value_at(C,s) =
  (t value_at(C,s), t1 value_at(C,s))<-(t2 value_at(C,s))
  proof
    let t be Element of T, the_array_sort_of S;
    let t1,t2 be Element of T, I;
    set o = In((the connectives of S).12, the carrier' of S);
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
A2: t2 value_at(C,s) = f.I.t2 by A1,Th29;
A3: t value_at(C,s) = f.(the_array_sort_of S).t by A1,Th29;
A4: (t,t1)<-t2 value_at(C,s) = f.(the_array_sort_of S).((t,t1)<-t2) by A1,Th29;
A5: the_arity_of o = <*the_array_sort_of S,I,I*> &
    the_result_sort_of o = the_array_sort_of S by Th76;
    then Args(o,T) = product <*(the Sorts of T).the_array_sort_of S,
    (the Sorts of T).I, (the Sorts of T).I*> by Th24;
    then reconsider p = <*t,t1,t2*> as Element of Args(o,T) by FINSEQ_3:125;
    thus (t,t1)<-t2 value_at(C,s) = Den(o,C).(f#p) by A1,A4,A5
    .= Den(o,C).<*f.(the_array_sort_of S).t,f.I.t1,f.I.t2*> by A5,Th27
    .= (t value_at(C,s), t1 value_at(C,s))<-(t2 value_at(C,s)) by A1,A2,A3,Th29
;
  end;

theorem Th81:
  for t being Element of T, the_array_sort_of S holds
  length(t,I) value_at(C,s) = length(t value_at(C,s), I)
  proof
    let t be Element of T, the_array_sort_of S;
    set o = In((the connectives of S).13, the carrier' of S);
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
A2: length(t,I) value_at(C,s) = f.I.(length(t,I)) by A1,Th29;
A3: the_arity_of o = <*the_array_sort_of S*> &
    the_result_sort_of o = I by Th77;
    then Args(o,T) = product <*(the Sorts of T).the_array_sort_of S*> by Th22;
    then reconsider p = <*t*> as Element of Args(o,T) by FINSEQ_3:123;
    thus (length(t,I)) value_at(C,s) = Den(o,C).(f#p)
    by A1,A2,A3
    .= Den(o,C).<*f.(the_array_sort_of S).t*> by A3,Th25
    .= length(t value_at(C,s),I) by A1,Th29;
  end;

theorem
  for t1,t2 being Element of T, I holds
  init.array(t1,t2) value_at(C,s) =
  init.array(t1 value_at(C,s), t2 value_at(C,s))
  proof
    let t1,t2 be Element of T, I;
    set o = In((the connectives of S).14, the carrier' of S);
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & s = f||(the generators of G) by AOFA_A00:def 19;
A2: t2 value_at(C,s) = f.I.t2 by A1,Th29;
A3: init.array(t1,t2) value_at(C,s) = f.(the_array_sort_of S)
    .(init.array(t1,t2)) by A1,Th29;
A4: the_arity_of o = <*I,I*> &
    the_result_sort_of o = the_array_sort_of S by Th78;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (init.array(t1,t2)) value_at(C,s) = Den(o,C).(f#p)
    by A1,A3,A4
    .= Den(o,C).<*f.I.t1,f.I.t2*> by A4,Th26
    .= init.array(t1 value_at(C,s),t2 value_at(C,s)) by A1,A2,Th29;
  end;

reserve u for ManySortedFunction of FreeGen T, the Sorts of C;

theorem
  for t being Element of T, the_array_sort_of S holds
  for t1 being Element of T, I holds
  t.(t1) value_at(C,u) = (t value_at(C,u)).(t1 value_at(C,u))
  proof
    let t be Element of T, the_array_sort_of S;
    let t1 be Element of T, I;
    set o = In((the connectives of S).11, the carrier' of S);
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
A2: t value_at(C,u) = f.(the_array_sort_of S).t by A1,Th28;
A3: (t.t1) value_at(C,u) = f.I.(t.t1) by A1,Th28;
A4: the_arity_of o = <*the_array_sort_of S,I*> &
    the_result_sort_of o = I by Th75;
    then Args(o,T) = product <*(the Sorts of T).the_array_sort_of S,
    (the Sorts of T).I*> by Th23;
    then reconsider p = <*t,t1*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (t.t1) value_at(C,u) = Den(o,C).(f#p) by A1,A3,A4
    .= Den(o,C).<*f.(the_array_sort_of S).t,f.I.t1*> by A4,Th26
    .= (t value_at(C,u)).(t1 value_at(C,u)) by A1,A2,Th28;
  end;

theorem Th84:
  for t being Element of T, the_array_sort_of S holds
  for t1,t2 being Element of T, I holds
  (t,t1)<-t2 value_at(C,u) =
  (t value_at(C,u), t1 value_at(C,u))<-(t2 value_at(C,u))
  proof
    let t be Element of T, the_array_sort_of S;
    let t1,t2 be Element of T, I;
    set o = In((the connectives of S).12, the carrier' of S);
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
A2: t2 value_at(C,u) = f.I.t2 by A1,Th28;
A3: t value_at(C,u) = f.(the_array_sort_of S).t by A1,Th28;
A4: (t,t1)<-t2 value_at(C,u) = f.(the_array_sort_of S).((t,t1)<-t2) by A1,Th28;
A5: the_arity_of o = <*the_array_sort_of S,I,I*> &
    the_result_sort_of o = the_array_sort_of S by Th76;
    then Args(o,T) = product <*(the Sorts of T).the_array_sort_of S,
    (the Sorts of T).I, (the Sorts of T).I*> by Th24;
    then reconsider p = <*t,t1,t2*> as Element of Args(o,T) by FINSEQ_3:125;
    thus (t,t1)<-t2 value_at(C,u) = Den(o,C).(f#p) by A1,A4,A5
    .= Den(o,C).<*f.(the_array_sort_of S).t,f.I.t1,f.I.t2*> by A5,Th27
    .= (t value_at(C,u), t1 value_at(C,u))<-(t2 value_at(C,u))
    by A1,A2,A3,Th28;
  end;

theorem
  for t being Element of T, the_array_sort_of S holds
  length(t,I) value_at(C,u) = length(t value_at(C,u), I)
  proof
    let t be Element of T, the_array_sort_of S;
    set o = In((the connectives of S).13, the carrier' of S);
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
A2: length(t,I) value_at(C,u) = f.I.(length(t,I)) by A1,Th28;
A3: the_arity_of o = <*the_array_sort_of S*> &
    the_result_sort_of o = I by Th77;
    then Args(o,T) = product <*(the Sorts of T).the_array_sort_of S*> by Th22;
    then reconsider p = <*t*> as Element of Args(o,T) by FINSEQ_3:123;
    thus (length(t,I)) value_at(C,u) = Den(o,C).(f#p)
    by A1,A2,A3
    .= Den(o,C).<*f.(the_array_sort_of S).t*> by A3,Th25
    .= length(t value_at(C,u),I) by A1,Th28;
  end;

theorem
  for t1,t2 being Element of T, I holds
  init.array(t1,t2) value_at(C,u) =
  init.array(t1 value_at(C,u), t2 value_at(C,u))
  proof
    let t1,t2 be Element of T, I;
    set o = In((the connectives of S).14, the carrier' of S);
    consider f being ManySortedFunction of T,C such that
A1: f is_homomorphism T,C & u = f||FreeGen T by MSAFREE4:46;
A2: t2 value_at(C,u) = f.I.t2 by A1,Th28;
A3: init.array(t1,t2) value_at(C,u) = f.(the_array_sort_of S)
    .(init.array(t1,t2)) by A1,Th28;
A4: the_arity_of o = <*I,I*> &
    the_result_sort_of o = the_array_sort_of S by Th78;
    then Args(o,T) = product <*(the Sorts of T).I, (the Sorts of T).I*>
    by Th23;
    then reconsider p = <*t1,t2*> as Element of Args(o,T) by FINSEQ_3:124;
    thus (init.array(t1,t2)) value_at(C,u) = Den(o,C).(f#p)
    by A1,A3,A4
    .= Den(o,C).<*f.I.t1,f.I.t2*> by A4,Th26
    .= init.array(t1 value_at(C,u),t2 value_at(C,u)) by A1,A2,Th28;
  end;

Lm1:
  now
    let S,X,T,I;
    let i be Integer;
    let f1 being Function of INT, (the Sorts of T).I such that
A1: f1.0 = \0(T,I) &
    for j being Nat, t being Element of T,I st f1.j = t
    holds f1.(j+1) = t+\1(T,I) & f1.(-(j+1)) = -(t+\1(T,I));
    let f2 being Function of INT, (the Sorts of T).I such that
A2: f2.0 = \0(T,I) &
    for j being Nat, t being Element of T,I st f2.j = t
    holds f2.(j+1) = t+\1(T,I) & f2.(-(j+1)) = -(t+\1(T,I));
    defpred P[Nat] means f1.$1 = f2.$1;
A3: P[0] by A1,A2;
A4: for i being Nat st P[i] holds P[i+1]
    proof
      let i be Nat;
      assume
A5:   P[i];
      reconsider j = i as Element of INT by INT_1:def 2;
      thus f1.(i+1) = (f1.j)+\1(T,I) by A1 .= f2.(i+1) by A2,A5;
    end;
A6: for i being Nat holds P[i] from NAT_1:sch 2(A3,A4);
    now let i be Element of INT;
      consider n being Nat such that
A7:   i = n or i = -n by INT_1:def 1;
      per cases by A7;
      suppose i = n or i = -n & n = 0;
        hence f1.i = f2.i by A6;
      end;
      suppose
A8:     i = -n & n <> 0;
        then consider m being Nat such that
A9:     n = m+1 by NAT_1:6;
        reconsider m0 = m, m1 = m+1 as Element of INT by INT_1:def 2;
        thus f1.i = -(f1.m0+\1(T,I)) by A1,A9,A8
        .= -(f2.m0+\1(T,I)) by A6 .= f2.i by A2,A9,A8;
      end;
    end;
    hence f1 = f2;
  end;

definition
  let S,X,T,I;
  let i be Integer;
  func ^(i,T,I) -> Element of T,I means: Def15:
  ex f being Function of INT, (the Sorts of T).I st
  it = f.i & f.0 = \0(T,I) &
  for j being Nat, t being Element of T,I st f.j = t
  holds f.(j+1) = t+\1(T,I) & f.(-(j+1)) = -(t+\1(T,I));
  existence
  proof
    deffunc F(Nat,Element of T,I) = $2+\1(T,I);
    consider f being Function of NAT,(the Sorts of T).I such that
A1: f.0 = \0(T,I) & for i being Nat holds f.(i+1) = F(i,f.i) from NAT_1:sch 12;
    set X = {-j where j is Nat: j <> 0};
    -1 in X;
    then reconsider X as non empty set;
    X is integer-membered
    proof
      let x be object;
      assume x in X;
      then ex j being Nat st x = -j & j <> 0;
      hence thesis;
    end;
    then reconsider X as non empty integer-membered set;
    deffunc G(Integer) = -(f.In(-$1,NAT));
    consider g being Function of X,(the Sorts of T).I such that
A2: for i being Element of X holds g.i = G(i) from FUNCT_2:sch 4;
    set h = f+*g;
A3: dom h = (dom f) \/ dom g by FUNCT_4:def 1
    .= NAT \/ dom g by FUNCT_2:def 1 .= NAT \/ X by FUNCT_2:def 1;
A4: NAT \/ X = INT
    proof
      thus NAT \/ X c= INT by MEMBERED:5;
      let x be Integer; assume x in INT;
      then consider n being Nat such that
A5:   x = n or x = -n by INT_1:def 1;
A6:    n in NAT by ORDINAL1:def 12;
      per cases by A5;
      suppose x = n;
        hence thesis by XBOOLE_0:def 3,A6;
      end;
      suppose x = -n & n = 0;
        hence thesis by XBOOLE_0:def 3;
      end;
      suppose x = -n & n <> 0;
        then x in X;
        hence thesis by XBOOLE_0:def 3;
      end;
    end;
    rng f c= (the Sorts of T).I & rng g c= (the Sorts of T).I
    by RELAT_1:def 19;
    then rng h c= (rng f)\/rng g & (rng f)\/rng g c= (the Sorts of T).I
    by XBOOLE_1:8,FUNCT_4:17;
    then reconsider h as Function of INT,(the Sorts of T).I
    by A3,A4,FUNCT_2:2,XBOOLE_1:1;
    reconsider j = i as Element of INT by INT_1:def 2;
    reconsider t = h.j as Element of T,I;
    take t, h; thus t = h.i;
    -0 nin X
    proof
      assume -0 in X;
      then ex n being Nat st -0 = -n & n <> 0;
      hence contradiction;
    end;
    then 0 nin dom g by FUNCT_2:def 1;
    hence h.0 = \0(T,I) by A1,FUNCT_4:11;
    let j be Nat, t be Element of T,I; assume
A7: h.j = t;
    j nin X
    proof
      assume j in X;
      then consider n being Nat such that
A8:   j = -n & n <> 0;
      j in NAT by ORDINAL1:def 12;
      hence contradiction by A8,INT_2:6;
    end;
    then j nin dom g by FUNCT_2:def 1;
    then
A9: h.j = f.j by FUNCT_4:11;
    j+1 nin X
    proof
      assume j+1 in X;
      then consider n being Nat such that
A10:   j+1 = -n & n <> 0;
      thus contradiction by A10;
    end;
    then j+1 nin dom g by FUNCT_2:def 1;
    hence h.(j+1) = f.(j+1) by FUNCT_4:11 .= t+\1(T,I) by A1,A7,A9;
A11: -(j+1) in X;
    then -(j+1) in dom g by FUNCT_2:def 1;
    hence h.(-(j+1)) = g.(-(j+1)) by FUNCT_4:13 .= G(-(j+1)) by A11,A2
    .= -(f.(j+1))
    .= -(t+\1(T,I)) by A1,A7,A9;
  end;
  uniqueness by Lm1;
end;

theorem Th87:
  ^(0,T,I) = \0(T,I)
  proof
    ex f being Function of INT, (the Sorts of T).I st
    ^(0,T,I) = f.0 & f.0 = \0(T,I) &
    for j being Nat, t being Element of T,I st f.j = t
    holds f.(j+1) = t+\1(T,I) & f.(-(j+1)) = -(t+\1(T,I)) by Def15;
    hence thesis;
  end;

theorem Th88:
  for n being Nat holds ^(n+1,T,I) = ^(n,T,I)+\1(T,I) &
  ^(-(n+1),T,I) = - ^(n+1,T,I)
  proof
    let n be Nat;
    consider f being Function of INT, (the Sorts of T).I such that
A1: ^(n+1,T,I) = f.(n+1) & f.0 = \0(T,I) &
    for j being Nat, t being Element of T,I st f.j = t
    holds f.(j+1) = t+\1(T,I) & f.(-(j+1)) = -(t+\1(T,I)) by Def15;
    consider g being Function of INT, (the Sorts of T).I such that
A2: ^(n,T,I) = g.n & g.0 = \0(T,I) &
    for j being Nat, t being Element of T,I st g.j = t
    holds g.(j+1) = t+\1(T,I) & g.(-(j+1)) = -(t+\1(T,I)) by Def15;
    consider h being Function of INT, (the Sorts of T).I such that
A3: ^(-(n+1),T,I) = h.(-(n+1)) & h.0 = \0(T,I) &
    for j being Nat, t being Element of T,I st h.j = t
    holds h.(j+1) = t+\1(T,I) & h.(-(j+1)) = -(t+\1(T,I)) by Def15;
A4: f = g by A1,A2,Lm1;
    ^(n,T,I) = f.n by A1,A2,Lm1;
    hence
A5: ^(n+1,T,I) = ^(n,T,I)+\1(T,I) by A1;
    f = h by A1,A3,Lm1;
    hence ^(-(n+1),T,I) = - ^(n+1,T,I) by A3,A5,A4,A2;
  end;

theorem
  ^(1,T,I) = \0(T,I)+\1(T,I)
  proof 1 = 0+1;
    hence ^(1,T,I) = ^(0,T,I)+\1(T,I) by Th88 .= \0(T,I)+\1(T,I) by Th87;
  end;

theorem Th90:
  for i being Integer holds ^(i,T,I) value_at(C,s) = i
  proof
    let i be Integer;
    defpred P[Nat] means ^($1,T,I) value_at(C,s) = $1;
    ^(0,T,I) = \0(T,I) by Th87;
    then
A1: P[0] by Th36;
A2: now let i be Nat;
      assume
A3:   P[i];
A4:   \1(T,I) value_at(C,s) = 1 by Th37;
      ^(i+1,T,I) = ^(i,T,I)+\1(T,I) by Th88;
      then ^(i+1,T,I) value_at(C,s)
      = (^(i,T,I) value_at(C,s))+(\1(T,I) value_at(C,s)) by Th39
      .= (^(i,T,I) value_at(C,s))+1 by A4,AOFA_A00:55;
      hence P[i+1] by A3;
    end;
A5: for i being Nat holds P[i] from NAT_1:sch 2(A1,A2);
    i in INT by INT_1:def 2;
    then consider n being Nat such that
A6: i = n or i = -n by INT_1:def 1;
    per cases by A6;
    suppose i = n or i = -n & n = 0;
      hence thesis by A5;
    end;
    suppose
A7:   i = -n & n <> 0;
      then consider m being Nat such that
A8:   n = m+1 by NAT_1:6;
      \1(T,I) value_at(C,s) = 1 & ^(m,T,I) value_at(C,s) = m by A5,Th37;
      then
A9:   (^(m,T,I) value_at(C,s))+(\1(T,I) value_at(C,s)) = m+1 by AOFA_A00:55;
      ^(i,T,I) = - ^(m+1,T,I) by A7,A8,Th88;
      hence ^(i,T,I) value_at(C,s)
      = -(^(m+1,T,I) value_at(C,s)) by Th38
      .= -((^(m,T,I)+\1(T,I)) value_at(C,s)) by Th88
      .= -((^(m,T,I) value_at(C,s))+(\1(T,I) value_at(C,s))) by Th39
      .= i by A7,A8,A9,AOFA_A00:55;
    end;
  end;

definition
  let S,X,T,G,I,M;
  let i be Integer;
  func M.(i,I) -> Element of T,I equals @M.(^(i,T,I));
  coherence;
end;

registration
  let S,X,T,G,C,s,M;
  cluster s.(the_array_sort_of S).M -> Function-like Relation-like;
  coherence
  proof
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then s.(the_array_sort_of S) is Function of (the generators of G)
    .the_array_sort_of S, (the Sorts of C).the_array_sort_of S
    by PBOOLE:def 15;
    then
A1: s.(the_array_sort_of S).M in (the Sorts of C).the_array_sort_of S
    by FUNCT_2:5;
    thus thesis by A1;
  end;
end;

registration
  let S,X,T,G,C,s,M;
  cluster s.(the_array_sort_of S).M -> finite Sequence-like INT-valued;
  coherence
  proof
    s is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    then s.(the_array_sort_of S) is Function of (the generators of G)
    .the_array_sort_of S, (the Sorts of C).the_array_sort_of S
    by PBOOLE:def 15;
    then
A1: s.(the_array_sort_of S).M in (the Sorts of C).the_array_sort_of S
    by FUNCT_2:5;
    (the Sorts of C).the_array_sort_of S = INT^omega by Th74;
    hence thesis by A1;
  end;
end;

registration
  let S,X,T,G,C,s,M;
  cluster rng (s.(the_array_sort_of S).M) -> finite integer-membered;
  coherence;
end;

theorem
  for j being Integer st j in dom (s.(the_array_sort_of S).M) &
  M.(j,I) in (the generators of G).I
  holds s.(the_array_sort_of S).M.j = s.I.(M.(j,I))
  proof
    let j be Integer;
    assume
A1: j in dom (s.(the_array_sort_of S).M);
    assume
A2: M.(j,I) in (the generators of G).I;
    reconsider s1 = s as ManySortedFunction of the generators of G,
    the Sorts of C by AOFA_A00:48;
    consider h being ManySortedFunction of T,C such that
A3: h is_homomorphism T,C & s1 = h||the generators of G by AOFA_A00:def 19;
A4: ^(j,T,I) value_at(C,s) = j & @M value_at(C,s) = s.(the_array_sort_of S).M
    by Th61,Th90;
    s.I.(M.(j,I)) = (h.I)|((the generators of G).I).(M.(j,I))
    by A3,MSAFREE:def 1
    .= h.I.(@M.(^(j,T,I))) by A2,FUNCT_1:49
    .= @M.(^(j,T,I)) value_at(C,s) by A3,Th29
    .= (@M value_at(C,s)).(^(j,T,I) value_at(C,s)) by Th79
    .= (s1.(the_array_sort_of S).M).j by A1,A4,Th74;
    hence s.(the_array_sort_of S).M.j = s.I.(M.(j,I));
  end;

theorem
  for j being Integer st j in dom (s.(the_array_sort_of S).M) &
  @M.(@i) in (the generators of G).I & j = @i value_at(C,s) holds
  s.(the_array_sort_of S).M.(@i value_at(C,s)) = s.I.(@M.(@i))
  proof
    let j be Integer;
    assume A1: j in dom (s.(the_array_sort_of S).M);
    assume A2: @M.(@i) in (the generators of G).I;
    assume A3: j = @i value_at(C,s);
    reconsider s1 = s as ManySortedFunction of the generators of G,
    the Sorts of C by AOFA_A00:48;
    consider h being ManySortedFunction of T,C such that
A4: h is_homomorphism T,C & s1 = h||the generators of G by AOFA_A00:def 19;
    s.(the_array_sort_of S).M = @M value_at(C,s) by Th61;
    hence s.(the_array_sort_of S).M.(@i value_at(C,s))
    = (@M value_at(C,s)).(@i value_at(C,s)) by A1,A3,Th74
    .= @M.@i value_at(C,s) by Th79
    .= h.I.(@M.@i) by A4,Th29
    .= ((h.I)|((the generators of G).I)).(@M.@i) by A2,FUNCT_1:49
    .= s.I.(@M.(@i)) by A4,MSAFREE:def 1;
  end;

registration
  let X be non empty set;
  cluster X^omega -> infinite;
  coherence
  proof
    set x = the Element of X;
    set Y = the set of all n-->x where n is Nat;
A1: Y c= X^omega
    proof
      let a be object;
      assume a in Y;
      then ex n being Nat st a = n qua set-->x;
      hence thesis by AFINSQ_1:def 7;
    end;
    defpred P[object,object] means
    ex z being set st z = $1 & $2 = card z;
A2: for e being object st e in Y ex u being object st P[e,u]
    proof
      let e be object such that e in Y;
      reconsider e as set by TARSKI:1;
      take card e;
      thus thesis;
    end;
    consider f being Function such that
A3: dom f = Y & for a being object st a in Y holds P[a,f.a]
    from CLASSES1:sch 1(A2);
    rng f = NAT
    proof
      thus rng f c= NAT
      proof
        let a be object; assume a in rng f;
        then consider b being object such that
A4:     b in dom f & a = f.b by FUNCT_1:def 3;
        consider n being Nat such that
A5:     b = n-->x by A3,A4;
        ex z being set st z = b & f.b = card z by A3,A4;
        then a = card dom(n-->x) by A4,A5
        .= card n .= n;
        hence a in NAT by ORDINAL1:def 12;
      end;
      let n be Nat;
      assume n in NAT;
A6:   n-->x in Y;
      then ex z being set st z = n-->x & f.(n-->x) = card z by A3;
      then f.(n-->x) = card dom (n-->x)
      .= card n .= n;
      hence n in rng f by A3,A6,FUNCT_1:def 3;
    end;
    hence thesis by A1,A3,FINSET_1:8;
  end;
end;

theorem
  for f being ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G, b) st
  f in C-Execution(A,b,\falseC) & G is C-supported & i <> m &
  s.(the_array_sort_of S).M <> {} holds
  for n being Nat st
  f.(s, m:=(\0(T,I),A)\;
        for-do(i:=(\1(T,I),A), b gt(length(@M,I),@i,A), i:=(@i+\1(T,I),A),
               if-then(b gt(@M.(@i), @M.(@m), A), m:=(@i,A)))).I.m = n
  for X being non empty finite integer-membered set
  st X = rng (s.(the_array_sort_of S).M)
  holds (M.(n,I)) value_at(C,s) = max X
  proof let f be ExecutionFunction of A, C-States(the generators of G),
    (\falseC)-States(the generators of G, b) such that
A1: f in C-Execution(A,b,\falseC) & G is C-supported & i <> m and
A2: s.(the_array_sort_of S).M <> {};
    let n be Nat;
    assume
A3: f.(s, m:=(\0(T,I),A)\;
          for-do(i:=(\1(T,I),A), b gt(length(@M,I),@i,A), i:=(@i+\1(T,I),A),
            if-then(b gt(@M.(@i), @M.(@m), A), m:=(@i,A)
            )
          )
      ).I.m = n;
    let X be non empty finite integer-membered set;
    assume
A4: X = rng (s.(the_array_sort_of S).M);
    set ST = C-States(the generators of G);
    set TV = (\falseC)-States(the generators of G, b);
    defpred R[Element of ST] means
    s.(the_array_sort_of S).M = $1.(the_array_sort_of S).M;
    reconsider sm = s as ManySortedFunction of the generators of G,
    the Sorts of C by AOFA_A00:48;
    reconsider z = sm.(the_array_sort_of S).M as 0-based finite array of INT;
    defpred P[Element of ST] means R[$1] &
    $1.I.i in NAT & $1.I.m in NAT & $1.I.i <= len z & $1.I.m < $1.I.i &
    $1.I.m < len z &
    for mx being Integer st mx = $1.I.m
    for j being Nat st j < $1.I.i
    holds z.j <= z.mx;
    defpred Q[Element of ST] means R[$1] &
    $1.I.i < (length(@M,I)) value_at(C,s);
    set s0 = s;
    set s1 = f.(s,m:=(\0(T,I),A));
    set s2 = f.(s1,i:=(\1(T,I),A));
    set W = b gt(length(@M,I),@i,A);
    set K = i:=(@i+\1(T,I),A);
    set s3 = f.(s2,W);
    set CJ = b gt(@M.(@i), @M.(@m), A);
    set IJ = m:=(@i,A);
    set J = if-then(CJ, IJ);
    set a = the_array_sort_of S;
A5: I <> the bool-sort of S by AOFA_A00:53;
A6: f complies_with_if_wrt TV by AOFA_000:def 32;
A7: s1.I.m = \0(T,I) value_at(C,s) by A1,Th65;
A8:\0(T,I) value_at(C,s) = 0 by Th36;
A9: s2.I.m = s1.I.m by A1,Th65;
A10: s2.I.i = \1(T,I) value_at(C,s1) by A1,Th65 .= 1 by Th37;
A11: s3.I.i = s2.I.i by A1,A5,Th65;
    consider J1,K1,L1 being Element of S such that
A12: L1 = 1 & K1 = 1 & J1 <> L1 & J1 <> K1 &
    (the connectives of S).11 is_of_type <*J1,K1*>, L1 &
    (the connectives of S).(11+1) is_of_type <*J1,K1,L1*>, J1 &
    (the connectives of S).(11+2) is_of_type <*J1*>, K1 &
    (the connectives of S).(11+3) is_of_type <*K1,L1*>, J1 by AOFA_A00:def 51;
A13: (the Sorts of C).the_array_sort_of S = INT^omega &
    (the Sorts of C).the bool-sort of S = BOOLEAN by Th74,AOFA_A00:def 32;
A14: the bool-sort of S <> I by AOFA_A00:53;
A15: the_array_sort_of S <> I by A12,Th71;
    then
A16: s1.(the_array_sort_of S).M = s.(the_array_sort_of S).M by A1,Th65;
A17: s3.(the_array_sort_of S).M = s2.(the_array_sort_of S).M by A13,A1,Th65;
A18: P[s2]
    proof
      thus R[s2] by A15,A1,Th65,A16;
      thus s2.I.i in NAT & s2.I.m in NAT by A7,A8,A9,A10;
      0 < len z & 0+1 = 1 by A2,NAT_1:3;
      hence s2.I.i <= len z & s2.I.m < s2.I.i & s2.I.m < len z
      by A7,A8,A9,A10,NAT_1:13;
      let mx be Integer; assume
A19:   mx = s2.I.m;
      let j be Nat; assume
A20:   j < s2.I.i;
      1=0+1;
      then j <= 0 & j >= 0 by A20,A10,NAT_1:13;
      then
A21:   j = 0;
      thus z.j <= z.mx by A21,A19,A8,A9,A1,Th65;
    end;
    deffunc F(Element of ST)
    = In((len(s0.(the_array_sort_of S).M))-$1.I.i,NAT);
A22: f.(s2,W) in TV iff Q[f.(s2,W)]
    proof
A23:   @i value_at(C,s2) < length(@M,I) value_at(C,s2) iff f.(s2, W) in TV
      by A1,Th66;
      length(@M,I) value_at(C,s2) = length(@M value_at(C,s2),I) by Th81
      .= len (@M value_at(C,s2)) by Th74
      .= len(s2.(the_array_sort_of S).M) by Th61
      .= len(s0.(the_array_sort_of S).M) by A15,A1,Th65,A16
      .= len(@M value_at(C,s0)) by Th61
      .= length(@M value_at(C,s0), I) by Th74
      .= length(@M,I) value_at(C,s0) by Th81;
      hence thesis by A15,A1,Th65,A16,A17,A11,A23,Th61;
    end;
A24: len(@M value_at(C,s0))
     = length(@M value_at(C,s0),I) by Th74
     .= length(@M,I) value_at(C,s0) by Th81;
A25: for s being Element of ST st Q[s]
    holds (Q[f.(s,J\;K\;W)] iff f.(s,J\;K\;W) in TV) & F(f.(s,J\;K\;W)) < F(s)
    proof
      let s be Element of ST;
      assume A26: Q[s];
A27:   f.(s,J\;K\;W) = f.(f.(s, J\;K), W) & f.(s,J\;K) = f.(f.(s,J),K)
      by AOFA_000:def 29;
      hereby
A28:     f.(s,J\;K\;W).I.i = f.(s,J\;K).I.i by A14,A27,A1,Th65;
A29:     s.a.M = f.(s,CJ).a.M by A13,A1,Th65;
A30:     s.I.i = f.(s,CJ).I.i by A14,A1,Th65;
A31:     now
          per cases;
          suppose f.(s,CJ) in TV;
            then f.(s,J) = f.(f.(s,CJ),IJ) by A6;
            hence f.(s,J).a.M = s.a.M & f.(s,J).I.i = s.I.i
            by A15,A1,A29,A30,Th65;
          end;
          suppose f.(s,CJ) nin TV;
            then f.(s,J) = f.(f.(s,CJ),EmptyIns A) by A6;
            hence f.(s,J).a.M = s.a.M & f.(s,J).I.i = s.I.i
            by A29,A30,AOFA_000:def 28;
          end;
        end;
A32:    (f.(s,J\;K).(the_array_sort_of S).M)
        = (s.(the_array_sort_of S).M) by A31,A27,A15,A1,Th65;
        length(@M,I) value_at(C,f.(s,J\;K))
        = length(@M value_at(C,f.(s,J\;K)),I) by Th81
        .= len(@M value_at(C,f.(s,J\;K))) by Th74
        .= len(f.(s,J\;K).(the_array_sort_of S).M) by Th61
        .= len(@M value_at(C,s0)) by A32,A26,Th61;
        then
        Q[f.(s,J\;K\;W)] iff @i value_at(C,f.(s,J\;K)) <
        length(@M,I) value_at(C,f.(s,J\;K))
        by A26,A28,A24,A32,A27,A13,A1,Th65,Th61;
        hence Q[f.(s,J\;K\;W)] iff f.(s,J\;K\;W) in TV
        by A1,A27,Th66;
      end;
      reconsider sJ = f.(s,J) as ManySortedFunction of the generators of G,
      the Sorts of C by AOFA_A00:48;
      reconsider a = sJ.I.i as Element of C,I;
A33:   @i value_at(C,f.(s,J)) = f.(s,J).I.i &
      \1(T,I) value_at(C,f.(s,J)) = 1 by Th37,Th61;
      f.(s,J\;K\;W) = f.(f.(s,J\;K),W) by AOFA_000:def 29
      .= f.(f.(f.(s,J),K),W) by AOFA_000:def 29;
      then
A34:   f.(s,J\;K\;W).I.i
      = f.(f.(s,J),K).I.i by A1,Th65,A14
      .= (@i+\1(T,I)) value_at(C,f.(s,J)) by A1,Th65
      .= (@i value_at(C,f.(s,J)))+(\1(T,I) value_at(C,f.(s,J))) by Th39
      .= f.(s,J).I.i + 1 by A33,AOFA_A00:55;
      @M value_at(C,s0) = s0.(the_array_sort_of S).M &
      s.I.i < (length(@M,I)) value_at(C,s0) &
      (length(@M,I)) value_at(C,s0) = length(@M value_at(C,s0),I)
      by A26,Th61,Th81;
      then
A35:   s.I.i < len(s0.(the_array_sort_of S).M) by Th74;
      then
A36:   (len(s0.(the_array_sort_of S).M))-s.I.i > 0 by XREAL_1:50;
      (len(s0.(the_array_sort_of S).M))-s.I.i >= 0+1 by A35,XREAL_1:50,INT_1:7;
      then
A37:   (len(s0.(the_array_sort_of S).M))-s.I.i-1 >= 1-1 by XREAL_1:9;
      per cases;
      suppose @M.(@i) value_at(C,s) > @M.(@m) value_at(C,s);
        then f.(s,CJ) in TV & f complies_with_if_wrt TV
        by A1,Th66,AOFA_000:def 32;
        then
A38:     f.(s,J).I.i = f.(f.(s,CJ),IJ).I.i
        .= f.(s,CJ).I.i by A1,Th65
        .= s.I.i by A14,A1,Th65;
        F(f.(s,J\;K\;W)) = (len(s0.(the_array_sort_of S).M))-s.I.i-1
        by A34,A38,A37,INT_1:3,SUBSET_1:def 8;
        then F(f.(s,J\;K\;W)) = F(s)-1 by A36,INT_1:3,SUBSET_1:def 8;
        hence F(f.(s,J\;K\;W)) < F(s) by XREAL_1:44;
      end;
      suppose @M.(@i) value_at(C,s) <= @M.(@m) value_at(C,s);
        then f.(s,CJ) nin TV & f complies_with_if_wrt TV
        by A1,Th66,AOFA_000:def 32;
        then f.(s,J) = f.(f.(s,CJ),EmptyIns A)
        .= f.(s,CJ) by AOFA_000:def 28;
        then f.(s,J).I.i = s.I.i by A1,Th65,A14;
        then F(f.(s,J\;K\;W))
        = len(s0.(the_array_sort_of S).M)-s.I.i-1
        by A34,A37,INT_1:3,SUBSET_1:def 8
        .= F(s)-1 by A36,INT_1:3,SUBSET_1:def 8;
        hence F(f.(s,J\;K\;W)) < F(s) by XREAL_1:44;
      end;
    end;
A39: f iteration_terminates_for J\;K\;W, f.(s2,W) from AOFA_000:sch 3(A22,A25);
A40: for s being Element of ST st P[s] & s in TV & Q[s]
    holds P[f.(s,J\;K)]
    proof
      let s be Element of ST;
      assume A41: P[s];
      assume s in TV;
      assume A42: Q[s];
A43:   s.a.M = f.(s,CJ).a.M by A13,A1,Th65;
      thus R[f.(s,J\;K)]
      proof
        per cases;
        suppose f.(s,CJ) in TV;
          then f.(s,J) = f.(f.(s,CJ),IJ) by A6;
          then
A44:       f.(s,J).a.M = s0.a.M by A41,A15,A1,A43,Th65;
          f.(s,J\;K) = f.(f.(s,J),K) by AOFA_000:def 29;
          hence thesis by A44,A15,A1,Th65;
        end;
        suppose f.(s,CJ) nin TV;
          then f.(s,J) = f.(f.(s,CJ),EmptyIns A) by A6;
          then
A45:       f.(s,J).a.M = s0.a.M by A41,A43,AOFA_000:def 28;
          f.(s,J\;K) = f.(f.(s,J),K) by AOFA_000:def 29;
          hence thesis by A45,A15,A1,Th65;
        end;
      end;
A46:   @i value_at(C,f.(s,J)) = f.(s,J).I.i & @i value_at(C,s) = s.I.i &
      @m value_at(C,s) = s.I.m & \1(T,I) value_at(C,f.(s,J)) = 1
      by Th61,Th37;
A47:   f.(s,J\;K) = f.(f.(s,J),K) by AOFA_000:def 29;
      then
A48:   f.(s,J\;K).I.i = (@i+\1(T,I)) value_at(C,f.(s,J)) by A1,Th65
      .= (@i value_at(C,f.(s,J)))+(\1(T,I) value_at(C,f.(s,J))) by Th39
      .= f.(s,J).I.i+1 by A46,AOFA_A00:55;
A49:   f.(s,J\;K).I.m = f.(s,J).I.m by A47,A1,Th65;
A50:   f.(s,CJ).I.i = s.I.i & f.(s,CJ).I.m = s.I.m &
      f.(s,CJ).a.M = s.a.M by A13,A14,A1,Th65;
A51:   s.I.i is Nat & @M value_at(C,s) = s.a.M & @M value_at(C,s0) = s0.a.M
      by A41,Th61;
      then
A52:   @i value_at(C,s) in dom (@M value_at(C,s))
by A46,A24,A42,AFINSQ_1:86;
A53:   @m value_at(C,s) in dom (@M value_at(C,s))
by A51,A46,A41,AFINSQ_1:86;
A54:   z.(s.I.i) = (@M value_at(C,s)).(s.I.i) by A41,Th61
      .= (@M value_at(C,s) qua Function).(@i value_at(C,s))
      by Th61
      .= (@M value_at(C,s)).(@i value_at(C,s)) by A52,Th74
      .= @M.(@i) value_at(C,s) by Th79;
A55:   z.(s.I.m) = (@M value_at(C,s)).(s.I.m) by A41,Th61
      .= (@M value_at(C,s) qua Function).(@m value_at(C,s))
      by Th61
      .= (@M value_at(C,s)).(@m value_at(C,s)) by A53,Th74
      .= @M.(@m) value_at(C,s) by Th79;
A56:   now per cases;
        case
          z.(s.I.i) > z.(s.I.m);
          then f.(s,CJ) in TV by A1,A54,A55,Th66;
          then
A57:       f.(s,J) = f.(f.(s,CJ),IJ) by A6;
          hence f.(s,J).I.i = s.I.i by A50,A1,Th65;
          thus f.(s,J).I.m = @i value_at(C,f.(s,CJ)) by A57,A1,Th65
          .= s.I.i by A50,Th61;
          thus f.(s,J).a.M = s.a.M by A57,A50,A1,A15,Th65;
        end;
        case
          z.(s.I.i) <= z.(s.I.m);
          then f.(s,CJ) nin TV by A1,A54,A55,Th66;
          then
A58:       f.(s,J) = f.(f.(s,CJ),EmptyIns A) by A6;
          hence f.(s,J).I.i = s.I.i by A50,AOFA_000:def 28;
          thus f.(s,J).I.m = s.I.m by A58,A50,AOFA_000:def 28;
          thus f.(s,J).a.M = s.a.M by A58,A50,AOFA_000:def 28;
        end;
      end;
      reconsider sIi = s.I.i as Element of NAT by A41;
A59:   f.(s,J\;K).I.i = sIi+1 & sIi+1 in NAT by A48,A56,ORDINAL1:def 12;
      thus f.(s,J\;K).I.i in NAT & f.(s,J\;K).I.m in NAT
      by A56,A41,A47,A1,Th65,A48,ORDINAL1:def 12;
      len z = length(@M,I) value_at(C,s0) by A24,Th61;
      hence
      f.(s,J\;K).I.i <= len z by A56,A48,A42,INT_1:7;
      thus f.(s,J\;K).I.m < f.(s,J\;K).I.i by A56,A48,A49,A41,NAT_1:13;
      thus f.(s,J\;K).I.m < len z by A24,Th61,A56,A49,A41,A42;
      let mx be Integer;
      assume
A60:   mx = f.(s,J\;K).I.m;
      let j be Nat; assume
A61:   j < f.(s,J\;K).I.i;
      per cases by A61,A59,NAT_1:22;
      suppose
        j < s.I.i & z.(s.I.i) <= z.(s.I.m);
        hence z.j <= z.mx by A60,A41,A56,A49;
      end;
      suppose
        j < s.I.i & z.(s.I.i) > z.(s.I.m);
        then z.j <= z.(s.I.m) by A41;
        hence z.j <= z.mx by A60,A56,A49,XXREAL_0:2;
      end;
      suppose
        j = s.I.i & z.(s.I.i) <= z.(s.I.m);
        hence z.j <= z.mx by A60,A56,A47,A1,Th65;
      end;
      suppose
        j = s.I.i & z.(s.I.i) > z.(s.I.m);
        hence z.j <= z.mx by A60,A56,A47,A1,Th65;
      end;
    end;
A62: for s being Element of ST st P[s] holds
    P[f.(s,W)] &
    (f.(s,W) in TV iff Q[f.(s,W)])
    proof
      let s be Element of ST;
      assume A63: P[s];
      thus R[f.(s,W)] by A63,A1,A13,Th65;
A64:   f.(s,W).I.i = s.I.i & f.(s,W).I.m = s.I.m by A1,A14,Th65;
      thus f.(s,W).I.i in NAT & f.(s,W).I.m in NAT by A63,A1,A14,Th65;
      thus f.(s,W).I.i <= len z & f.(s,W).I.m < f.(s,W).I.i by A64,A63;
      thus f.(s,W).I.m < len z by A1,A14,Th65,A63;
      thus for mx being Integer st mx = f.(s,W).I.m
      for j being Nat st j < f.(s,W).I.i holds z.j <= z.mx by A64,A63;
A65:  length(@M,I) value_at(C,s)
      = length(@M value_at(C,s),I) by Th81
      .= len(@M value_at(C,s)) by Th74
      .= len(s.(the_array_sort_of S).M) by Th61
      .= len(@M value_at(C,s0)) by A63,Th61;
      hereby
        assume f.(s,W) in TV;
        then @i value_at(C,s) < length(@M,I) value_at(C,s) &
        s.I.i = @i value_at(C,s) by A1,Th66,Th61;
        hence Q[f.(s,W)] by A63,A1,A14,Th65,A13,A24,A65;
      end;
      assume Q[f.(s,W)];
      then @i value_at(C,s) < length(@M,I) value_at(C,s)
      by A64,A24,A65,Th61;
      hence f.(s,W) in TV by A1,Th66;
    end;
A66: P[f.(s2, while(W, J\;K))] &
    not Q[f.(s2, while(W, J\;K))]
    from AOFA_000:sch 5(A18,A39,A40,A62);
A67: f.(s, m:=(\0(T,I),A)\;for-do(i:=(\1(T,I),A),W,K,J))
    = f.(s1, for-do(i:=(\1(T,I),A),W,K,J)) by AOFA_000:def 29
    .= f.(f.(s1, i:=(\1(T,I),A)), while(W, J\;K)) by AOFA_000:def 29;
    then
A68: n in dom z by A66,A3,AFINSQ_1:86;
A69: ^(n,T,I) value_at(C,s) = n by Th90;
A70: z = @M value_at(C,s) by Th61;
A71: z.(f.(s, m:=(\0(T,I),A)\;for-do(i:=(\1(T,I),A),W,K,J)).I.m)
    = (@M value_at(C,s)).(^(n,T,I) value_at(C,s)) by A68,A70,A69,Th74,A3
    .= (@M. ^(n,T,I)) value_at(C,s) by Th79;
A72: (M.(n,I)) value_at(C,s) is UpperBound of X
    proof
      let x be ExtReal;
      assume x in X;
      then consider j being object such that
A73:   j in dom z & x = z.j by A4,FUNCT_1:def 3;
      reconsider j as Nat by A73;
      f.(s,m:=(\0(T,I),A)\;for-do(i:=(\1(T,I),A),W,K,J)).I.i <= len z &
      f.(s,m:=(\0(T,I),A)\;for-do(i:=(\1(T,I),A),W,K,J)).I.i >= len z
      by A24,Th61,A66,A67;
      then f.(s,m:=(\0(T,I),A)\;for-do(i:=(\1(T,I),A),W,K,J)).I.i = len z &
      j < len z by A73,AFINSQ_1:86,XXREAL_0:1;
      hence thesis by A71,A73,A66,A67;
    end;
    for x being UpperBound of X holds (M.(n,I)) value_at(C,s) <= x
    proof
      let x be UpperBound of X;
      n in dom z & M.(n,I) value_at(C,s) = z.n
by A66,A67,A71,A3,AFINSQ_1:86;
      then M.(n,I) value_at(C,s) in X by A4,FUNCT_1:def 3;
      hence (M.(n,I)) value_at(C,s) <= x by XXREAL_2:def 1;
    end;
    hence (M.(n,I)) value_at(C,s) = max X by A72,XXREAL_2:def 3;
  end;

theorem Th94:
  for A being elementary IfWhileAlgebra of the generators of G
  for f being ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G,b) st
  f in C-Execution(A,b,\falseC) & G is C-supported
  for t0,t1 being Element of T,I for J being Algorithm of A
  for P being set st
  P is_invariant_wrt i:=(t0,A),f &
  P is_invariant_wrt b gt(t1,@i,A),f &
  P is_invariant_wrt i:=(@i+\1(T,I),A),f &
  P is_invariant_wrt J,f & J is_terminating_wrt f,P &
  for s holds f.(s,J).I.i = s.I.i & f.(s,b gt(t1,@i,A)).I.i = s.I.i &
  t1 value_at(C,f.(s, b gt(t1,@i,A))) = t1 value_at(C,s) &
  t1 value_at(C,f.(s, J\;i:=(@i+\1(T,I),A))) =
  t1 value_at(C,s)
  holds
  for-do(i:=(t0,A),b gt(t1,@i,A),i:=(@i+\1(T,I),A), J) is_terminating_wrt f, P
  proof
    let A be elementary IfWhileAlgebra of the generators of G;
    let f be ExecutionFunction of A, C-States(the generators of G),
    (\falseC)-States(the generators of G,b);
    assume
A1: f in C-Execution(A,b,\falseC) & G is C-supported;
    let t0,t1 be Element of T,I;
    let J be Algorithm of A;
    let P be set;
    assume A2: P is_invariant_wrt i:=(t0,A),f;
    assume A3: P is_invariant_wrt b gt(t1,@i,A),f;
    assume A4: P is_invariant_wrt i:=(@i+\1(T,I),A),f;
    assume A5: P is_invariant_wrt J,f;
    assume A6: J is_terminating_wrt f,P;
    set W = b gt(t1,@i,A);
    set L = i:=(@i+\1(T,I),A);
    set K = i:=(t0,A);
    set ST = C-States(the generators of G);
    set TV = (\falseC)-States(the generators of G, b);
    assume A7: for s holds f.(s,J).I.i = s.I.i & f.(s,W).I.i = s.I.i &
    t1 value_at(C,f.(s, W)) = t1 value_at(C,s) &
    t1 value_at(C,f.(s, J\;L)) = t1 value_at(C,s);
A8: K is_terminating_wrt f, P by AOFA_000:107;
    L is_terminating_wrt f,P by AOFA_000:107;
    then
A9: W is_terminating_wrt f & J\;L is_terminating_wrt f,P
    by A5,A6,AOFA_000:104,111;
A10: for s st s in P & f.(f.(s,J\;L),W) in TV holds f.(s,J\;L) in P
    by A5,A4,AOFA_000:109,def 39;
    for s st f.(s,W) in P holds f iteration_terminates_for J\;L\;W, f.(s,W)
    proof let s; assume
      f.(s,W) in P;
      defpred P[Element of ST] means $1.I.i < t1 value_at(C,$1);
      deffunc F(Element of ST) = In((t1 value_at(C,$1))-$1.I.i, NAT);
      @i value_at(C,s) = s.I.i &
      f.(s,W).I.i = s.I.i & t1 value_at(C,f.(s,W)) = t1 value_at(C,s)
      by A7,Th61;
      then
A11:   f.(s,W) in TV iff P[f.(s,W)] by A1,Th66;
A12:   for s being Element of ST st P[s]
      holds (P[f.(s,J\;L\;W)] iff f.(s,J\;L\;W) in TV) &
      F(f.(s,J\;L\;W)) < F(s)
      proof
        let s; assume
A13:     P[s];
A14:     f.(s,J\;L\;W) = f.(f.(s, J\;L), W) by AOFA_000:def 29;
        then @i value_at(C,f.(s,J\;L)) = f.(s,J\;L).I.i &
        f.(s,J\;L\;W).I.i = f.(s,J\;L).I.i &
        t1 value_at(C,f.(s,J\;L\;W)) = t1 value_at(C,f.(s,J\;L))
        by A7,Th61;
        hence P[f.(s,J\;L\;W)] iff f.(s,J\;L\;W) in TV by A14,A1,Th66;
A15:     s.I.i+1 <= t1 value_at(C,s) by A13,INT_1:7;
A16:     (@i value_at(C,f.(s,J)))+(\1(T,I)value_at(C,f.(s,J)))
        = (@i value_at(C,f.(s,J)) qua Integer)+(\1(T,I)value_at(C,f.(s,J)))
        by AOFA_A00:55;
        F(f.(s,J\;L\;W))
        = In((t1 value_at(C,f.(f.(s,J\;L),W)))-f.(s,J\;L\;W).I.i, NAT)
        by AOFA_000:def 29
        .= In((t1 value_at(C,f.(s,J\;L)))-f.(s,J\;L\;W).I.i, NAT) by A7
        .= In((t1 value_at(C,s))-f.(s,J\;L\;W).I.i, NAT) by A7
        .= In((t1 value_at(C,s))-f.(f.(s,J\;L),W).I.i, NAT) by AOFA_000:def 29
        .= In((t1 value_at(C,s))-f.(s,J\;L).I.i, NAT) by A7
        .= In((t1 value_at(C,s))-f.(f.(s,J),L).I.i, NAT) by AOFA_000:def 29
        .= In((t1 value_at(C,s) qua Integer)
        -((@i+\1(T,I))value_at(C,f.(s,J))), NAT) by A1,Th65
        .= In((t1 value_at(C,s))-((@i value_at(C,f.(s,J)) qua Integer)+
        (\1(T,I)value_at(C,f.(s,J)))), NAT) by A16,Th39
        .= In((t1 value_at(C,s))-(f.(s,J).I.i+
        (\1(T,I)value_at(C,f.(s,J)))), NAT) by Th61
        .= In((t1 value_at(C,s))-(s.I.i+(\1(T,I)value_at(C,f.(s,J)))), NAT)
        by A7
        .= In((t1 value_at(C,s))-(s.I.i+1), NAT) by Th37
        .= (t1 value_at(C,s))-s.I.i-1 by A15,INT_1:5,SUBSET_1:def 8
        .= F(s)-1 by A13,INT_1:5,SUBSET_1:def 8;
        hence F(f.(s,J\;L\;W)) < F(s) by XREAL_1:44;
      end;
      thus f iteration_terminates_for J\;L\;W, f.(s,W)
      from AOFA_000:sch 3(A11,A12);
    end;
    then while(W,J\;L) is_terminating_wrt f, P by A3,A9,A10,AOFA_000:118;
    hence for-do(K,W,L, J) is_terminating_wrt f, P by A2,A8,AOFA_000:111;
  end;

theorem
  for A being elementary IfWhileAlgebra of the generators of G
  for f being ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G,b) holds
  f in C-Execution(A,b,\falseC) & G is C-supported & i <> m implies
  m:=(\0(T,I),A)\;
  for-do(i:=(\1(T,I),A), b gt(length(@M,I),@i,A), i:=(@i+\1(T,I),A),
         if-then(b gt(@M.(@i), @M.(@m), A), m:=(@i,A)))
  is_terminating_wrt f, {s: s.(the_array_sort_of S).M <> {}}
  proof
    let A be elementary IfWhileAlgebra of the generators of G;
    let f be ExecutionFunction of A, C-States(the generators of G),
    (\falseC)-States(the generators of G,b);
    assume A1: f in C-Execution(A,b,\falseC);
    assume A2: G is C-supported;
    assume A3: i <> m;
    set J = m:=(\0(T,I),A);
    set K = i:=(\1(T,I),A);
    set W = b gt(length(@M,I),@i,A);
    set L = i:=(@i+\1(T,I),A);
    set N = b gt(@M.(@i), @M.(@m), A);
    set O = m:=(@i,A);
    set a = the_array_sort_of S;
    set P = {s: s.(a).M <> {}};
A4: (the Sorts of C).the bool-sort of S = BOOLEAN &
    (the Sorts of C).a = INT^omega by Th74,AOFA_A00:def 32;
    then
A5: the bool-sort of S <> a & I <> a & the bool-sort of S <> I
    by Th73,AOFA_A00:53;
A6: P is_invariant_wrt J, f
    proof
      let s; assume s in P;
      then consider s1 such that
A7:   s = s1 & s1.a.M <> {};
      f.(s,J).a.M = s.a.M by A1,A2,A5,Th65;
      hence thesis by A7;
    end;
A8: P is_invariant_wrt K,f
    proof
      let s; assume s in P;
      then consider s1 such that
A9:   s = s1 & s1.a.M <> {};
      f.(s,K).a.M = s.a.M by A1,A2,A5,Th65;
      hence thesis by A9;
    end;
A10: P is_invariant_wrt W,f
    proof
      let s; assume s in P;
      then consider s1 such that
A11:   s = s1 & s1.a.M <> {};
      f.(s,W).a.M = s.a.M by A1,A2,A4,Th65;
      hence thesis by A11;
    end;
A12: P is_invariant_wrt L,f
    proof
      let s; assume s in P;
      then consider s1 such that
A13:   s = s1 & s1.a.M <> {};
      f.(s,L).a.M = s.a.M by A1,A2,A5,Th65;
      hence thesis by A13;
    end;
A14: P is_invariant_wrt N,f
    proof
      let s; assume s in P;
      then consider s1 such that
A15:   s = s1 & s1.a.M <> {};
      f.(s,N).a.M = s.a.M by A1,A2,A4,Th65;
      hence thesis by A15;
    end;
A16: P is_invariant_wrt O,f
    proof
      let s; assume s in P;
      then consider s1 such that
A17:   s = s1 & s1.a.M <> {};
      f.(s,O).a.M = s.a.M by A1,A2,A5,Th65;
      hence thesis by A17;
    end;
    set ST = C-States(the generators of G);
    set TV = (\falseC)-States(the generators of G, b);
A18: f complies_with_if_wrt TV by AOFA_000:def 32;
A19: P is_invariant_wrt if-then(N,O), f
    proof
      let s; assume s in P;
      then
A20:   f.(s,N) in P by A14;
      per cases;
      suppose f.(s, N) in TV;
        then f.(s,if-then(N,O)) = f.(f.(s,N),O) by A18;
        hence thesis by A20,A16;
      end;
      suppose f.(s, N) nin TV;
        then f.(s,if-then(N,O)) = f.(f.(s,N),EmptyIns A) by A18;
        hence thesis by A20,AOFA_000:def 28;
      end;
    end;
A21: J is_terminating_wrt f,P by AOFA_000:107;
    for s holds f.(s,if-then(N,O)).I.i = s.I.i & f.(s,W).I.i = s.I.i &
    length(@M,I) value_at(C,f.(s,W)) = length(@M,I) value_at(C,s) &
    length(@M,I) value_at(C,f.(s,if-then(N,O)\;L)) =
    length(@M,I) value_at(C,s)
    proof
      let s;
      hereby
        per cases;
        suppose f.(s,N) in TV;
          then f.(s,if-then(N,O)) = f.(f.(s,N),O) by A18;
          hence f.(s,if-then(N,O)).I.i = f.(s,N).I.i by A1,A2,A3,Th65
          .= s.I.i by A1,A2,A5,Th65;
        end;
        suppose f.(s,N) nin TV;
          then f.(s,if-then(N,O)) = f.(f.(s,N),EmptyIns A)
          by A18;
          hence f.(s,if-then(N,O)).I.i = f.(s,N).I.i by AOFA_000:def 28
          .= s.I.i by A1,A2,A5,Th65;
        end;
      end;
A22:   now
        per cases;
        suppose f.(s,N) in TV;
          then f.(s,if-then(N,O)) = f.(f.(s,N),O) by A18;
          hence f.(s,if-then(N,O)).a.M = f.(s,N).a.M by A1,A2,A5,Th65
          .= s.a.M by A1,A2,A4,Th65;
        end;
        suppose f.(s,N) nin TV;
          then f.(s,if-then(N,O)) = f.(f.(s,N),EmptyIns A)
          by A18;
          hence f.(s,if-then(N,O)).a.M = f.(s,N).a.M by AOFA_000:def 28
          .= s.a.M by A1,A2,A4,Th65;
        end;
      end;
      thus f.(s,W).I.i = s.I.i by A1,A2,A5,Th65;
A23:   @M value_at(C,f.(s,if-then(N,O)\;L))
      = f.(s,if-then(N,O)\;L).a.M &
      @M value_at(C,f.(s,W)) = f.(s,W).a.M & @M value_at(C,s) = s.a.M by Th61;
      thus length(@M,I) value_at(C,f.(s,W))
      = length(@M value_at(C,f.(s,W)),I) by Th81
      .= len(f.(s,W).a.M) by A23,Th74
      .= len(s.a.M) by A1,A2,A4,Th65
      .= length(@M value_at(C,s),I) by A23,Th74
      .= length(@M,I) value_at(C,s) by Th81;
      thus length(@M,I) value_at(C,f.(s,if-then(N,O)\;L))
      = length(@M value_at(C,f.(s,if-then(N,O)\;L)),I) by Th81
      .= len(f.(s,if-then(N,O)\;L).a.M) by A23,Th74
      .= len(f.(f.(s,if-then(N,O)),L).a.M) by AOFA_000:def 29
      .= len(f.(s,if-then(N,O)).a.M) by A1,A2,A5,Th65
      .= length(@M value_at(C,s),I) by A23,A22,Th74
      .= length(@M,I) value_at(C,s) by Th81;
   end;
   then for-do(K,W,L,if-then(N,O)) is_terminating_wrt f, P
   by A1,A2,A8,A10,A12,A19,Th94,AOFA_000:107;
   hence thesis by A6,A21,AOFA_000:111;
 end;

begin :: Sorting by exchanging

reserve i1,i2 for pure Element of (the generators of G).I;

definition
  let S,X,T,G;
  attr G is integer-array means
  for I holds
  the set of all @M.t where t is Element of T,I
  c= (the generators of G).I &
  for M for t being Element of T,I
  for g being Element of G,I st g = @M.t
  ex x st x nin (vf t).I & supp-var g = x &
  (supp-term g).(the_array_sort_of S).M = (@M,t)<-@x &
  for s being SortSymbol of S
  for y st y in (vf g).s & (s = the_array_sort_of S implies y <> M)
  holds (supp-term g).s.y = y;
end;

theorem Th96:
  G is integer-array implies
  for t being Element of T,I holds @M.t in (the generators of G).I
  proof
    assume
A1: G is integer-array;
    let t be Element of T,I;
A2: @M.t in the set of all @N.q where q is Element of T,I;
    the set of all @N.q where q is Element of T,I
    c= (the generators of G).I by A1;
    hence @M.t in (the generators of G).I by A2;
  end;

definition
  func (#INT,<=#) -> strict real non empty Poset equals RealPoset INT;
  coherence;
end;

definition
  let S,X,T,G;
  let A be elementary IfWhileAlgebra of the generators of G;
  let a be SortSymbol of S;
  let t1,t2 be Element of T,a such that
A1: t1 in (the generators of G).a;
  func t1:=(t2,A) -> absolutely-terminating Algorithm of A equals: Def19:
  (the assignments of A).[t1,t2];
  coherence
  proof
    reconsider x = t1 as Element of (the generators of G).a by A1;
    (the assignments of A).[t1,t2] = x:=(t2,A);
    hence thesis;
  end;
end;

theorem Th97:
  for X being countable non-empty ManySortedSet of the carrier of S
  for T being vf-free all_vars_including inheriting_operations free_in_itself
  (X,S)-terms integer-array non-empty VarMSAlgebra over S
  for G being basic GeneratorSystem over S,X,T
  for M being pure Element of (the generators of G).the_array_sort_of S
  for i,x being pure Element of (the generators of G).I holds
  @M.@i <> x
  proof
    let X be countable non-empty ManySortedSet of the carrier of S;
    let T be vf-free all_vars_including inheriting_operations free_in_itself
    (X,S)-terms integer-array non-empty VarMSAlgebra over S;
    let G be basic GeneratorSystem over S,X,T;
    let M be pure Element of (the generators of G).the_array_sort_of S;
    let i,x be pure Element of (the generators of G).I;
    set C = the (11,1,1)-array (4,1) integer bool-correct non-empty image of T;
    set ST = C-States the generators of G;
    assume
A1: @M.@i = x;
    set q = the ManySortedFunction of FreeGen T, the Sorts of C;
    set g = q+*(I,x,0)+*(the_array_sort_of S,M,<%1%>)+*(I,i,0);
    set a = the_array_sort_of S;
    consider h being ManySortedFunction of T,C such that
A2: h is_homomorphism T,C & h||FreeGen T = g by MSAFREE4:def 12;
    reconsider s = h||the generators of G as Element of ST
    by A2,AOFA_A00:def 19;
A3: the_array_sort_of S <> I by Th73;
A4: @M value_at(C,s) = s.(the_array_sort_of S).M &
    @i value_at(C,s) = s.I.i &
    @M.@i value_at(C,s) = (@M value_at(C,s)).(@i value_at(C,s)) by Th79,Th61;
A5: i in (FreeGen T).I & x in (FreeGen T).I & M in (FreeGen T).a by Def4;
A6: dom ((q+*(I,x,0)+*(a,M,<%1%>)).I) = (FreeGen T).I &
    0 in INT & INT = (the Sorts of C).I
    by INT_1:def 2,AOFA_A00:55,FUNCT_2:def 1;
    ((h.I)|((the generators of G).I)).i = h.I.i by FUNCT_1:49;
    then
A7: s.I.i = h.I.i by MSAFREE:def 1
    .= ((h.I)|((FreeGen T).I)).i by Def4,FUNCT_1:49
    .= g.I.i by A2,MSAFREE:def 1
    .= (((q+*(I,x,0)+*(a,M,<%1%>)).I)+*(i,0)).i by A5,A6,AOFA_A00:def 2
    .= 0 by Def4,A6,FUNCT_7:31;
    reconsider 01 = 1 as Element of INT by INT_1:def 2;
A8: <%01%> in INT^omega & (the Sorts of C).a = INT^omega &
    dom ((q+*(I,x,0)).a) = (FreeGen T).a & dom (q.I) = (FreeGen T).I &
    dom ((q+*(I,x,0)+*(a,M,<%1%>)).a) = (FreeGen T).a
    by Th74,AFINSQ_1:def 7,FUNCT_2:def 1;
A9: s.a.M = ((h.a)|((the generators of G).a)).M by MSAFREE:def 1
    .= h.a.M by FUNCT_1:49
    .= ((h.a)|((FreeGen T).a)).M by Def4,FUNCT_1:49
    .= g.a.M by A2,MSAFREE:def 1
    .= (q+*(I,x,0)+*(a,M,<%1%>)).a.M by A5,A6,A3,AOFA_A00:def 2
    .= (q+*(I,x,0)).a+*(M,<%1%>).M by A8,A5,AOFA_A00:def 2
    .= <%1%> by Def4,A8,FUNCT_7:31;
    0 < len(s.a.M) by A9,AFINSQ_1:34;
    then 0 in dom(s.a.M) by AFINSQ_1:86;
    then @x value_at(C,s) = s.a.M.(s.I.i) by A1,A4,Th74,A7;
    then
A10: s.I.x = <%1%>.(s.I.i) by A9,Th61
    .= 1 by A7;
    s.I.x = ((h.I)|((the generators of G).I)).x by MSAFREE:def 1
    .= h.I.x by FUNCT_1:49
    .= ((h.I)|((FreeGen T).I)).x by Def4,FUNCT_1:49
    .= g.I.x by A2,MSAFREE:def 1
    .= ((q+*(I,x,0)+*(a,M,<%1%>)).I+*(i,0)).x by A5,A6,AOFA_A00:def 2
    .= (q+*(I,x,0)+*(a,M,<%1%>)).I.x by A7,A10,FUNCT_7:32
    .= (q+*(I,x,0)).I.x by A3,A5,A8,AOFA_A00:def 2
    .= ((q.I)+*(x,0)).x by A5,A6,AOFA_A00:def 2
    .= 0 by Def4,A8,FUNCT_7:31;
    hence contradiction by A10;
  end;

registration
  let S be non empty non void ManySortedSign;
  let A be disjoint_valued MSAlgebra over S;
  cluster the Sorts of A -> disjoint_valued;
  coherence by MSAFREE1:def 2;
end;

definition
  let S,X;
  let T be all_vars_including inheriting_operations free_in_itself
  (X,S)-terms MSAlgebra over S;
  attr T is array-degenerated means
  ex I st
  ex M being Element of (FreeGen T).the_array_sort_of S st
  ex t being Element of T,I st
  @M.t <> Sym(In((the connectives of S).11, the carrier' of S),X)-tree<*M,t*>;
end;

registration
  let S,X;
  cluster Free(S,X) -> non array-degenerated;
  coherence
  proof set T = Free(S,X);
    let I;
    let M be Element of (FreeGen T).the_array_sort_of S;
    let t be Element of T,I;
    set o = In((the connectives of S).11, the carrier' of S);
A1: Free(S,X) = FreeMSA X by MSAFREE3:31;
    consider J1,K1,L1 being Element of S such that
A2: L1 = 1 & K1 = 1 & J1 <> L1 & J1 <> K1 &
    (the connectives of S).11 is_of_type <*J1,K1*>, L1 &
    (the connectives of S).(11+1) is_of_type <*J1,K1,L1*>, J1 &
    (the connectives of S).(11+2) is_of_type <*J1*>, K1 &
    (the connectives of S).(11+3) is_of_type <*K1,L1*>, J1 by AOFA_A00:def 51;
A3: I = 1 by AOFA_A00:def 40;
    11+3 <= len the connectives of S by AOFA_A00:def 51;
    then 11 <= len the connectives of S by XXREAL_0:2;
    then 11 in dom the connectives of S by FINSEQ_3:25;
    then (the connectives of S).11 = o by FUNCT_1:102,SUBSET_1:def 8;
    then the_arity_of o = <*the_array_sort_of S, I*>
    by A2,A3;
    then
    Args(o, T) = product <*(the Sorts of T).the_array_sort_of S,
    (the Sorts of T).I*> by Th23;
    then
    <*@M,t*> in Args(o,T) by FINSEQ_3:124;
    then
    @M.t = [In((the connectives of S).11, the carrier' of S),the carrier of S]
    -tree<*M,t*> by A1,INSTALG1:3;
    hence thesis by MSAFREE:def 9;
  end;
end;

registration
  let S,X;
  cluster non array-degenerated for all_vars_including inheriting_operations
  free_in_itself (X,S)-terms MSAlgebra over S;
  existence
  proof
    take Free(S,X);
    thus thesis;
  end;
end;

theorem Th98:
  T is non array-degenerated implies
  vf (@M.@i) = (I-singleton i) (\/) ((the_array_sort_of S)-singleton M)
  proof set t = @M.@i;
    assume
A1: T is non array-degenerated;
    reconsider N = M as Element of (FreeGen T).the_array_sort_of S by Def4;
    @N = @M; then
A2: @M.@i = Sym(In((the connectives of S).11, the carrier' of S),X)-tree<*M,i*>
    by A1;
A3: <*M,i*>.(0+1) = M & <*M,i*>.(1+1) = i & len <*M,i*> = 2 by FINSEQ_1:44;
    then
A4: t|<*0*> = M & t|<*1*> = i by A2,TREES_4:def 4;
    M in (FreeGen T).the_array_sort_of S by Def4;
    then M in FreeGen(the_array_sort_of S, X) by MSAFREE:def 16;
    then consider m being set such that
A5: m in X.the_array_sort_of S & M = root-tree[m,the_array_sort_of S]
    by MSAFREE:def 15;
    i in (FreeGen T).I by Def4;
    then i in FreeGen(I, X) by MSAFREE:def 16;
    then consider j being set such that
A6: j in X.I & i = root-tree[j,I] by MSAFREE:def 15;
    (t|<*0*>).{} = [m,the_array_sort_of S] & (t|<*1*>).{} = [j,I]
    by A4,A5,A6,TREES_4:3;
    then
A7: ((t|<*0*>).{})`2 = the_array_sort_of S & ((t|<*1*>).{})`2 = I;
    {} in dom root-tree[m,the_array_sort_of S] & {} in dom root-tree[j,I]
    by TREES_1:22;
    then <*0*>^{} in dom t & <*1*>^{} in dom t by A2,A5,A6,A3,TREES_4:11;
    then
A8: <*0*> in dom t & <*1*> in dom t by FINSEQ_1:34;
A9: the_array_sort_of S <> I by Th73;
A10: {M} = (vf t).the_array_sort_of S
    proof
      set A = {t|p where p is Element of dom t: ((t|p).{})`2
      = the_array_sort_of S};
A11:   M in A & A = (vf t).the_array_sort_of S
      by A4,A7,A8,AOFA_A00:def 12;
      hence {M} c= (vf t).the_array_sort_of S by ZFMISC_1:31;
      let x be object; assume x in (vf t).the_array_sort_of S;
      then consider p being Element of dom t such that
A12:   x = t|p & ((t|p).{})`2 = the_array_sort_of S by A11;
      per cases by A2,TREES_4:11;
      suppose p = {};
        then t|p = t by TREES_9:1;
        then (t|p).{} = Sym(In((the connectives of S).11, the carrier' of S),X)
        by A2,TREES_4:def 4
        .= [In((the connectives of S).11, the carrier' of S), the carrier of S]
        by MSAFREE:def 9;
        then ((t|p).{})`2 = the carrier of S &
        the_array_sort_of S in the carrier of S;
        hence thesis by A12;
      end;
      suppose ex k being Nat, T being DecoratedTree,
        q being Node of T st k < len <*M,i*> & T = <*M,i*>.(k+1) & p = <*k*>^q;
        then consider k being Nat, Q being DecoratedTree,
        q being Element of dom Q such that
A13:     k < len <*M,i*> & Q = <*M,i*>.(k+1) & p = <*k*>^q;
A14:     k = 0 or k = 1 by A3,A13,NAT_1:23;
        then q in dom root-tree [m,the_array_sort_of S] or
        q in dom root-tree [j,I] by A13,A5,A6,A3;
        then q in {{}} by TREES_4:3,TREES_1:29;
        then q = {} by TARSKI:def 1;
        then p = <*0*> by A12,A14,A9,A7,A13,FINSEQ_1:34;
        hence x in {M} by A12,A4,TARSKI:def 1;
      end;
    end;
A15: {i} = (vf t).I
    proof
      set A = {t|p where p is Element of dom t: ((t|p).{})`2 = I};
A16:   i in A & A = (vf t).I by A4,A7,A8,AOFA_A00:def 12;
      hence {i} c= (vf t).I by ZFMISC_1:31;
      let x be object; assume x in (vf t).I;
      then consider p being Element of dom t such that
A17:   x = t|p & ((t|p).{})`2 = I by A16;
      per cases by A2,TREES_4:11;
      suppose p = {};
        then t|p = t by TREES_9:1;
        then (t|p).{} = Sym(In((the connectives of S).11, the carrier' of S),X)
        by A2,TREES_4:def 4
        .= [In((the connectives of S).11, the carrier' of S), the carrier of S]
        by MSAFREE:def 9;
        then ((t|p).{})`2 = the carrier of S & I in the carrier of S;
        hence thesis by A17;
      end;
      suppose ex k being Nat, T being DecoratedTree,
        q being Node of T st k < len <*M,i*> & T = <*M,i*>.(k+1) & p = <*k*>^q;
        then consider k being Nat, Q being DecoratedTree,
        q being Element of dom Q such that
A18:     k < len <*M,i*> & Q = <*M,i*>.(k+1) & p = <*k*>^q;
A19:     k = 0 or k = 1 by A3,A18,NAT_1:23;
        then q in dom root-tree [m,the_array_sort_of S] or
        q in dom root-tree [j,I] by A18,A5,A6,A3;
        then q in {{}} by TREES_4:3,TREES_1:29;
        then q = {} by TARSKI:def 1;
        then p = <*1*> by A17,A19,A9,A7,A18,FINSEQ_1:34;
        hence x in {i} by A17,A4,TARSKI:def 1;
      end;
    end;
A20: for s being SortSymbol of S st s <> the_array_sort_of S & s <> I
    holds {} = (vf t).s
    proof
      let s be SortSymbol of S;
      assume A21: s <> the_array_sort_of S;
      assume A22: s <> I;
      set A = {t|p where p is Element of dom t: ((t|p).{})`2 = s};
A23:   A = (vf t).s by AOFA_A00:def 12;
      thus {} c= (vf t).s;
      let x be object; assume x in (vf t).s;
      then consider p being Element of dom t such that
A24:   x = t|p & ((t|p).{})`2 = s by A23;
      per cases by A2,TREES_4:11;
      suppose p = {};
        then t|p = t by TREES_9:1;
        then (t|p).{} = Sym(In((the connectives of S).11, the carrier' of S),X)
        by A2,TREES_4:def 4
        .= [In((the connectives of S).11, the carrier' of S), the carrier of S]
        by MSAFREE:def 9;
        then ((t|p).{})`2 = the carrier of S & s in the carrier of S;
        hence thesis by A24;
      end;
      suppose ex k being Nat, T being DecoratedTree,
        q being Node of T st k < len <*M,i*> & T = <*M,i*>.(k+1) & p = <*k*>^q;
        then consider k being Nat, Q being DecoratedTree,
        q being Element of dom Q such that
A25:     k < len <*M,i*> & Q = <*M,i*>.(k+1) & p = <*k*>^q;
A26:     k = 0 or k = 1 by A3,A25,NAT_1:23;
        then q in dom root-tree [m,the_array_sort_of S] or
        q in dom root-tree [j,I] by A25,A5,A6,A3;
        then q in {{}} by TREES_4:3,TREES_1:29;
        then q = {} by TARSKI:def 1;
        hence thesis by A24,A26,A7,A21,A22,A25,FINSEQ_1:34;
      end;
    end;
    let a be SortSymbol of S;
    per cases;
    suppose
A27:   a = the_array_sort_of S;
      thus (vf t).a
      = {} \/ ((the_array_sort_of S)-singleton M).a by A10,A27,AOFA_A00:6
      .= ((I-singleton i).a)\/((the_array_sort_of S)-singleton M).a
      by A27,A9,AOFA_A00:6
      .= ((I-singleton i) (\/) ((the_array_sort_of S)-singleton M)).a
      by PBOOLE:def 4;
    end;
    suppose
A28:   a = I;
      hence (vf t).a = (I-singleton i).a \/ {} by A15,AOFA_A00:6
      .= ((I-singleton i).a)\/((the_array_sort_of S)-singleton M).a
      by A28,Th73,AOFA_A00:6
      .= ((I-singleton i) (\/) ((the_array_sort_of S)-singleton M)).a
      by PBOOLE:def 4;
    end;
    suppose
A29:   a <> the_array_sort_of S & a <> I;
      hence (vf t).a = {} by A20
      .= (I-singleton i).a \/ {} by A29,AOFA_A00:6
      .= ((I-singleton i).a)\/((the_array_sort_of S)-singleton M).a
      by A29,AOFA_A00:6
      .= ((I-singleton i) (\/) ((the_array_sort_of S)-singleton M)).a
      by PBOOLE:def 4;
    end;
  end;

theorem Th99:
  for A being elementary IfWhileAlgebra of the generators of G
  for f being ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G, b) st
  G is integer-array C-supported & f in C-Execution(A,b,\falseC) &
  X is countable & T is non array-degenerated
  for t being Element of T,I holds
  f.(s,@M.@i:=(t,A)) = f.(s,M:=((@M,@i)<-t,A))
  proof
    let A be elementary IfWhileAlgebra of the generators of G;
    let f be ExecutionFunction of A, C-States(the generators of G),
    (\falseC)-States(the generators of G, b);
    assume A1: G is integer-array;
    assume A2: G is C-supported;
    assume A3: f in C-Execution(A,b,\falseC);
    assume A4: X is countable;
    assume A5: T is non array-degenerated;
    let t be Element of T,I;
    reconsider H = FreeGen T as ManySortedSubset of the generators of G
    by Def3,PBOOLE:def 18;
    set v = t value_at(C,s);
    reconsider p = @M.@i as Element of G,I by A1,Th96,AOFA_A00:def 22;
    reconsider g = s as ManySortedFunction of the generators of G,
    the Sorts of C by AOFA_A00:48;
    reconsider g1 = f.(s,@M.@i:=(t,A)), g2 = f.(s,M:=((@M,@i)<-t,A))
    as ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    reconsider Mi = @M.@i as Element of (the generators of G).I by A1,Th96;
    M in (the generators of G).the_array_sort_of S &
    (the generators of G).the_array_sort_of S
    c= (the Sorts of T).the_array_sort_of S by PBOOLE:def 2,def 18;
    then reconsider m = M as Element of G,the_array_sort_of S
    by AOFA_A00:def 22;
    Mi:=(t,A) = @M.@i:=(t,A) by Def19;
    then
A6: g1 = succ(s,p,v) & g2 = succ(s,m,(@M,@i)<-t value_at(C,s))
    by A3,AOFA_A00:def 28;
A7: vf p = ((the_array_sort_of S)-singleton M)(\/)(I-singleton i) by A5,Th98;
    M in (FreeGen T).the_array_sort_of S by Def4;
    then
A8: vf @M = (the_array_sort_of S)-singleton M by AOFA_A00:41;
    i in (FreeGen T).I by Def4;
    then
A9:vf @i = I-singleton i by AOFA_A00:41;
    consider x such that
A10: x nin (vf @i).I & supp-var p = x &
    (supp-term p).(the_array_sort_of S).M = (@M,@i)<-@x &
    for s being SortSymbol of S
    for y st y in (vf p).s & (s = the_array_sort_of S implies y <> M)
    holds (supp-term p).s.y = y by A1;
    g1 = g2
    proof
      let a be SortSymbol of S;
A11:   now
        let a be SortSymbol of S;
A12:     (vf @M).a c= (vf p).a by A7,A8,PBOOLE:14,def 2;
        let b be Element of (the generators of G).a;
        assume
A13:     b in (FreeGen T).a;
        per cases by A13;
        suppose
A14:       b in (FreeGen T).a & b nin (vf p).a;
          then
A15:       b nin (vf @M).a by A12;
A16:       now
            assume a = the_array_sort_of S;
            then (vf @M).a = {M} by A8,AOFA_A00:6;
            hence b <> m by A15,TARSKI:def 1;
          end;
          b is pure by A14;
          then a = I implies b <> p by A4,Th97;
          then g1.a.b = s.a.b & g2.a.b = s.a.b
          by A2,A6,A14,A15,A16,AOFA_A00:def 27;
          hence g1.a.b = g2.a.b;
        end;
        suppose
A17:       b in (FreeGen T).a & b in (vf p).a & b nin (vf @M).a;
A18:       now
            assume a = the_array_sort_of S;
            then (vf @M).a = {M} by A8,AOFA_A00:6;
            hence b <> m by A17,TARSKI:def 1;
          end;
          consider u being ManySortedFunction of FreeGen T, the Sorts of C
          such that
A19:       u = (g||H)+*(I,supp-var p,v);
A20:      a = I & b = i or a = the_array_sort_of S & b = M by A7,A17,Th4;
A21:       (supp-term p).a.b = @i by A20,A17,A18,A10;
A22:      i in (vf @i).a by A20,A8,A17,Th3,A9;
          b is pure by A17;
          then a = I implies b <> p by A4,Th97;
          then g1.a.b = @i value_at(C,u)
          by A2,A6,A17,A19,A20,A21,A8,Th3,AOFA_A00:def 27
          .= u.a.i by A20,A8,A17,Th3,Th62
          .= (((g||H).a)+*(supp-var p,v)).b by A19,A20,A8,A17,Th3
,AOFA_A00:def 2
          .= (g||H).a.b by A20,A22,A10,A8,A17,Th3,FUNCT_7:32
          .= ((g.a)|(H.a)).b by MSAFREE:def 1
          .= g.a.b by A17,FUNCT_1:49;
          hence g1.a.b = g2.a.b by A2,A6,A17,A18,AOFA_A00:def 27;
        end;
        suppose
A23:       b in (FreeGen T).a & b in (vf p).a & b in (vf @M).a;
          then
A24:       b = M & a = the_array_sort_of S by A8,Th3;
A25:       I <> the_array_sort_of S by Th73;
          set u = (g||H)+*(I,supp-var p,v);
          reconsider uIx = u.I.x as Element of C,I by Def4,FUNCT_2:5;
A26:       dom((g||H).I) = (FreeGen T).I by FUNCT_2:def 1;
          (vf @i).I = {i} by A9,AOFA_A00:6;
          then
A27:       i in (vf @i).I by TARSKI:def 1;
A28:       uIx = ((g||H).I+*(x,v)).x by A10,AOFA_A00:def 2
          .= v by Def4,A26,FUNCT_7:31;
A29:       @M value_at(C,u) = u.(the_array_sort_of S).M by Th62
          .= (g||H).a.b by A24,A25,AOFA_A00:def 2
          .= ((g.a)|(H.a)).b by MSAFREE:def 1
          .= g.a.b by A23,FUNCT_1:49
          .= @M value_at(C,s) by A24,Th61;
A30:       @i value_at(C,u) = u.I.i by Th62
          .= ((g||H).I+*(x,v)).i by A10,AOFA_A00:def 2
          .= (g||H).I.i by A27,A10,FUNCT_7:32
          .= ((g.I)|(H.I)).i by MSAFREE:def 1
          .= g.I.i by Def4,FUNCT_1:49
          .= @i value_at(C,s) by Th61;
          b is pure by A23;
          then a = I implies b <> p by A4,Th97;
          then
A31:       g1.a.b = (@M,@i)<-@x value_at(C,u)
          by A2,A6,A23,A24,A10,AOFA_A00:def 27
          .= (@M value_at(C,u),@i value_at(C,u))<-(@x value_at(C,u)) by Th84
          .= (@M value_at(C,u),@i value_at(C,u))<-v by A28,Th62;
          g2.a.b = (@M,@i)<-t value_at(C,s) by A24,A2,A3,Th65
          .= (@M value_at(C,s),@i value_at(C,s))<-(t value_at(C,s)) by Th80;
          hence g1.a.b = g2.a.b by A31,A29,A30;
        end;
      end;
      thus g1.a = g2.a
      proof
        let b be Element of (the generators of G).a;
        per cases;
        suppose b in (FreeGen T).a;
          hence thesis by A11;
        end;
        suppose
          b nin (FreeGen T).a;
          consider h1 being ManySortedFunction of T,C such that
A32:       h1 is_homomorphism T,C & g1 = h1||the generators of G
          by AOFA_A00:def 19;
          consider h2 being ManySortedFunction of T,C such that
A33:       h2 is_homomorphism T,C & g2 = h2||the generators of G
          by AOFA_A00:def 19;
          h1||FreeGen T = h2||FreeGen T
          proof
            let a be SortSymbol of S;
            thus (h1||FreeGen T).a = (h2||FreeGen T).a
            proof
              let b be Element of (FreeGen T).a;
A34:           H.a c= (the generators of G).a & b in (FreeGen T).a
              by PBOOLE:def 2,def 18;
              thus (h1||FreeGen T).a.b
              = ((h1.a)|((FreeGen T).a)).b by MSAFREE:def 1
              .= h1.a.b by FUNCT_1:49
              .= ((h1.a)|((the generators of G).a)).b by A34,FUNCT_1:49
              .= g1.a.b by A32,MSAFREE:def 1
              .= g2.a.b by A34,A11
              .= ((h2.a)|((the generators of G).a)).b by A33,MSAFREE:def 1
              .= h2.a.b by A34,FUNCT_1:49
              .= ((h2.a)|((FreeGen T).a)).b by FUNCT_1:49
              .= (h2||FreeGen T).a.b by MSAFREE:def 1;
            end;
          end;
          hence thesis by A32,A33,EXTENS_1:19;
        end;
      end;
    end;
    hence f.(s,@M.@i:=(t,A)) = f.(s,M:=((@M,@i)<-t,A));
  end;

registration
  let S,X,T,G,C,s,b;
  cluster s.(the bool-sort of S).b -> boolean;
  coherence
  proof
    reconsider s as ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    (the Sorts of C).(the bool-sort of S) = BOOLEAN by AOFA_A00:def 32;
    then s.(the bool-sort of S).b in BOOLEAN;
    hence thesis;
  end;
end;

theorem
  for A being elementary IfWhileAlgebra of the generators of G
  for f being ExecutionFunction of A, C-States(the generators of G),
  (\falseC)-States(the generators of G, b) st
  G is integer-array C-supported & f in C-Execution(A,b,\falseC) &
  T is non array-degenerated & X is countable
  for J being Algorithm of A st
    for s holds f.(s,J).(the_array_sort_of S).M = s.(the_array_sort_of S).M &
    for D being array of (#INT,<=#) st D = s.(the_array_sort_of S).M holds
    (D <> {} implies f.(s,J).I.i1 in dom D & f.(s,J).I.i2 in dom D) &
    (inversions D <> {} implies [f.(s,J).I.i1,f.(s,J).I.i2] in inversions D) &
    (f.(s,J).(the bool-sort of S).b = TRUE iff inversions D <> {})
  for D being 0-based finite array of (#INT,<=#)
  st D = s.(the_array_sort_of S).M & y <> i1 & y <> i2
  holds
    f.(s,while(J, y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))).
    (the_array_sort_of S).M is ascending permutation of D &
    (J is absolutely-terminating implies
    while(J, y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))
    is_terminating_wrt f, {s1: s1.(the_array_sort_of S).M <> {}})
  proof
    let A be elementary IfWhileAlgebra of the generators of G;
    let f be ExecutionFunction of A, C-States(the generators of G),
    (\falseC)-States(the generators of G, b);
    assume A1: G is integer-array;
    assume A2: G is C-supported;
    assume A3: f in C-Execution(A,b,\falseC);
    assume A4: T is non array-degenerated;
    assume A5: X is countable;
    let J be Algorithm of A;
    assume A6: for s
    holds f.(s,J).(the_array_sort_of S).M = s.(the_array_sort_of S).M &
    for D being array of (#INT,<=#) st D = s.(the_array_sort_of S).M
    holds (D <> {} implies f.(s,J).I.i1 in dom D & f.(s,J).I.i2 in dom D) &
    (inversions D <> {} implies [f.(s,J).I.i1,f.(s,J).I.i2] in inversions D) &
    (f.(s,J).(the bool-sort of S).b = TRUE iff inversions D <> {});
    let D be 0-based finite array of (#INT,<=#);
    assume A7: D = s.(the_array_sort_of S).M;
    assume A8: y <> i1 & y <> i2;
    deffunc F(Nat,Element of C-States(the generators of G))
    = f.($2,J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A));
    set ST = C-States(the generators of G);
A9: the_array_sort_of S <> I by Th73;
    consider g being Function of NAT, ST such that
A10: g.0 = s & for i being Nat holds g.(i+1) = F(i,g.i qua Element of ST)
    from NAT_1:sch 12;
A11: the carrier of (#INT,<=#) = INT by LFUZZY_0:def 3;
    deffunc G(object) = g.In($1,NAT).(the_array_sort_of S).M;
A12: for x being object st x in NAT holds G(x) in INT^omega by AFINSQ_1:def 7;
    consider h being Function of NAT, INT^omega such that
A13: for i being object st i in NAT holds h.i = G(i) from FUNCT_2:sch 2(A12);
A14: dom h = NAT & dom g = NAT by FUNCT_2:def 1;
    then
A15: h is non empty Sequence by ORDINAL1:def 7;
    then
A16: base-h = 0 by EXCHSORT:24;
    then
A17: h.(base-h) = g.In(0,NAT).(the_array_sort_of S).M by A13
    .= D by A7,A10;
A18: for a being Ordinal st a in dom g holds h.a is array of (#INT,<=#)
    proof
      let a be Ordinal;
      assume a in dom g;
      then a in NAT by FUNCT_2:def 1;
      then h.a in INT^omega by FUNCT_2:5;
      hence h.a is array of (#INT,<=#) by A11;
    end;
    set TV = (\falseC)-States(the generators of G, b);
    hereby per cases;
    suppose
A19:   D = {};
      then inversions D = {};
      then f.(s,J).(the bool-sort of S).b <> TRUE by A6,A7;
      then
A20:   f.(s,J).(the bool-sort of S).b = FALSE by XBOOLEAN:def 3
      .= \falseC by Th10;
      f.(s,J) is ManySortedFunction of the generators of G, the Sorts of C
      by AOFA_A00:48;
      then f.(s,J) nin TV & f complies_with_while_wrt TV
      by A20,AOFA_000:def 32,AOFA_A00:def 20;
      then
A21:   f.(s, while(J, y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))) =
      f.(s,J);
      f.(s,J).(the_array_sort_of S).M = D by A6,A7;
      hence f.(s,while(J, y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))).
      (the_array_sort_of S).M is ascending permutation of D
      by A19,A21,EXCHSORT:38;
    end;
    suppose
A22:   D <> {};
      defpred T[Nat] means h.$1 <> {};
A23:   T[0] by A22,A17,A15,EXCHSORT:24;
A24:   for i being Nat holds T[i] implies T[i+1]
      proof
        let i be Nat;
        assume A25: T[i];
A26:     I <> the_array_sort_of S by Th73;
A27:     h.i = g.(In(i,NAT)).(the_array_sort_of S).M by A13
        .= g.i.(the_array_sort_of S).M;
        reconsider R = h.i as array of (#INT,<=#) by A18,A14,ORDINAL1:def 12;
A28:     h.(i+1) = g.(In(i+1,NAT)).(the_array_sort_of S).M by A13
        .= f.(g.i, J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))
        .(the_array_sort_of S).M by A10
        .= f.(f.(g.i, J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
        .(the_array_sort_of S).M by AOFA_000:def 29
        .= f.(f.(f.(g.i, J\;y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
        .(the_array_sort_of S).M by AOFA_000:def 29
        .= f.(f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
        @M.@i2:=(@y,A)).(the_array_sort_of S).M by AOFA_000:def 29;
        @i1 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A)))
        = f.(f.(g.i, J),y:=(@M.@i1,A)).I.i1 by Th61
        .= f.(g.i, J).I.i1 by A2,A3,A8,Th65;
        then
A29:     @i1 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A))) in dom R by A6,A25,A27;
A30:     @M value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A)))
        = f.(f.(g.i, J),y:=(@M.@i1,A)).(the_array_sort_of S).M by Th61;
        f.(g.i, J).(the_array_sort_of S).M = g.i.(the_array_sort_of S).M by A6;
        then
A31:    (f.(f.(g.i, J),y:=(@M.@i1,A))).(the_array_sort_of S).M
        = g.i.(the_array_sort_of S).M by A2,A3,A26,Th65;
        f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))
        .(the_array_sort_of S).M
        = f.(f.(f.(g.i, J),y:=(@M.@i1,A)),M:=((@M,@i1)<-(@M.@i2),A))
        .(the_array_sort_of S).M by A1,A2,A3,A4,A5,Th99
        .= (@M,@i1)<-(@M.@i2) value_at(C, f.(f.(g.i, J),y:=(@M.@i1,A)))
        by A2,A3,Th65
        .= (@M value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A))),
        @i1 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A))))
        <-(@M.@i2 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A)))) by Th80
        .= (f.(f.(g.i, J),y:=(@M.@i1,A)).(the_array_sort_of S).M)+*
        (@i1 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A))),
        (@M.@i2 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A)))))
                 by A29,A31,A27,A30,Th74;
        then
A32:     dom (f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))
        .(the_array_sort_of S).M)
        = dom (g.i.(the_array_sort_of S).M) by A31,FUNCT_7:30;
A33:     @M value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)))
        = f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)).
        (the_array_sort_of S).M by Th61;
        @i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)))
        = f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)).I.i2 by Th61
        .= f.(f.(f.(g.i,J),y:=(@M.@i1,A)),M:=((@M,@i1)<-(@M.@i2),A)).I.i2
        by A1,A2,A3,A4,A5,Th99
        .= f.(f.(g.i,J),y:=(@M.@i1,A)).I.i2 by A2,A3,Th73,Th65
        .= (f.(g.i,J)).I.i2 by A2,A3,A8,Th65;
        then
A34:     @i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)))
        in dom R by A6,A25,A27;
A35:     f.(f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
        @M.@i2:=(@y,A)).(the_array_sort_of S).M
        = f.(f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
        M:=((@M,@i2)<-@y,A)).(the_array_sort_of S).M by A1,A2,A3,A4,A5,Th99
        .= (@M,@i2)<-@y value_at(C,f.(f.(f.(g.i, J),y:=(@M.@i1,A)),
        @M.@i1:=(@M.@i2,A))) by A2,A3,Th65
        .= (@M value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))),
        @i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))))
        <-(@y value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))))
        by Th80
        .= (@M value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))))
        +*(@i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))),
        @y value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))))
        by A32,A33,A34,A27,Th74;
        dom((@M value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),
        @M.@i1:=(@M.@i2,A))))
        +*(@i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))),
        @y value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)))))
        = dom (f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))
        .(the_array_sort_of S).M) by A33,FUNCT_7:30;
        hence h.(i+1) <> {} by A35,A28,A27,A25,A32;
      end;
A36:   for i being Nat holds T[i] from NAT_1:sch 2(A23,A24);
A37:   for a being Nat
      for R being (array of (#INT,<=#)) st R = h.a
      for s st g.a = s
      ex x,y being set st x = f.(s,J).I.i1 & y = f.(s,J).I.i2 &
      x in dom R & y in dom R & h.(a+1) = Swap(R,x,y)
      proof
        let a be Nat;
        let R be array of (#INT,<=#) such that
A38:     R = h.a;
        let s1 such that
A39:     g.a = s1;
        reconsider i = a as Element of NAT by ORDINAL1:def 12;
        reconsider s = g.i as Element of ST;
        set y1 = f.(s,J).I.i1, y2 = f.(s,J).I.i2;
        take y1,y2; thus y1 = f.(s1,J).I.i1 & y2 = f.(s1,J).I.i2 by A39;
        In(i,NAT) = i;
        then
A40:     h.i = g.i.(the_array_sort_of S).M by A13;
        R <> {} by A36,A38;
        hence
A41:     y1 in dom R & y2 in dom R by A40,A6,A38;
A42:     succ Segm a = Segm(i+1) & In(i+1,NAT) = i+1 by NAT_1:38;
        then
A43:     h.succ a = g.(i+1).(the_array_sort_of S).M by A13;
A44:     g.(i+1) = f.(s, J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))
        by A10
        .= f.(f.(s, J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
        by AOFA_000:def 29
        .= f.(f.(f.(s, J\;y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
        by AOFA_000:def 29
        .= f.(f.(f.(f.(s, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
        by AOFA_000:def 29
        .= f.(f.(f.(f.(s, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
        M:=((@M,@i2)<-@y,A)) by A1,A2,A3,A4,A5,Th99
        .= f.(f.(f.(f.(s, J),y:=(@M.@i1,A)),M:=((@M,@i1)<-(@M.@i2),A)),
        M:=((@M,@i2)<-@y,A)) by A1,A2,A3,A4,A5,Th99;
        set s1 = f.(s,J);
        set s2 = f.(s1,y:=(@M.@i1,A));
        set s3 = f.(s2,M:=((@M,@i1)<-(@M.@i2),A));
        set s4 = f.(s3,M:=((@M,@i2)<-@y,A));
A45:     @i1 value_at(C,f.(s,J)) = f.(s,J).I.i1 by Th61;
A46:   s1.(the_array_sort_of S).M = s.(the_array_sort_of S).M by A6;
A47:     @M value_at(C,s1) = s1.(the_array_sort_of S).M by Th61
        .= s.(the_array_sort_of S).M by A6;
A48:     s2.I.y = @M.@i1 value_at(C,s1) by A2,A3,Th65
        .= (@M value_at(C,s1)).(@i1 value_at(C,s1)) by Th79
        .= R.y1 by A38,A41,A45,A40,A47,Th74;
A49:  s2.I.i1 = y1 by A2,A3,A8,Th65;
A50:  s2.I.i2 = y2 by A2,A3,A8,Th65;
A51:   s2.(the_array_sort_of S).M = s1.(the_array_sort_of S).M
        by A2,A3,A9,Th65;
A52:   s3.I.y = s2.I.y by A2,A3,Th73,Th65;
A53:  s3.I.i2 = s2.I.i2 by A2,A3,Th73,Th65;
A54:     @M value_at(C,s2) = s2.(the_array_sort_of S).M by Th61;
A55:     @i1 value_at(C,s2) = s2.I.i1 by Th61;
A56:     @i2 value_at(C,s2) = s2.I.i2 by Th61;
A57:   s3.(the_array_sort_of S).M = (@M,@i1)<-(@M.@i2) value_at(C,s2)
        by A2,A3,Th65
        .= (@M value_at(C,s2),@i1 value_at(C,s2))<-(@M.@i2 value_at(C,s2))
        by Th80
        .= R+*(@i1 value_at(C,s2),@M.@i2 value_at(C,s2))
        by A38,A54,A55,A46,A51,A49,A41,A40,Th74;
A58:     @M value_at(C,s3) = s3.(the_array_sort_of S).M by Th61;
A59:     @i2 value_at(C,s3) = s3.I.i2 by Th61;
A60:     @y value_at(C,s3) = s3.I.y by Th61;
A61:     dom R = dom(R+*(y1,@M.@i2 value_at(C,s2))) by FUNCT_7:30;
A62:   s4.(the_array_sort_of S).M = (@M,@i2)<-@y value_at(C,s3) by A2,A3,Th65
        .= (@M value_at(C,s3),@i2 value_at(C,s3))<-(@y value_at(C,s3))
        by Th80
        .= R+*(y1,@M.@i2 value_at(C,s2))+*(y2, @y value_at(C,s3))
        by A58,A59,A61,A55,A41,A57,A49,A53,A50,Th74;
        @M.@i2 value_at(C,s2) = (@M value_at(C,s2)).(@i2 value_at(C,s2))
        by Th79 .= R.y2 by A38,A41,A54,A56,A50,A51,A46,A40,Th74;
        hence h.(a+1) = Swap(R,y1,y2)
        by A42,A43,A44,A41,A60,A62,A52,A48,FUNCT_7:def 12;
      end;
      defpred Q[Nat] means h.$1 is permutation of D;
A63:   Q[0] by A17,A16,EXCHSORT:38;
A64:   now
        let i be Nat; assume
A65:     Q[i];
        thus Q[i+1]
        proof
          reconsider R = h.i as array of (#INT,<=#) by A18,A14,ORDINAL1:def 12;
          reconsider s = g.i as Element of ST;
          consider x,y being set such that
          x = f.(s,J).I.i1 & y = f.(s,J).I.i2 and
A66:       x in dom R & y in dom R & h.(i+1) = Swap(R,x,y) by A37;
          thus h.(i+1) is permutation of D by A65,A66,EXCHSORT:44;
        end;
      end;
A67:   for i being Nat holds Q[i] from NAT_1:sch 2(A63,A64);
      defpred P[Nat] means
      g.$1.(the_array_sort_of S).M is ascending permutation of D;
A68:   ex i being Nat st P[i]
      proof
        assume
A69:     not thesis;
        for a being Ordinal st a in dom h & succ a in dom h
        ex R being (array of (#INT,<=#)), x,y being set
        st [x,y] in inversions R & h.a = R & h.succ a = Swap(R,x,y)
        proof
          let a be Ordinal;
          assume A70: a in dom h;
          assume succ a in dom h;
          reconsider i = a as Element of NAT by A70,FUNCT_2:def 1;
          reconsider R = h.i as array of (#INT,<=#) by A11;
          reconsider s = g.i as Element of ST;
          set y1 = f.(s,J).I.i1, y2 = f.(s,J).I.i2;
          take R, y1,y2;
          In(i,NAT) = i;
          then
A71:       Q[i] & not P[i] & h.i = g.i.(the_array_sort_of S).M by A67,A69,A13;
          then inversions R <> {} by EXCHSORT:48;
          hence [y1,y2] in inversions R by A71,A6;
          thus h.a = R;
A72:        succ Segm i = Segm(i+1) by NAT_1:38;
          consider x,y being set such that
A73:       x = f.(s,J).I.i1 & y = f.(s,J).I.i2 &
          x in dom R & y in dom R & h.(i+1) = Swap(R,x,y) by A37;
          thus h.succ a = Swap(R,y1,y2) by A73,A72;
        end;
        then h is 0-based arr_computation of D by A15,A14,A17,A18
,EXCHSORT:def 14;
        then h is finite by EXCHSORT:76;
        hence contradiction by A14;
      end;
      consider B being Nat such that
A74:   P[B] & for i being Nat st P[i] holds B <= i from NAT_1:sch 5(A68);
      reconsider h as Sequence of INT^omega by A14,ORDINAL1:def 7;
      reconsider c = h|succ B as array of INT^omega;
      deffunc H(Nat) = f.(g.($1-1),J);
      consider r being FinSequence such that
A75:   len r = B+1 &
      for i being Nat st i in dom r holds r.i = H(i) from FINSEQ_1:sch 2;
      rng r c= ST
      proof
        let x be object; assume x in rng r;
        then consider y being object such that
A76:     y in dom r & x = r.y by FUNCT_1:def 3;
        reconsider y as Nat by A76;
        consider i being Nat such that
A77:     y = 1+i by A76,FINSEQ_3:25,NAT_1:10;
        x = H(y) by A75,A76 .= f.(g.i,J) by A77;
        hence thesis;
      end;
      then reconsider r as non empty FinSequence of ST by A75,FINSEQ_1:def 4;
A78:  1 <= B+1 by NAT_1:11;
A79:   r.1 = f.(g.(1-1),J) by A75,A78,FINSEQ_3:25 .= f.(s,J) by A10;
A80:   r.len r = f.(g.(B+1-1),J) by A75,A78,FINSEQ_3:25 .= f.(g.B,J);
      reconsider R = g.B.(the_array_sort_of S).M as ascending permutation of D
      by A74;
A81:   f.(g.B,J).(the_array_sort_of S).M = R by A6;
A82:   f.(g.B,J) is ManySortedFunction of the generators of G, the Sorts of C
      by AOFA_A00:48;
      inversions R = {} by EXCHSORT:48;
      then f.(g.B,J).(the bool-sort of S).b <> TRUE by A6;
      then f.(g.B,J).(the bool-sort of S).b = FALSE by XBOOLEAN:def 3
      .= \falseC by Th10;
      then
A83:   r.len r nin TV by A80,A82,AOFA_A00:def 20;
      for i being Nat st 1 <= i & i < len r
      holds r.i in TV &
      r.(i+1) = f.(r.i, y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A)\;J)
      proof
        let i be Nat;
        assume A84: 1 <= i;
        assume A85: i < len r;
        consider j being Nat such that
A86:     i = 1+j by A84,NAT_1:10;
A87:     r.i = H(i) by A75,A84,A85,FINSEQ_3:25 .= f.(g.j,J) by A86;
        In(j,NAT) = j;
        then h.j = g.j.(the_array_sort_of S).M by A13;
        then reconsider R = g.j.(the_array_sort_of S).M as permutation of D
        by A67;
A88:     f.(g.j,J) is ManySortedFunction of the generators of G, the Sorts of C
        by AOFA_A00:48;
        i <= B by A75,A85,NAT_1:13;
        then R is not ascending by A74,A86,NAT_1:13;
        then inversions R <> {} by EXCHSORT:48;
        then f.(g.j,J).(the bool-sort of S).b <> FALSE & FALSE = \falseC
        by A6,Th10;
        hence r.i in TV by A87,A88,AOFA_A00:def 20;
        1 <= i+1 & i+1 <= len r by A85,NAT_1:11,13;
        hence r.(i+1) = H(i+1) by A75,FINSEQ_3:25
        .= f.(f.(g.j,J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A)),J)
        by A10,A86
        .= f.(f.(f.(g.j,J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A)),
        J) by AOFA_000:def 29
        .= f.(f.(f.(f.(g.j,J\;y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
        @M.@i2:=(@y,A)),J) by AOFA_000:def 29
        .= f.(f.(f.(f.(f.(g.j,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
        @M.@i2:=(@y,A)),J) by AOFA_000:def 29
        .= f.(f.(f.(f.(g.j,J),y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)),
        @M.@i2:=(@y,A)),J) by AOFA_000:def 29
        .= f.(f.(f.(g.j,J),y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A)),
        J) by AOFA_000:def 29
        .= f.(r.i,y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A)\;J)
        by A87,AOFA_000:def 29;
      end;
      hence f.(s,while(J, y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))).
      (the_array_sort_of S).M is ascending permutation of D
      by A80,A81,A79,A83,AOFA_000:86;
    end;
    end;
    assume
A89:J is absolutely-terminating;
    let s; assume s in {s1: s1.(the_array_sort_of S).M <> {}};
    then consider s1 such that
A90: s = s1 & s1.(the_array_sort_of S).M <> {};
A91: the carrier of (#INT,<=#) = INT by LFUZZY_0:def 3;
    reconsider D = s.(the_array_sort_of S).M as 0-based finite non empty
    array of (#INT,<=#) by A91,A90;
    consider g being Function of NAT, ST such that
A92: g.0 = s & for i being Nat holds g.(i+1) = F(i,g.i qua Element of ST)
    from NAT_1:sch 12;
    deffunc G(object) = g.In($1,NAT).(the_array_sort_of S).M;
A93: for x being object st x in NAT holds G(x) in INT^omega by AFINSQ_1:def 7;
    consider h being Function of NAT, INT^omega such that
A94: for i being object st i in NAT holds h.i = G(i) from FUNCT_2:sch 2(A93);
A95: dom h = NAT & dom g = NAT by FUNCT_2:def 1;
    then
A96: h is non empty Sequence by ORDINAL1:def 7;
    then
A97: base-h = 0 by EXCHSORT:24;
    then
A98: h.(base-h) = g.In(0,NAT).(the_array_sort_of S).M by A94
    .= D by A92;
A99: for a being Ordinal st a in dom g holds h.a is array of (#INT,<=#)
    proof
      let a be Ordinal;
      assume a in dom g;
      then a in NAT by FUNCT_2:def 1;
      then h.a in INT^omega by FUNCT_2:5;
      hence h.a is array of (#INT,<=#) by A91;
    end;
    defpred T[Nat] means h.$1 <> {};
A100: T[0] by A98,A96,EXCHSORT:24;
A101: for i being Nat holds T[i] implies T[i+1]
    proof
      let i be Nat;
      assume A102: T[i];
A103:   I <> the_array_sort_of S by Th73;
A104:   h.i = g.(In(i,NAT)).(the_array_sort_of S).M by A94
      .= g.i.(the_array_sort_of S).M;
      reconsider R = h.i as array of (#INT,<=#) by A99,A95,ORDINAL1:def 12;
A105:   h.(i+1) = g.(In(i+1,NAT)).(the_array_sort_of S).M by A94
      .= f.(g.i, J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))
      .(the_array_sort_of S).M by A92
      .= f.(f.(g.i, J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
      .(the_array_sort_of S).M by AOFA_000:def 29
      .= f.(f.(f.(g.i, J\;y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
      .(the_array_sort_of S).M by AOFA_000:def 29
      .= f.(f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
      @M.@i2:=(@y,A)).(the_array_sort_of S).M by AOFA_000:def 29;
      @i1 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A)))
      = f.(f.(g.i, J),y:=(@M.@i1,A)).I.i1 by Th61
      .= f.(g.i, J).I.i1 by A2,A3,A8,Th65;
      then
A106:   @i1 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A))) in dom R by A6,A102,A104;
A107:   @M value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A)))
      = f.(f.(g.i, J),y:=(@M.@i1,A)).(the_array_sort_of S).M by Th61;
      f.(g.i, J).(the_array_sort_of S).M = g.i.(the_array_sort_of S).M by A6;
      then
A108:  (f.(f.(g.i, J),y:=(@M.@i1,A))).(the_array_sort_of S).M
      = g.i.(the_array_sort_of S).M by A2,A3,A103,Th65;
      f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))
      .(the_array_sort_of S).M
      = f.(f.(f.(g.i, J),y:=(@M.@i1,A)),M:=((@M,@i1)<-(@M.@i2),A))
      .(the_array_sort_of S).M by A1,A2,A3,A4,A5,Th99
      .= (@M,@i1)<-(@M.@i2) value_at(C, f.(f.(g.i, J),y:=(@M.@i1,A)))
      by A2,A3,Th65
      .= (@M value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A))),
      @i1 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A))))
      <-(@M.@i2 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A)))) by Th80
      .= (f.(f.(g.i, J),y:=(@M.@i1,A)).(the_array_sort_of S).M)+*
      (@i1 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A))),
      (@M.@i2 value_at(C,f.(f.(g.i, J),y:=(@M.@i1,A)))))
              by A106,A108,A104,A107,Th74;
      then
A109:   dom (f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))
      .(the_array_sort_of S).M)
      = dom (g.i.(the_array_sort_of S).M) by A108,FUNCT_7:30;
A110:   @M value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)))
      = f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)).
      (the_array_sort_of S).M by Th61;
      @i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)))
      = f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)).I.i2 by Th61
      .= f.(f.(f.(g.i,J),y:=(@M.@i1,A)),M:=((@M,@i1)<-(@M.@i2),A)).I.i2
      by A1,A2,A3,A4,A5,Th99
      .= f.(f.(g.i,J),y:=(@M.@i1,A)).I.i2 by A2,A3,Th73,Th65
      .= (f.(g.i,J)).I.i2 by A2,A3,A8,Th65;
      then
A111:   @i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)))
      in dom R by A6,A102,A104;
A112:   f.(f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
      @M.@i2:=(@y,A)).(the_array_sort_of S).M
      = f.(f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
      M:=((@M,@i2)<-@y,A)).(the_array_sort_of S).M by A1,A2,A3,A4,A5,Th99
      .= (@M,@i2)<-@y value_at(C,f.(f.(f.(g.i, J),y:=(@M.@i1,A)),
      @M.@i1:=(@M.@i2,A))) by A2,A3,Th65
      .= (@M value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))),
      @i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))))
      <-(@y value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))))
      by Th80
      .= (@M value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))))
      +*(@i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))),
      @y value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))))
      by A109,A110,A111,A104,Th74;
      dom((@M value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),
      @M.@i1:=(@M.@i2,A))))
      +*(@i2 value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))),
      @y value_at(C,f.(f.(f.(g.i,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)))))
      = dom (f.(f.(f.(g.i, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A))
      .(the_array_sort_of S).M) by A110,FUNCT_7:30;
      hence h.(i+1) <> {} by A112,A105,A109,A104,A102;
    end;
A113: for i being Nat holds T[i] from NAT_1:sch 2(A100,A101);
A114: for a being Nat
    for R being (array of (#INT,<=#)) st R = h.a
    for s st g.a = s
    ex x,y being set st x = f.(s,J).I.i1 & y = f.(s,J).I.i2 &
    x in dom R & y in dom R & h.(a+1) = Swap(R,x,y)
    proof
      let a be Nat;
      let R be array of (#INT,<=#) such that
A115:   R = h.a;
      let s1 such that
A116:   g.a = s1;
      reconsider i = a as Element of NAT by ORDINAL1:def 12;
      reconsider s = g.i as Element of ST;
      set y1 = f.(s,J).I.i1, y2 = f.(s,J).I.i2;
      take y1,y2; thus y1 = f.(s1,J).I.i1 & y2 = f.(s1,J).I.i2 by A116;
      In(i,NAT) = i;
      then
A117:   h.i = g.i.(the_array_sort_of S).M by A94;
      R <> {} by A115,A113;
      hence
A118:   y1 in dom R & y2 in dom R by A117,A6,A115;
A119:   succ Segm i = Segm(i+1) & In(i+1,NAT) = i+1 by NAT_1:38;
      then
A120:   h.succ a = g.(i+1).(the_array_sort_of S).M by A94;
A121:   g.(i+1) = f.(s, J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))
      by A92
      .= f.(f.(s, J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
      by AOFA_000:def 29
      .= f.(f.(f.(s, J\;y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
      by AOFA_000:def 29
      .= f.(f.(f.(f.(s, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A))
      by AOFA_000:def 29
      .= f.(f.(f.(f.(s, J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
      M:=((@M,@i2)<-@y,A)) by A1,A2,A3,A4,A5,Th99
      .= f.(f.(f.(f.(s, J),y:=(@M.@i1,A)),M:=((@M,@i1)<-(@M.@i2),A)),
      M:=((@M,@i2)<-@y,A)) by A1,A2,A3,A4,A5,Th99;
      set s1 = f.(s,J);
      set s2 = f.(s1,y:=(@M.@i1,A));
      set s3 = f.(s2,M:=((@M,@i1)<-(@M.@i2),A));
      set s4 = f.(s3,M:=((@M,@i2)<-@y,A));
A122:   @i1 value_at(C,f.(s,J)) = f.(s,J).I.i1 by Th61;
A123: s1.(the_array_sort_of S).M = s.(the_array_sort_of S).M by A6;
A124:   @M value_at(C,s1) = s1.(the_array_sort_of S).M by Th61
      .= s.(the_array_sort_of S).M by A6;
A125:   s2.I.y = @M.@i1 value_at(C,s1) by A2,A3,Th65
      .= (@M value_at(C,s1)).(@i1 value_at(C,s1)) by Th79
      .= R.y1 by A115,A118,A122,A117,A124,Th74;
A126: s2.I.i1 = y1 by A2,A3,A8,Th65;
A127: s2.I.i2 = y2 by A2,A3,A8,Th65;
A128: s2.(the_array_sort_of S).M = s1.(the_array_sort_of S).M
      by A2,A3,A9,Th65;
A129: s3.I.y = s2.I.y by A2,A3,Th73,Th65;
A130:s3.I.i2 = s2.I.i2 by A2,A3,Th73,Th65;
A131:   @M value_at(C,s2) = s2.(the_array_sort_of S).M by Th61;
A132:   @i1 value_at(C,s2) = s2.I.i1 by Th61;
A133:   @i2 value_at(C,s2) = s2.I.i2 by Th61;
A134: s3.(the_array_sort_of S).M = (@M,@i1)<-(@M.@i2) value_at(C,s2)
      by A2,A3,Th65
      .= (@M value_at(C,s2),@i1 value_at(C,s2))<-(@M.@i2 value_at(C,s2))
      by Th80
      .= R+*(@i1 value_at(C,s2),@M.@i2 value_at(C,s2))
      by A115,A131,A132,A123,A128,A126,A118,A117,Th74;
A135:   @M value_at(C,s3) = s3.(the_array_sort_of S).M by Th61;
A136:   @i2 value_at(C,s3) = s3.I.i2 by Th61;
A137:   @y value_at(C,s3) = s3.I.y by Th61;
A138:   dom R = dom(R+*(y1,@M.@i2 value_at(C,s2))) by FUNCT_7:30;
A139: s4.(the_array_sort_of S).M = (@M,@i2)<-@y value_at(C,s3) by A2,A3,Th65
      .= (@M value_at(C,s3),@i2 value_at(C,s3))<-(@y value_at(C,s3))
      by Th80
      .= R+*(y1,@M.@i2 value_at(C,s2))+*(y2, @y value_at(C,s3))
      by A135,A136,A138,A132,A118,A134,A126,A130,A127,Th74;
      @M.@i2 value_at(C,s2) = (@M value_at(C,s2)).(@i2 value_at(C,s2))
      by Th79 .= R.y2 by A115,A118,A131,A133,A127,A128,A123,A117,Th74;
      hence h.(a+1) = Swap(R,y1,y2)
      by A119,A120,A121,A118,A137,A139,A129,A125,FUNCT_7:def 12;
    end;
    defpred Q[Nat] means h.$1 is permutation of D;
A140: Q[0] by A98,A97,EXCHSORT:38;
A141: now
      let i be Nat; assume
A142:   Q[i];
      thus Q[i+1]
      proof
        reconsider R = h.i as array of (#INT,<=#) by A99,A95,ORDINAL1:def 12;
        reconsider s = g.i as Element of ST;
        consider x,y being set such that
        x = f.(s,J).I.i1 & y = f.(s,J).I.i2 and
A143:     x in dom R & y in dom R & h.(i+1) = Swap(R,x,y) by A114;
        thus h.(i+1) is permutation of D by A142,A143,EXCHSORT:44;
      end;
    end;
A144: for i being Nat holds Q[i] from NAT_1:sch 2(A140,A141);
    defpred P[Nat] means
    g.$1.(the_array_sort_of S).M is ascending permutation of D;
A145: ex i being Nat st P[i]
    proof
      assume
A146:   not thesis;
      for a being Ordinal st a in dom h & succ a in dom h
      ex R being (array of (#INT,<=#)), x,y being set
      st [x,y] in inversions R & h.a = R & h.succ a = Swap(R,x,y)
      proof
        let a be Ordinal;
        assume A147: a in dom h;
        assume succ a in dom h;
        reconsider i = a as Element of NAT by A147,FUNCT_2:def 1;
        reconsider R = h.i as array of (#INT,<=#) by A91;
        reconsider s = g.i as Element of ST;
        set y1 = f.(s,J).I.i1, y2 = f.(s,J).I.i2;
        take R, y1,y2;
        In(i,NAT) = i;
        then
A148:     Q[i] & not P[i] & h.i = g.i.(the_array_sort_of S).M by A144,A146,A94;
        then inversions R <> {} by EXCHSORT:48;
        hence [y1,y2] in inversions R by A148,A6;
        thus h.a = R;
        consider x,y being set such that
A149:     x = f.(s,J).I.i1 & y = f.(s,J).I.i2 &
        x in dom R & y in dom R & h.(i+1) = Swap(R,x,y) by A114;
         succ Segm i = Segm(i+1) by NAT_1:38;
        hence h.succ a = Swap(R,y1,y2) by A149;
      end;
      then h is 0-based arr_computation of D by A96,A95,A98,A99
,EXCHSORT:def 14;
      then h is finite by EXCHSORT:76;
      hence contradiction by A95;
    end;
    consider B being Nat such that
A150: P[B] & for i being Nat st P[i] holds B <= i from NAT_1:sch 5(A145);
    reconsider h as Sequence of INT^omega by A95,ORDINAL1:def 7;
    reconsider c = h|succ B as array of INT^omega;
    set TV = (\falseC)-States(the generators of G, b);
    deffunc H(Nat) = f.(g.($1-1),J);
    consider r being FinSequence such that
A151: len r = B+1 &
    for i being Nat st i in dom r holds r.i = H(i) from FINSEQ_1:sch 2;
    rng r c= ST
    proof
      let x be object; assume x in rng r;
      then consider y being object such that
A152:   y in dom r & x = r.y by FUNCT_1:def 3;
      reconsider y as Nat by A152;
      consider i being Nat such that
A153:   y = 1+i by A152,FINSEQ_3:25,NAT_1:10;
      x = H(y) by A151,A152 .= f.(g.i,J) by A153;
      hence thesis;
    end;
    then reconsider r as non empty FinSequence of ST by A151,FINSEQ_1:def 4;
A154:1 <= B+1 by NAT_1:11;
A155: r.1 = f.(g.(1-1),J) by A151,A154,FINSEQ_3:25 .= f.(s,J) by A92;
A156: r.len r = f.(g.(B+1-1),J) by A151,A154,FINSEQ_3:25 .= f.(g.B,J);
    reconsider R = g.B.(the_array_sort_of S).M as ascending permutation of D
    by A150;
A157: f.(g.B,J) is ManySortedFunction of the generators of G, the Sorts of C
    by AOFA_A00:48;
    inversions R = {} by EXCHSORT:48;
    then f.(g.B,J).(the bool-sort of S).b <> TRUE by A6;
    then f.(g.B,J).(the bool-sort of S).b = FALSE by XBOOLEAN:def 3
    .= \falseC by Th10;
    then
A158: r.len r nin TV by A156,A157,AOFA_A00:def 20;
    for i being Nat st 1 <= i & i < len r
    holds r.i in TV &
    r.(i+1) = f.(r.i, y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A)\;J)
    proof
      let i be Nat;
      assume A159: 1 <= i;
      assume A160: i < len r;
      consider j being Nat such that
A161:   i = 1+j by A159,NAT_1:10;
A162:   r.i = H(i) by A151,A159,A160,FINSEQ_3:25 .= f.(g.j,J) by A161;
      In(j,NAT) = j;
      then h.j = g.j.(the_array_sort_of S).M by A94;
      then reconsider R = g.j.(the_array_sort_of S).M as permutation of D
      by A144;
A163:   f.(g.j,J) is ManySortedFunction of the generators of G, the Sorts of C
      by AOFA_A00:48;
      i <= B by A151,A160,NAT_1:13;
      then R is not ascending by A150,A161,NAT_1:13;
      then inversions R <> {} by EXCHSORT:48;
      then f.(g.j,J).(the bool-sort of S).b <> FALSE & FALSE = \falseC
      by A6,Th10;
      hence r.i in TV by A162,A163,AOFA_A00:def 20;
      1 <= i+1 & i+1 <= len r by A160,NAT_1:11,13;
      hence r.(i+1) = H(i+1) by A151,FINSEQ_3:25
      .= f.(f.(g.j,J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A)),J)
      by A92,A161
      .= f.(f.(f.(g.j,J\;y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)),@M.@i2:=(@y,A)),J)
      by AOFA_000:def 29
      .= f.(f.(f.(f.(g.j,J\;y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
      @M.@i2:=(@y,A)),J) by AOFA_000:def 29
      .= f.(f.(f.(f.(f.(g.j,J),y:=(@M.@i1,A)),@M.@i1:=(@M.@i2,A)),
      @M.@i2:=(@y,A)),J) by AOFA_000:def 29
      .= f.(f.(f.(f.(g.j,J),y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)),
      @M.@i2:=(@y,A)),J) by AOFA_000:def 29
      .= f.(f.(f.(g.j,J),y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A)),J)
      by AOFA_000:def 29
      .= f.(r.i,y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A)\;J)
      by A162,AOFA_000:def 29;
    end;
    hence [s,while(J, y:=(@M.@i1,A)\;@M.@i1:=(@M.@i2,A)\;@M.@i2:=(@y,A))]
    in TerminatingPrograms(A,ST,TV,f) by A89,A155,A158,AOFA_000:def 33,101;
  end;

