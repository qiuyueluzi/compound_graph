:: Program Algebra over an Algebra
::  by Grzegorz Bancerek
::
:: Received August 27, 2012
:: Copyright (c) 2012-2022 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies AOFA_A00, AOFA_000, PROB_2, UNIALG_1, FUNCT_1, RELAT_1, NAT_1,
      FUNCT_2, XBOOLE_0, MSUALG_1, FUNCOP_1, TREES_4, FINSET_1, MCART_1,
      SUBSET_1, ZF_MODEL, PBOOLE, INCPROJ, MSUALG_3, AOFA_I00, CARD_3,
      ZFMISC_1, MSAFREE, MEMBERED, MSATERM, STRUCT_0, PZFMISC1, GRAPHSP,
      TARSKI, MARGREL1, REALSET1, PRELAMB, COMPUT_1, CARD_1, PARTFUN1, FUNCT_7,
      FINSEQ_1, UNIALG_2, WELLORD1, XXREAL_0, XBOOLEAN, INT_1, NUMBERS,
      ARYTM_1, ARYTM_3, ORDINAL4, FUNCT_4, FINSEQ_2, ORDINAL1, MSUALG_2,
      FUNCT_6, FUNCT_5, FINSEQ_4, MSAFREE4, EXCHSORT, AFINSQ_1, RFINSEQ,
      MATRIX_7, ALGSTR_4;
 notations TARSKI, XBOOLE_0, ZFMISC_1, XTUPLE_0, SUBSET_1, RELAT_1, FUNCT_1,
      PARTFUN1, ORDINAL1, TREES_1, ENUMSET1, FUNCT_2, FUNCOP_1, FINSET_1,
      FINSEQ_2, FINSEQ_1, FINSEQ_4, RFINSEQ, FUNCT_4, BINOP_1, CARD_1, CARD_3,
      PROB_2, NUMBERS, MEMBERED, FUNCT_7, COMPUT_1, PBOOLE, PZFMISC1, MARGREL1,
      AFINSQ_1, XXREAL_0, XCMPLX_0, INT_1, FUNCT_5, FUNCT_6, TREES_2, TREES_4,
      STRUCT_0, MATRIX_7, BORSUK_7, UNIALG_1, UNIALG_2, FREEALG, MSUALG_1,
      MSUALG_2, MSUALG_3, MSUALG_6, CIRCCOMB, AUTALG_1, MSAFREE, MSAFREE1,
      MSATERM, MSAFREE3, AOFA_000, MSAFREE4, EXCHSORT;
 constructors PZFMISC1, AOFA_000, CATALG_1, PUA2MSS1, MSAFREE1, MSUALG_3,
      COMPUT_1, FINSEQ_4, MSAFREE4, AUTALG_1, EXCHSORT, AFINSQ_1, CIRCCOMB,
      RFINSEQ, MATRIX_7, BORSUK_7, BINOP_1;
 registrations RELAT_1, RELSET_1, FUNCT_1, FUNCOP_1, FINSEQ_1, UNIALG_1,
      STRUCT_0, PUA2MSS1, PBOOLE, MSUALG_1, INSTALG1, MSAFREE1, CARD_3,
      XBOOLE_0, AOFA_000, MSAFREE, ORDINAL1, INT_1, XREAL_0, FUNCT_4, FINSEQ_4,
      MARGREL1, SUBSET_1, FINSEQ_2, NUMBERS, CATALG_1, TREES_2, MSUALG_2,
      TREES_3, MSAFREE4, EXCHSORT, NAT_1, XTUPLE_0, FUNCT_7, AFINSQ_1,
      XBOOLEAN, MEMBERED, FOMODEL0, PRE_CIRC, PRE_POLY;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, FUNCT_1, PARTFUN1, FREEALG, UNIALG_1, UNIALG_2, FUNCOP_1,
      STRUCT_0, XBOOLE_0, AOFA_000, PBOOLE, MSUALG_1, MSAFREE, MSAFREE1,
      MSAFREE4;
 equalities BINOP_1, UNIALG_2, FUNCOP_1, FINSEQ_1, XBOOLEAN, AOFA_000,
      MSUALG_1, PUA2MSS1, MSAFREE, ORDINAL1;
 expansions TARSKI, FUNCT_1, PZFMISC1, UNIALG_1, AOFA_000, PBOOLE, MSUALG_1,
      MSAFREE, ZFMISC_1;
 theorems XBOOLE_1, ZFMISC_1, FUNCT_2, FUNCOP_1, TARSKI, XBOOLE_0, FINSEQ_1,
      FINSEQ_3, FUNCT_7, ORDINAL1, PARTFUN1, DTCONSTR, MCART_1, SUBSET_1,
      FUNCT_4, FREEALG, FINSEQ_4, NAT_1, FUNCT_1, XXREAL_0, TREES_9, TREES_1,
      TREES_4, PBOOLE, AUTALG_1, CARD_5, MSATERM, RELAT_1, MSAFREE, UNIALG_1,
      EXTENS_1, MSAFREE3, AOFA_000, ENUMSET1, CARD_1, FINSEQ_2, CARD_3,
      FUNCT_6, GRFUNC_1, CIRCCMB3, RELSET_1, MARGREL1, COMPUT_1, INT_1,
      MSUALG_2, MSUALG_3, FUNCT_5, EQUATION, MSAFREE4, CIRCCOMB, XREAL_1,
      XTUPLE_0, RFINSEQ, FINSEQ_5, MATRIX_7, AFINSQ_1, XREGULAR, QUATERNI;
 schemes XBOOLE_0, FUNCT_1, FUNCT_2, CLASSES1, PBOOLE;

begin :: Preliminary

reserve i for Nat, x,y for set;
reserve S for non empty non void ManySortedSign;
reserve X for non-empty ManySortedSet of S;

theorem Th1:
  for A,B being set
  for R being A-valued Relation
  holds R.:B c= A
  proof
    let A,B be set;
    let R be A-valued Relation;
    R.:B c= rng R & rng R c= A by RELAT_1:111,def 19;
    hence R.:B c= A;
  end;

definition
  let I be set;
  let f be ManySortedSet of I;
  let i be object;
  let x;
  redefine func f+*(i,x) -> ManySortedSet of I;
  coherence;
end;

registration
  let I be set;
  let f be non-empty ManySortedSet of I;
  let i be object;
  let x be non empty set;
  cluster f+*(i,x) -> non-empty;
  coherence
  proof
    now
      thus f+*(i,x) is ManySortedSet of I;
      let y be object; assume
A1:   y in I; dom f = I by PARTFUN1:def 2; then
      (y <> i implies (f+*(i,x)).y = f.y) &
      (y = i implies (f+*(i,x)).y = x) by A1,FUNCT_7:31,32;
      hence (f+*(i,x)).y is non empty by A1;
    end;
    hence thesis;
  end;
end;

theorem Th2:
  for I being set
  for f,g being ManySortedSet of I st f c= g holds f# c= g#
  proof
    let I be set;
    let f,g be ManySortedSet of I;
    assume A1: f c= g;
    let x be object; assume x in I*; then
    reconsider p = x as Element of I*;
A2: f#.p = product(f*p) & g#.p = product(g*p) by FINSEQ_2:def 5;
    let y be object; assume y in f#.x; then
    consider h being Function such that
A3: y = h & dom h = dom(f*p) &
for x being object st x in dom(f*p) holds h.x in (f*p).x
    by A2,CARD_3:def 5;
    p is FinSequence of I by FINSEQ_1:def 11; then
A4: dom f = I & dom g = I & rng p c= I by PARTFUN1:def 2,FINSEQ_1:def 4; then
A5: dom(f*p) = dom p & dom(g*p) = dom p by RELAT_1:27;
    now
      let x be object; assume x in dom(g*p); then
A6:   h.x in (f*p).x & (f*p).x = f.(p.x) & (g*p).x = g.(p.x) & p.x in rng p
      by A3,A5,FUNCT_1:13,def 3; then
      f.(p.x) c= g.(p.x) by A4,A1;
      hence h.x in (g*p).x by A6;
    end;
    hence y in g#.x by A2,A3,A5,CARD_3:9;
  end;

theorem
  for I being non empty set
  for J being set
  for A,B being ManySortedSet of I st A c= B
  for f being Function of J,I holds A*f c= B*f
  proof
    let I be non empty set;
    let J be set;
    let A,B be ManySortedSet of I;
    assume A1: A c= B;
    let f be Function of J,I;
    let x be object; assume A2: x in J; then
    reconsider i = f.x as Element of I by FUNCT_2:5;
    (A*f).x = A.i & (B*f).x = B.i by A2,FUNCT_2:15;
    hence (A*f).x c= (B*f).x by A1;
  end;

registration
  let f be Function-yielding Function;
  cluster Frege f -> Function-yielding;
  coherence
  proof
    let x be object; assume
A1: x in dom Frege f; then
A2: x in product doms f by FUNCT_6:def 7;
    reconsider x as Element of product doms f by A1,FUNCT_6:def 7;
    consider h being Function such that
A3: (Frege f).x = h & dom h = dom f &
    for y being object st y in dom h holds h.y = (uncurry f).(y,x.y)
    by A2,FUNCT_6:def 7;
    thus thesis by A3;
  end;
end;

theorem
  for f,g being Function-yielding Function holds doms (f*g) = (doms f)*g
  proof
    let f,g be Function-yielding Function;
A1: dom doms (f*g) = dom (f*g) & dom doms f = dom f
    by FUNCT_6:def 2;
A2: dom doms (f*g) = dom((doms f)*g)
    proof
      thus dom doms (f*g) c= dom((doms f)*g)
      proof
        let x be object; assume x in dom doms (f*g); then
     x in dom(f*g) & (f*g).x is Function by A1; then
A3:     x in dom g & g.x in dom f & (f*g).x = f.(g.x) by FUNCT_1:11,12; then
        g.x in dom doms f by FUNCT_6:22;
        hence thesis by A3,FUNCT_1:11;
      end;
      let x be object; assume x in dom((doms f)*g); then
A4:   x in dom g & g.x in dom doms f by FUNCT_1:11; then
A5:   g.x in dom f & f.(g.x) is Function & f.(g.x) = (f*g).x
      by A1,FUNCT_1:13; then
      x in dom(f*g) by A4,FUNCT_1:11;
      hence thesis by A5,FUNCT_6:22;
    end;
    now let x be object;
      assume x in dom doms (f*g); then
A6:   x in dom g & g.x in dom doms f & (doms (f*g)).x = proj1((f*g).x)
      by A1,FUNCT_1:11,FUNCT_6:def 2; then
A7:   (doms f).(g.x) = proj1(f.(g.x)) by A1,FUNCT_6:def 2;
      thus (doms(f*g)).x = (doms f).(g.x) by A6,A7,FUNCT_1:13
      .= ((doms f)*g).x by A6,FUNCT_1:13;
    end;
    hence doms (f*g) = (doms f)*g by A2;
  end;

theorem Th5:
  for f,g being Function st g = f.x holds g.y = f..(x,y)
  proof
    let f,g be Function such that
A1: g = f.x;
A2: f..(x,y) = (uncurry f).(x,y) by FUNCT_6:def 5;
    per cases;
    suppose
      x in dom f & y in dom g; then
A3:   [x,y] in dom uncurry f & f.[x,y]`1 is Function by A1,FUNCT_5:def 2;
      [x,y]`1 = x & [x,y]`2 = y;
      hence g.y = f..(x,y) by A1,A2,A3,FUNCT_5:def 2;
    end;
    suppose
A4:   y nin dom g or x nin dom f; then
A5:   (f.x = 0 or g.y = 0) & dom {} = {}
      by FUNCT_1:def 2;
      now
        assume [x,y] in dom uncurry f; then
        consider a being object, h being Function, b being object such that
A6:     [x,y] = [a,b] & a in dom f & h = f.a & b in dom h by FUNCT_5:def 2;
        a = x & b = y by A6,XTUPLE_0:1;
        hence contradiction by A1,A4,A6;
      end; then
      f..(x,y) = 0 & g.y = 0 by A1,A2,A5,FUNCT_1:def 2;
      hence g.y = f..(x,y);
    end;
  end;

definition
  let I be set;
  let i be Element of I;
  let x;
  func i-singleton(x) -> ManySortedSet of I equals (EmptyMS I)+*(i,{x});
  coherence;
end;

theorem Th6:
  for I being non empty set
  for i,j being Element of I
  for x holds (i-singleton x).i = {x} & (i <> j implies (i-singleton x).j = {})
  proof
    let I be non empty set;
    let i,j be Element of I;
    let x;
    dom(EmptyMS I) = I by PARTFUN1:def 2;
    hence (i-singleton x).i = {x} by FUNCT_7:31;
    assume i <> j;
    hence (i-singleton x).j = (EmptyMS I).j by FUNCT_7:32 .= {};
  end;

theorem
  for I being non empty set
  for i being Element of I
  for A being ManySortedSet of I
  for x st x in A.i holds i-singleton x is ManySortedSubset of A
  proof
    let I be non empty set;
    let i be Element of I;
    let A be ManySortedSet of I;
    let x;
    assume A1: x in A.i;
    let y be object;
    assume y in I; then
    (y = i implies (i-singleton x).y = {x}) &
    (y <> i implies (i-singleton x).y = {}) by Th6;
    hence (i-singleton x).y c= A.y by A1,ZFMISC_1:31;
  end;

definition
  let I be set;
  let A,B be ManySortedSet of I;
  let F be ManySortedFunction of A,B;
  let i be set such that A1: i in I;
  let j be set such that A2: j in A.i;
  let v be set such that A3: v in B.i;
  func F+*(i,j,v) -> ManySortedFunction of A,B means
  it.i = F.i+*(j,v) & for s being set st s in I & s <> i holds it.s = F.s;
  existence
  proof
    defpred P[object,object] means ($1 = i implies $2 = F.i+*(j,v)) &
    ($1 <> i implies $2 = F.$1);
A4: for x being object st x in I ex y being object st P[x,y]
    proof
      let x be object; assume x in I;
      per cases;
      suppose
A5:     x = i;
        take F.i+*(j,v);
        thus thesis by A5;
      end;
      suppose
A6:     x <> i;
        take F.x;
        thus thesis by A6;
      end;
    end;
    consider f being Function such that
A7: dom f = I &
     for x being object st x in I holds P[x,f.x] from CLASSES1:sch 1(A4);
    reconsider f as ManySortedSet of I by A7,RELAT_1:def 18,PARTFUN1:def 2;
    f is Function-yielding
    proof
      let x be object; assume x in dom f; then
      (x = i implies f.x = F.i+*(j,v)) & (x <> i implies f.x = F.x) by A7;
      hence thesis;
    end; then
    reconsider f as ManySortedFunction of I;
    f is ManySortedFunction of A,B
    proof
      reconsider j as Element of A.i by A2;
      reconsider v as Element of B.i by A3;
      let x be object; assume
      x in I; then
A8:    P[x,f.x] & F.i+*(j,v) is Function of A.i,B.i by A7;
      thus thesis by A8;
    end;
    then reconsider f as ManySortedFunction of A,B;
    take f;
    thus f.i = F.i+*(j,v) by A1,A7;
    thus thesis by A7;
  end;
  uniqueness
  proof let f1,f2 be ManySortedFunction of A,B such that
A9: f1.i = F.i+*(j,v) & for s being set st s in I & s <> i holds f1.s = F.s
    and
A10: f2.i = F.i+*(j,v) & for s being set st s in I & s <> i holds f2.s = F.s;
    now let x be object; assume
A11:   x in I;
      per cases;
      suppose x = i;
        hence f1.x = f2.x by A9,A10;
      end;
      suppose x <> i; then
        f1.x = F.x & f2.x = F.x by A9,A10,A11;
        hence f1.x = f2.x;
      end;
    end;
    hence thesis;
  end;
end;

::$CD
::$CT 5

theorem
  for X being set, a1,a2,a3,a4,a5,a6 being object
  st a1 in X & a2 in X & a3 in X & a4 in X & a5 in X & a6 in X
  holds {a1,a2,a3,a4,a5,a6} c= X
  by ENUMSET1:def 4;

theorem
  for X being set, a1,a2,a3,a4,a5,a6,a7,a8,a9 being object
  st a1 in X & a2 in X & a3 in X & a4 in X & a5 in X & a6 in X & a7 in X &
  a8 in X & a9 in X
  holds {a1,a2,a3,a4,a5,a6,a7,a8,a9} c= X
  by ENUMSET1:def 7;

theorem Th10:
  for X being set, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 being object
  st a1 in X & a2 in X & a3 in X & a4 in X & a5 in X & a6 in X & a7 in X &
  a8 in X & a9 in X & a10 in X
  holds {a1,a2,a3,a4,a5,a6,a7,a8,a9,a10} c= X
  by ENUMSET1:def 8;

theorem
  for a1,a2,a3,a4,a5,a6,a7,a8,a9 being object holds
  {a1}\/{a2,a3,a4,a5,a6,a7,a8,a9} = {a1,a2,a3,a4,a5,a6,a7,a8,a9}
  proof
    let a1,a2,a3,a4,a5,a6,a7,a8,a9 be object;
    thus {a1}\/{a2,a3,a4,a5,a6,a7,a8,a9} c= {a1,a2,a3,a4,a5,a6,a7,a8,a9}
    proof
      let x be object; assume x in {a1}\/{a2,a3,a4,a5,a6,a7,a8,a9}; then
      x in {a1} or x in {a2,a3,a4,a5,a6,a7,a8,a9} by XBOOLE_0:def 3; then
      x = a1 or x = a2 or x = a3 or x = a4 or x = a5 or x = a6 or x = a7 or
      x = a8 or x = a9 by TARSKI:def 1,ENUMSET1:def 6;
      hence thesis by ENUMSET1:def 7;
    end;
    let x be object; assume
    x in {a1,a2,a3,a4,a5,a6,a7,a8,a9}; then
    x = a1 or x = a2 or x = a3 or x = a4 or x = a5 or x = a6 or x = a7 or
    x = a8 or x = a9 by ENUMSET1:def 7; then
    x in {a1} or x in {a2,a3,a4,a5,a6,a7,a8,a9} by TARSKI:def 1,ENUMSET1:def 6;
    hence thesis by XBOOLE_0:def 3;
  end;

theorem Th12:
  for a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 being object holds
  {a1}\/{a2,a3,a4,a5,a6,a7,a8,a9,a10} = {a1,a2,a3,a4,a5,a6,a7,a8,a9,a10}
  proof
    let a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 be object;
    thus {a1}\/{a2,a3,a4,a5,a6,a7,a8,a9,a10}
    c= {a1,a2,a3,a4,a5,a6,a7,a8,a9,a10}
    proof
      let x be object; assume x in {a1}\/{a2,a3,a4,a5,a6,a7,a8,a9,a10}; then
      x in {a1} or x in {a2,a3,a4,a5,a6,a7,a8,a9,a10} by XBOOLE_0:def 3; then
      x = a1 or x = a2 or x = a3 or x = a4 or x = a5 or x = a6 or x = a7 or
      x = a8 or x = a9 or x = a10 by TARSKI:def 1,ENUMSET1:def 7;
      hence thesis by ENUMSET1:def 8;
    end;
    let x be object; assume
    x in {a1,a2,a3,a4,a5,a6,a7,a8,a9,a10}; then
    x = a1 or x = a2 or x = a3 or x = a4 or x = a5 or x = a6 or x = a7 or
    x = a8 or x = a9 or x = a10 by ENUMSET1:def 8; then
    x in {a1} or x in {a2,a3,a4,a5,a6,a7,a8,a9,a10}
    by TARSKI:def 1,ENUMSET1:def 7;
    hence thesis by XBOOLE_0:def 3;
  end;

theorem Th13:
  for a1,a2,a3,a4,a5,a6,a7,a8,a9 being object holds
  {a1,a2,a3}\/{a4,a5,a6,a7,a8,a9} = {a1,a2,a3,a4,a5,a6,a7,a8,a9}
  proof
    let a1,a2,a3,a4,a5,a6,a7,a8,a9 be object;
    thus {a1,a2,a3}\/{a4,a5,a6,a7,a8,a9} c= {a1,a2,a3,a4,a5,a6,a7,a8,a9}
    proof
      let x be object; assume x in {a1,a2,a3}\/{a4,a5,a6,a7,a8,a9}; then
      x in {a1,a2,a3} or x in {a4,a5,a6,a7,a8,a9} by XBOOLE_0:def 3; then
      x = a1 or x = a2 or x = a3 or x = a4 or x = a5 or x = a6 or x = a7 or
      x = a8 or x = a9 by ENUMSET1:def 1,def 4;
      hence thesis by ENUMSET1:def 7;
    end;
    let x be object; assume
    x in {a1,a2,a3,a4,a5,a6,a7,a8,a9}; then
    x = a1 or x = a2 or x = a3 or x = a4 or x = a5 or x = a6 or x = a7 or
    x = a8 or x = a9 by ENUMSET1:def 7; then
    x in {a1,a2,a3} or x in {a4,a5,a6,a7,a8,a9} by ENUMSET1:def 1,def 4;
    hence thesis by XBOOLE_0:def 3;
  end;

theorem Th14:
  for a1,a2,a3,a4 being object st a1 <> a2 & a1 <> a3 & a1 <> a4 &
  a2 <> a3 & a2 <> a4 & a3 <> a4
  holds <*a1,a2,a3,a4*> is one-to-one
  proof
    let a1,a2,a3,a4 be object;
    assume A1: a1 <> a2;
    assume A2: a1 <> a3;
    assume A3: a1 <> a4;
    assume A4: a2 <> a3;
    assume A5: a2 <> a4;
    assume A6: a3 <> a4;
A7: dom <*a1,a2,a3,a4*> = Seg 4 by FINSEQ_1:89;
    let x,y be object; assume x in dom <*a1,a2,a3,a4*>;
    then
A8: x = 1 or x = 2 or x = 3 or x = 4 by A7,ENUMSET1:def 2,FINSEQ_3:2;
    assume
A9: y in dom <*a1,a2,a3,a4*>;
    <*a1,a2,a3,a4*>.1 = a1 & <*a1,a2,a3,a4*>.2 = a2 & <*a1,a2,a3,a4*>.3 = a3 &
    <*a1,a2,a3,a4*>.4 = a4 by FINSEQ_4:76;
    hence thesis by A1,A2,A3,A4,A5,A6,A8,A7,A9,ENUMSET1:def 2,FINSEQ_3:2;
  end;

definition
  let a1,a2,a3,a4,a5,a6 be object;
  func <*a1,a2,a3,a4,a5,a6*> -> FinSequence equals <*a1,a2,a3,a4,a5*>^<*a6*>;
  coherence;
end;

definition
  let X be non empty set;
  let a1,a2,a3,a4,a5,a6 be Element of X;
  redefine func <*a1,a2,a3,a4,a5,a6*> -> FinSequence of X;
  coherence
  proof
    <*a1,a2,a3,a4,a5*>^<*a6*> is FinSequence of X;
    hence thesis;
  end;
end;

registration
  let a1,a2,a3,a4,a5,a6 be object;
  cluster <*a1,a2,a3,a4,a5,a6*> -> 6-element;
  coherence;
end;

theorem
  for a1,a2,a3,a4,a5,a6 being object
  for f being FinSequence holds f = <*a1,a2,a3,a4,a5,a6*> iff len f = 6 &
  f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5 & f.6 = a6
  proof
    let a1,a2,a3,a4,a5,a6 be object;
    let f be FinSequence;
A1: now
      let f be FinSequence;
      assume A2: f = <*a1,a2,a3,a4,a5,a6*>;
      hence len f  = len <*a1,a2,a3,a4,a5*>+len <*a6*>
      by FINSEQ_1:22 .= 5+len <*a6*> by FINSEQ_4:78 .= 5+1 by FINSEQ_1:39
      .= 6;
      dom <*a1,a2,a3,a4,a5*> = Seg 5 by FINSEQ_1:89; then
      1 in dom <*a1,a2,a3,a4,a5*> & 2 in dom <*a1,a2,a3,a4,a5*> &
      3 in dom <*a1,a2,a3,a4,a5*> & 4 in dom <*a1,a2,a3,a4,a5*> &
      5 in dom <*a1,a2,a3,a4,a5*>; then
      f.1 = <*a1,a2,a3,a4,a5*>.1 & f.2 = <*a1,a2,a3,a4,a5*>.2 &
      f.3 = <*a1,a2,a3,a4,a5*>.3 & f.4 = <*a1,a2,a3,a4,a5*>.4 &
      f.5 = <*a1,a2,a3,a4,a5*>.5 by A2,FINSEQ_1:def 7;
      hence f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5
      by FINSEQ_4:78;
A3:   len <*a1,a2,a3,a4,a5*> = 5 by FINSEQ_4:78;
      1 in Seg 1; then
      1 in dom <*a6*> & 5+1 = 6 by FINSEQ_1:89;
      hence f.6 = <*a6*>.1 by A2,A3,FINSEQ_1:def 7 .= a6 by FINSEQ_1:40;
    end;
    hence f = <*a1,a2,a3,a4,a5,a6*> implies len f = 6 &
    f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5 & f.6 = a6;
    assume A4: len f = 6; len <*a1,a2,a3,a4,a5,a6*> = 6 by A1; then
A5: dom f = Seg 6 & dom <*a1,a2,a3,a4,a5,a6*> = Seg 6 by A4,FINSEQ_1:def 3;
    assume A6: f.1 = a1;
    assume A7: f.2 = a2;
    assume A8: f.3 = a3;
    assume A9: f.4 = a4;
    assume A10: f.5 = a5;
    assume A11: f.6 = a6;
    now let x be object;
      assume x in Seg 6; then
      x = 1 or x = 2 or x = 3 or x = 4 or x = 5 or x = 6
      by FINSEQ_3:4,ENUMSET1:def 4;
      hence f.x = <*a1,a2,a3,a4,a5,a6*>.x by A1,A6,A7,A8,A9,A10,A11;
    end;
    hence f = <*a1,a2,a3,a4,a5,a6*> by A5;
  end;

theorem
  for a1,a2,a3,a4,a5,a6 being object holds
  rng <*a1,a2,a3,a4,a5,a6*> = {a1,a2,a3,a4,a5,a6}
  proof
    let a1,a2,a3,a4,a5,a6 be object;
    thus rng <*a1,a2,a3,a4,a5,a6*>
    = rng <*a1,a2,a3,a4,a5*> \/ rng <*a6*> by FINSEQ_1:31
    .= {a1,a2,a3,a4,a5} \/ rng <*a6*> by CIRCCMB3:14
    .= {a1,a2,a3,a4,a5} \/ {a6} by FINSEQ_1:39
    .= {a1,a2,a3,a4,a5,a6} by ENUMSET1:15;
  end;

definition
  let a1,a2,a3,a4,a5,a6,a7 be object;
  func <*a1,a2,a3,a4,a5,a6,a7*> -> FinSequence equals
  <*a1,a2,a3,a4,a5*>^<*a6,a7*>;
  coherence;
end;

definition
  let X be non empty set;
  let a1,a2,a3,a4,a5,a6,a7 be Element of X;
  redefine func <*a1,a2,a3,a4,a5,a6,a7*> -> FinSequence of X;
  coherence
  proof
    <*a1,a2,a3,a4,a5*>^<*a6,a7*> is FinSequence of X;
    hence thesis;
  end;
end;

registration
  let a1,a2,a3,a4,a5,a6,a7 be object;
  cluster <*a1,a2,a3,a4,a5,a6,a7*> -> 7-element;
  coherence;
end;

theorem
  for a1,a2,a3,a4,a5,a6,a7 being object
  for f being FinSequence holds f = <*a1,a2,a3,a4,a5,a6,a7*> iff len f = 7 &
  f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5 & f.6 = a6 & f.7 = a7
  proof
    let a1,a2,a3,a4,a5,a6,a7 be object;
    let f be FinSequence;
A1: now
      let f be FinSequence;
      assume A2: f = <*a1,a2,a3,a4,a5,a6,a7*>;
      hence len f  = len <*a1,a2,a3,a4,a5*>+len <*a6,a7*>
      by FINSEQ_1:22 .= 5+len <*a6,a7*> by FINSEQ_4:78 .= 5+2 by FINSEQ_1:44
      .= 7;
      dom <*a1,a2,a3,a4,a5*> = Seg 5 by FINSEQ_1:89; then
      1 in dom <*a1,a2,a3,a4,a5*> & 2 in dom <*a1,a2,a3,a4,a5*> &
      3 in dom <*a1,a2,a3,a4,a5*> & 4 in dom <*a1,a2,a3,a4,a5*> &
      5 in dom <*a1,a2,a3,a4,a5*>; then
      f.1 = <*a1,a2,a3,a4,a5*>.1 & f.2 = <*a1,a2,a3,a4,a5*>.2 &
      f.3 = <*a1,a2,a3,a4,a5*>.3 & f.4 = <*a1,a2,a3,a4,a5*>.4 &
      f.5 = <*a1,a2,a3,a4,a5*>.5 by A2,FINSEQ_1:def 7;
      hence f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5
      by FINSEQ_4:78;
A3:   len <*a1,a2,a3,a4,a5*> = 5 by FINSEQ_4:78;
A4:   1 in Seg 2 & 2 in Seg 2; then
      1 in dom <*a6,a7*> & 5+1 = 6 by FINSEQ_1:89;
      hence f.6 = <*a6,a7*>.1 by A2,A3,FINSEQ_1:def 7 .= a6 by FINSEQ_1:44;
      2 in dom <*a6,a7*> & 5+2 = 7 by A4,FINSEQ_1:89;
      hence f.7 = <*a6,a7*>.2 by A2,A3,FINSEQ_1:def 7 .= a7 by FINSEQ_1:44;
    end;
    hence f = <*a1,a2,a3,a4,a5,a6,a7*> implies len f = 7 &
    f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5 & f.6 = a6 & f.7=a7;
    assume A5: len f = 7; len <*a1,a2,a3,a4,a5,a6,a7*> = 7 by A1; then
A6: dom f = Seg 7 & dom <*a1,a2,a3,a4,a5,a6,a7*> = Seg 7 by A5,FINSEQ_1:def 3;
    assume A7: f.1 = a1;
    assume A8: f.2 = a2;
    assume A9: f.3 = a3;
    assume A10: f.4 = a4;
    assume A11: f.5 = a5;
    assume A12: f.6 = a6;
    assume A13: f.7 = a7;
    now let x be object;
      assume x in Seg 7; then
      x = 1 or x = 2 or x = 3 or x = 4 or x = 5 or x = 6 or x = 7
      by FINSEQ_3:5,ENUMSET1:def 5;
      hence f.x = <*a1,a2,a3,a4,a5,a6,a7*>.x by A1,A7,A8,A9,A10,A11,A12,A13;
    end;
    hence f = <*a1,a2,a3,a4,a5,a6,a7*> by A6;
  end;

theorem
  for a1,a2,a3,a4,a5,a6,a7 being object holds
  rng <*a1,a2,a3,a4,a5,a6,a7*> = {a1,a2,a3,a4,a5,a6,a7}
  proof
    let a1,a2,a3,a4,a5,a6,a7 be object;
    thus rng <*a1,a2,a3,a4,a5,a6,a7*>
    = rng <*a1,a2,a3,a4,a5*> \/ rng <*a6,a7*> by FINSEQ_1:31
    .= {a1,a2,a3,a4,a5} \/ rng <*a6,a7*> by CIRCCMB3:14
    .= {a1,a2,a3,a4,a5} \/ {a6,a7} by FINSEQ_2:127
    .= {a1,a2,a3,a4,a5,a6,a7} by ENUMSET1:20;
  end;

definition
  let a1,a2,a3,a4,a5,a6,a7,a8 be object;
  func <*a1,a2,a3,a4,a5,a6,a7,a8*> -> FinSequence equals
  <*a1,a2,a3,a4,a5*>^<*a6,a7,a8*>;
  coherence;
end;

definition
  let X be non empty set;
  let a1,a2,a3,a4,a5,a6,a7,a8 be Element of X;
  redefine func <*a1,a2,a3,a4,a5,a6,a7,a8*> -> FinSequence of X;
  coherence
  proof
    <*a1,a2,a3,a4,a5*>^<*a6,a7,a8*> is FinSequence of X;
    hence thesis;
  end;
end;

registration
  let a1,a2,a3,a4,a5,a6,a7,a8 be object;
  cluster <*a1,a2,a3,a4,a5,a6,a7,a8*> -> 8-element;
  coherence;
end;

theorem Th19:
  for a1,a2,a3,a4,a5,a6,a7,a8 being object
  for f being FinSequence holds f = <*a1,a2,a3,a4,a5,a6,a7,a8*> iff len f = 8 &
  f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5 & f.6 = a6 & f.7 = a7 &
  f.8 = a8
  proof
    let a1,a2,a3,a4,a5,a6,a7,a8 be object;
    let f be FinSequence;
A1: now
      let f be FinSequence;
      assume A2: f = <*a1,a2,a3,a4,a5,a6,a7,a8*>;
      hence len f  = len <*a1,a2,a3,a4,a5*>+len <*a6,a7,a8*>
      by FINSEQ_1:22 .= 5+len <*a6,a7,a8*> by FINSEQ_4:78 .= 5+3 by FINSEQ_1:45
      .= 8;
      dom <*a1,a2,a3,a4,a5*> = Seg 5 by FINSEQ_1:89; then
      1 in dom <*a1,a2,a3,a4,a5*> & 2 in dom <*a1,a2,a3,a4,a5*> &
      3 in dom <*a1,a2,a3,a4,a5*> & 4 in dom <*a1,a2,a3,a4,a5*> &
      5 in dom <*a1,a2,a3,a4,a5*>; then
      f.1 = <*a1,a2,a3,a4,a5*>.1 & f.2 = <*a1,a2,a3,a4,a5*>.2 &
      f.3 = <*a1,a2,a3,a4,a5*>.3 & f.4 = <*a1,a2,a3,a4,a5*>.4 &
      f.5 = <*a1,a2,a3,a4,a5*>.5 by A2,FINSEQ_1:def 7;
      hence f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5
      by FINSEQ_4:78;
A3:   len <*a1,a2,a3,a4,a5*> = 5 by FINSEQ_4:78;
A4:   1 in Seg 3 & 2 in Seg 3 & 3 in Seg 3; then
      1 in dom <*a6,a7,a8*> & 5+1 = 6 by FINSEQ_1:89;
      hence f.6 = <*a6,a7,a8*>.1 by A2,A3,FINSEQ_1:def 7 .= a6 by FINSEQ_1:45;
      2 in dom <*a6,a7,a8*> & 5+2 = 7 by A4,FINSEQ_1:89;
      hence f.7 = <*a6,a7,a8*>.2 by A2,A3,FINSEQ_1:def 7 .= a7 by FINSEQ_1:45;
      3 in dom <*a6,a7,a8*> & 5+3 = 8 by A4,FINSEQ_1:89;
      hence f.8 = <*a6,a7,a8*>.3 by A2,A3,FINSEQ_1:def 7 .= a8 by FINSEQ_1:45;
    end;
    hence f = <*a1,a2,a3,a4,a5,a6,a7,a8*> implies len f = 8 &
    f.1 = a1 & f.2 = a2 & f.3 = a3 & f.4 = a4 & f.5 = a5 & f.6 = a6 & f.7=a7 &
    f.8 = a8;
    assume A5: len f = 8; len <*a1,a2,a3,a4,a5,a6,a7,a8*> = 8 by A1; then
A6: dom f = Seg 8 & dom <*a1,a2,a3,a4,a5,a6,a7,a8*> = Seg 8
    by A5,FINSEQ_1:def 3;
    assume A7: f.1 = a1;
    assume A8: f.2 = a2;
    assume A9: f.3 = a3;
    assume A10: f.4 = a4;
    assume A11: f.5 = a5;
    assume A12: f.6 = a6;
    assume A13: f.7 = a7;
    assume A14: f.8 = a8;
    now let x be object;
      assume x in Seg 8; then
      x = 1 or x = 2 or x = 3 or x = 4 or x = 5 or x = 6 or x = 7 or x = 8
      by FINSEQ_3:6,ENUMSET1:def 6;
      hence f.x = <*a1,a2,a3,a4,a5,a6,a7,a8*>.x by A1,A7,A8,A9,A10,A11,A12,A13,
A14;
    end;
    hence f = <*a1,a2,a3,a4,a5,a6,a7,a8*> by A6;
  end;

theorem Th20:
  for a1,a2,a3,a4,a5,a6,a7,a8 being object holds
  rng <*a1,a2,a3,a4,a5,a6,a7,a8*> = {a1,a2,a3,a4,a5,a6,a7,a8}
  proof
    let a1,a2,a3,a4,a5,a6,a7,a8 be object;
    thus rng <*a1,a2,a3,a4,a5,a6,a7,a8*>
    = rng <*a1,a2,a3,a4,a5*> \/ rng <*a6,a7,a8*> by FINSEQ_1:31
    .= {a1,a2,a3,a4,a5} \/ rng <*a6,a7,a8*> by CIRCCMB3:14
    .= {a1,a2,a3,a4,a5} \/ {a6,a7,a8} by FINSEQ_2:128
    .= {a1,a2,a3,a4,a5,a6,a7,a8} by ENUMSET1:26;
  end;

theorem Th21:
  for a1,a2,a3,a4,a5,a6,a7,a8,a9 being object holds
  rng(<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>) = {a1,a2,a3,a4,a5,a6,a7,a8,a9}
  proof
    let a1,a2,a3,a4,a5,a6,a7,a8,a9 be object;
    thus rng(<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>)
    = rng <*a1,a2,a3,a4,a5,a6,a7,a8*> \/ rng <*a9*> by FINSEQ_1:31
    .= {a1,a2,a3,a4,a5,a6,a7,a8} \/ rng <*a9*> by Th20
    .= {a1,a2,a3,a4,a5,a6,a7,a8} \/ {a9} by FINSEQ_1:38
    .= {a1,a2,a3,a4,a5,a6,a7,a8,a9} by ENUMSET1:84;
  end;

theorem Th22:
  Seg 9 = {1,2,3,4,5,6,7,8,9}
  proof
    thus Seg 9 = Seg 8 \/ {8+1} by FINSEQ_1:9
    .= {1,2,3,4,5,6,7,8,9} by FINSEQ_3:6,ENUMSET1:84;
  end;

theorem Th23:
  Seg 10 = {1,2,3,4,5,6,7,8,9,10}
  proof
    thus Seg 10 = Seg 9 \/ {9+1} by FINSEQ_1:9
    .= {1,2,3,4,5,6,7,8,9,10} by Th22,ENUMSET1:85;
  end;

theorem Th24:
  for a1,a2,a3,a4,a5,a6,a7,a8,a9 being object holds
  dom (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>) = Seg 9 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).1 = a1 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).2 = a2 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).3 = a3 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).4 = a4 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).5 = a5 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).6 = a6 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).7 = a7 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).8 = a8 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).9 = a9
  proof
    let a1,a2,a3,a4,a5,a6,a7,a8,a9 be object;
    thus dom (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>)
    = Seg (len <*a1,a2,a3,a4,a5,a6,a7,a8*> + len <*a9*>) by FINSEQ_1:def 7
    .= Seg (8+len <*a9*>) by Th19
    .= Seg (8+1) by FINSEQ_1:40 .= Seg 9;
A1: len <*a1,a2,a3,a4,a5,a6,a7,a8*> = 8 by Th19; then
    1 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).1
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.1 by FINSEQ_1:def 7 .= a1 by Th19;
    2 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).2
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.2 by FINSEQ_1:def 7 .= a2 by Th19;
    3 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).3
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.3 by FINSEQ_1:def 7 .= a3 by Th19;
    4 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).4
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.4 by FINSEQ_1:def 7 .= a4 by Th19;
    5 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).5
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.5 by FINSEQ_1:def 7 .= a5 by Th19;
    6 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).6
   = <*a1,a2,a3,a4,a5,a6,a7,a8*>.6 by FINSEQ_1:def 7 .= a6 by Th19;
    7 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).7
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.7 by FINSEQ_1:def 7 .= a7 by Th19;
    8 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).8
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.8 by FINSEQ_1:def 7 .= a8 by Th19;
    len <*a9*> = 1 by FINSEQ_1:40; then
    1 in dom <*a9*> by FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9*>).9
    = <*a9*>.1 by A1,FINSEQ_1:def 7 .= a9 by FINSEQ_1:40;
  end;

theorem Th25:
  for a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 being object holds
  dom (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>) = Seg 10 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).1 = a1 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).2 = a2 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).3 = a3 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).4 = a4 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).5 = a5 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).6 = a6 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).7 = a7 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).8 = a8 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).9 = a9 &
  (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).10 = a10
  proof
    let a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 be object;
    thus dom (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>)
    = Seg (len <*a1,a2,a3,a4,a5,a6,a7,a8*> + len <*a9,a10*>) by FINSEQ_1:def 7
    .= Seg (8+len <*a9,a10*>) by Th19
    .= Seg (8+2) by FINSEQ_1:44 .= Seg 10;
A1: len <*a1,a2,a3,a4,a5,a6,a7,a8*> = 8 by Th19; then
    1 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).1
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.1 by FINSEQ_1:def 7 .= a1 by Th19;
    2 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).2
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.2 by FINSEQ_1:def 7 .= a2 by Th19;
    3 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).3
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.3 by FINSEQ_1:def 7 .= a3 by Th19;
    4 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).4
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.4 by FINSEQ_1:def 7 .= a4 by Th19;
    5 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).5
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.5 by FINSEQ_1:def 7 .= a5 by Th19;
    6 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).6
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.6 by FINSEQ_1:def 7 .= a6 by Th19;
    7 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).7
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.7 by FINSEQ_1:def 7 .= a7 by Th19;
    8 in dom <*a1,a2,a3,a4,a5,a6,a7,a8*> by A1,FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).8
    = <*a1,a2,a3,a4,a5,a6,a7,a8*>.8 by FINSEQ_1:def 7 .= a8 by Th19;
    len <*a9,a10*> = 2 by FINSEQ_1:44; then
    1 in dom <*a9,a10*> & 9 = 8+1 by FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).9
    = <*a9,a10*>.1 by A1,FINSEQ_1:def 7 .= a9 by FINSEQ_1:44;
    len <*a9,a10*> = 2 by FINSEQ_1:44; then
    2 in dom <*a9,a10*> by FINSEQ_3:25;
    hence (<*a1,a2,a3,a4,a5,a6,a7,a8*>^<*a9,a10*>).10
    = <*a9,a10*>.2 by A1,FINSEQ_1:def 7 .= a10 by FINSEQ_1:44;
  end;

definition
  let I,J be set;
  let S be ManySortedSet of I;
  mode ManySortedMSSet of S,J -> ManySortedFunction of I means: Def6:
  for i,j being set st i in I holds dom(it.i) = S.i &
  (j in S.i implies it.i.j is ManySortedSet of J);
  existence
  proof
    set f = the ManySortedSet of J;
    deffunc F(object) = S.$1 --> f;
    consider X being ManySortedSet of I such that
A1: for x being object st x in I holds X.x = F(x) from PBOOLE:sch 4;
    X is Function-yielding
    proof
      let x be object; assume x in dom X; then
      x in I by PARTFUN1:def 2; then
      X.x = F(x) by A1;
      hence thesis;
    end; then
    reconsider X as ManySortedFunction of I;
    take X;
    let i,j be set; assume
A2: i in I; then
    X.i = F(i) by A1;
    hence dom(X.i) = S.i;
    assume j in S.i; then
    X.i = F(i) & F(i).j = f by A1,A2,FUNCOP_1:7;
    hence thesis;
  end;
end;

definition
  let I,J be set;
  let S1 be ManySortedSet of I;
  let S2 be ManySortedSet of J;
  mode ManySortedMSSet of S1,S2 -> ManySortedMSSet of S1,J means: Def7:
  for i,a being set st i in I & a in S1.i
  holds it.i.a is ManySortedSubset of S2;
  existence
  proof
    set f = the ManySortedSubset of S2;
    deffunc F(object) = S1.$1 --> f;
    consider X being ManySortedSet of I such that
A1: for x being object st x in I holds X.x = F(x) from PBOOLE:sch 4;
    X is Function-yielding
    proof
      let x be object; assume x in dom X; then
      x in I by PARTFUN1:def 2; then
      X.x = F(x) by A1;
      hence thesis;
    end; then
    reconsider X as ManySortedFunction of I;
    X is ManySortedMSSet of S1,J
    proof
      let i,j be set; assume
A2:   i in I; then
      X.i = F(i) by A1;
      hence dom(X.i) = S1.i;
      assume j in S1.i; then
      X.i = F(i) & F(i).j = f by A1,A2,FUNCOP_1:7;
      hence thesis;
    end; then
    reconsider X as ManySortedMSSet of S1,J;
    take X;
    let i,j be set; assume i in I & j in S1.i; then
    X.i = F(i) & F(i).j = f by A1,FUNCOP_1:7;
    hence thesis;
  end;
end;

registration
  let I be set;
  let X,Y be ManySortedSet of I;
  let f be ManySortedMSSet of X,Y;
  let x,y;
  cluster f.x.y -> Function-like Relation-like;
  coherence
  proof
    (x in dom f or x nin dom f) & dom f = I by PARTFUN1:def 2; then
    x in I & dom(f.x) = X.x & (y in X.x or y nin X.x) or f.x = {} & dom {} = {}
    by Def6,FUNCT_1:def 2;
    hence thesis by Def6,FUNCT_1:def 2;
  end;
end;

definition
  let S be ManySortedSign;
  let o,a be set;
  let r be Element of S;
  pred o is_of_type a,r means
  (the Arity of S).o = a & (the ResultSort of S).o = r;
end;

theorem Th26:
  for S being non void non empty ManySortedSign
  for o being OperSymbol of S
  for r being SortSymbol of S st o is_of_type {}, r
  for A being MSAlgebra over S
  st (the Sorts of A).r <> {}
  holds Den(In(o, the carrier' of S), A).{} is
        Element of (the Sorts of A).r
  proof
    let S be non void non empty ManySortedSign;
    let o be OperSymbol of S;
    let r be SortSymbol of S;
    assume
A1: (the Arity of S).o = {} & (the ResultSort of S).o = r;
    reconsider s = o as OperSymbol of S;
    let A be MSAlgebra over S;
    assume A3: (the Sorts of A).r <> {};
A4: <*>the carrier of S in (the carrier of S)* by FINSEQ_1:def 11;
    ((the Sorts of A)#*the Arity of S).o
    = (the Sorts of A)#.{} by A1,FUNCT_2:15
    .= product ((the Sorts of A)*{}) by A4,FINSEQ_2:def 5
    .= product {}; then
A5: {} in Args(s, A) by CARD_3:10,TARSKI:def 1;
    Result(s, A) = (the Sorts of A).the_result_sort_of s by FUNCT_2:15;
    hence Den(In(o, the carrier' of S), A).{} is
    Element of (the Sorts of A).r by A1,A3,A5,FUNCT_2:5;
  end;

theorem Th27:
  for S being non void non empty ManySortedSign
  for o,a being set
  for r being SortSymbol of S st o is_of_type <*a*>, r
  for A being MSAlgebra over S
  st (the Sorts of A).a <> {} & (the Sorts of A).r <> {}
  for x being Element of (the Sorts of A).a
  holds Den(In(o, the carrier' of S), A).<*x*> is
        Element of (the Sorts of A).r
  proof
    let S be non void non empty ManySortedSign;
    let o,a be set;
    let r be SortSymbol of S;
    assume
A1: (the Arity of S).o = <*a*> & (the ResultSort of S).o = r; then
A2: o in dom the Arity of S & dom the Arity of S c= the carrier' of S
    by FUNCT_1:def 2,RELAT_1:def 18; then
    reconsider s = o as OperSymbol of S;
    let A be MSAlgebra over S;
    assume A4: (the Sorts of A).a <> {};
    assume A5: (the Sorts of A).r <> {};
    let x be Element of (the Sorts of A).a;
A6: <*a*> = the_arity_of s by A1;
A7: dom the Sorts of A = the carrier of S by PARTFUN1:def 2;
    ((the Sorts of A)#*the Arity of S).o
    = (the Sorts of A)#.<*a*> by A1,A2,FUNCT_2:15
    .= product ((the Sorts of A)*<*a*>) by A6,FINSEQ_2:def 5
    .= product <*(the Sorts of A).a*> by A6,FUNCT_7:18,A7,FINSEQ_2:34; then
A8: <*x*> in Args(s, A) by A4,FINSEQ_3:123;
    Result(s, A) = (the Sorts of A).the_result_sort_of s by FUNCT_2:15;
    hence Den(In(o, the carrier' of S), A).<*x*> is
    Element of (the Sorts of A).r by A1,A5,A8,FUNCT_2:5;
  end;

theorem Th28:
  for S being non void non empty ManySortedSign
  for o,a,b being set
  for r being SortSymbol of S st o is_of_type <*a,b*>, r
  for A being MSAlgebra over S
  st (the Sorts of A).a <> {} & (the Sorts of A).b <> {} &
     (the Sorts of A).r <> {}
  for x being Element of (the Sorts of A).a
  for y being Element of (the Sorts of A).b
  holds Den(In(o, the carrier' of S), A).<*x,y*> is
        Element of (the Sorts of A).r
  proof
    let S be non void non empty ManySortedSign;
    let o,a,b be set;
    let r be SortSymbol of S;
    assume
A1: (the Arity of S).o = <*a,b*> & (the ResultSort of S).o = r; then
A2: o in dom the Arity of S & dom the Arity of S c= the carrier' of S
    by FUNCT_1:def 2,RELAT_1:def 18; then
    reconsider s = o as OperSymbol of S; 
    let A be MSAlgebra over S;
    assume A4: (the Sorts of A).a <> {};
    assume A5: (the Sorts of A).b <> {};
    assume A6: (the Sorts of A).r <> {};
    let x be Element of (the Sorts of A).a;
    let y be Element of (the Sorts of A).b;
A7: <*a,b*> = the_arity_of s by A1;
    dom the Sorts of A = the carrier of S by PARTFUN1:def 2; then
A8: the Sorts of A is Function of the carrier of S, rng the Sorts of A &
    rng the Sorts of A <> {} by FUNCT_2:2;
    ((the Sorts of A)#*the Arity of S).o
    = (the Sorts of A)#.<*a,b*> by A1,A2,FUNCT_2:15
    .= product ((the Sorts of A)*<*a,b*>) by A7,FINSEQ_2:def 5
    .= product <*(the Sorts of A).a, (the Sorts of A).b*>
    by A7,A8,FINSEQ_2:36; then
A9: <*x,y*> in Args(s, A) by A4,A5,FINSEQ_3:124;
    Result(s, A) = (the Sorts of A).the_result_sort_of s by FUNCT_2:15;
    hence Den(In(o, the carrier' of S), A).<*x,y*> is
    Element of (the Sorts of A).r by A1,A6,A9,FUNCT_2:5;
  end;

theorem Th29:
  for S being non void non empty ManySortedSign
  for o,a,b,c being set
  for r being SortSymbol of S st o is_of_type <*a,b,c*>, r
  for A being MSAlgebra over S
  st (the Sorts of A).a <> {} & (the Sorts of A).b <> {} &
     (the Sorts of A).c <> {} & (the Sorts of A).r <> {}
  for x being Element of (the Sorts of A).a
  for y being Element of (the Sorts of A).b
  for z being Element of (the Sorts of A).c
  holds Den(In(o, the carrier' of S), A).<*x,y,z*> is
        Element of (the Sorts of A).r
  proof
    let S be non void non empty ManySortedSign;
    let o,a,b,c be set;
    let r be SortSymbol of S;
    assume
A1: (the Arity of S).o = <*a,b,c*> & (the ResultSort of S).o = r; then
A2: o in dom the Arity of S & dom the Arity of S c= the carrier' of S
    by FUNCT_1:def 2,RELAT_1:def 18; then
    reconsider s = o as OperSymbol of S;
    let A be MSAlgebra over S;
    assume A4: (the Sorts of A).a <> {};
    assume A5: (the Sorts of A).b <> {};
    assume A6: (the Sorts of A).c <> {};
    assume A7: (the Sorts of A).r <> {};
    let x be Element of (the Sorts of A).a;
    let y be Element of (the Sorts of A).b;
    let z be Element of (the Sorts of A).c;
A8: <*a,b,c*> = the_arity_of s by A1;
    dom the Sorts of A = the carrier of S by PARTFUN1:def 2; then
A9: the Sorts of A is Function of the carrier of S, rng the Sorts of A &
    rng the Sorts of A <> {} by FUNCT_2:2;
    ((the Sorts of A)#*the Arity of S).o
    = (the Sorts of A)#.<*a,b,c*> by A1,A2,FUNCT_2:15
    .= product ((the Sorts of A)*<*a,b,c*>) by A8,FINSEQ_2:def 5
    .= product <*(the Sorts of A).a, (the Sorts of A).b, (the Sorts of A).c*>
    by A8,A9,FINSEQ_2:37; then
A10: <*x,y,z*> in Args(s, A) by A4,A5,A6,FINSEQ_3:125;
    Result(s, A) = (the Sorts of A).the_result_sort_of s by FUNCT_2:15;
    hence Den(In(o, the carrier' of S), A).<*x,y,z*> is
    Element of (the Sorts of A).r by A1,A7,A10,FUNCT_2:5;
  end;

theorem
  for S1,S2 being ManySortedSign
  st the ManySortedSign of S1 = the ManySortedSign of S2
  for o,a be set, r1 be Element of S1 for r2 being Element of S2 st r1 = r2
  holds o is_of_type a,r1 implies o is_of_type a,r2;

begin :: Free Variables

definition
  let S be non empty non void ManySortedSign;
  struct (MSAlgebra over S) VarMSAlgebra over S (#
  Sorts -> ManySortedSet of the carrier of S,
  Charact -> ManySortedFunction of (the Sorts)# * the Arity of S,
    the Sorts * the ResultSort of S,
  free-vars -> ManySortedMSSet of the Sorts, the Sorts
  #);
end;

registration
  let S be non empty non void ManySortedSign;
  let U be non-empty ManySortedSet of the carrier of S;
  let C be ManySortedFunction of U# * the Arity of S,
    U * the ResultSort of S;
  let v be ManySortedMSSet of U,U;
  cluster VarMSAlgebra(#U, C, v#) -> non-empty;
  coherence;
end;

registration
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster (X,S)-terms for strict VarMSAlgebra over S;
  existence
  proof
    set v = the ManySortedMSSet of the Sorts of Free(S,X),
    the Sorts of Free(S,X);
    take A=VarMSAlgebra(#the Sorts of Free(S,X), the Charact of Free(S,X), v#);
    thus the Sorts of A is ManySortedSubset of the Sorts of Free(S,X)
    proof
      thus the Sorts of A c= the Sorts of Free(S,X);
    end;
  end;
end;

registration
  let S be non empty non void ManySortedSign;
  cluster non-empty disjoint_valued for VarMSAlgebra over S;
  existence
  proof
    set A = the non-empty disjoint_valued MSAlgebra over S;
    set v = the ManySortedMSSet of the Sorts of A, the Sorts of A;
    take V = VarMSAlgebra(#the Sorts of A,the Charact of A,v#);
    thus the Sorts of V is non-empty;
    thus the Sorts of V is disjoint_valued;
  end;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster all_vars_including -> non-empty for (X,S)-terms VarMSAlgebra over S;
  coherence;
end;

definition
  let S be non empty non void ManySortedSign;
  let A be non-empty VarMSAlgebra over S;
  let a be SortSymbol of S;
  let t be Element of A,a;
  func vf t -> ManySortedSubset of the Sorts of A equals
  (the free-vars of A).a.t;
  coherence by Def7;
end;

definition
  let S be non empty non void ManySortedSign;
  let A be non-empty VarMSAlgebra over S;
  attr A is vf-correct means
  for o being OperSymbol of S
  for p being FinSequence st p in Args(o,A)
  for b being Element of A, the_result_sort_of o st b = Den(o,A).p
  for s being SortSymbol of S holds (vf b).s c= union {(vf a).s where s0 is
  SortSymbol of S, a is Element of A,s0: ex i being Nat st
  i in dom the_arity_of o & s0 = (the_arity_of o).i & a = p.i};
end;

theorem Th31:
  for S being non empty non void ManySortedSign
  for A,B being MSAlgebra over S st the MSAlgebra of A = the MSAlgebra of B
  for G being MSSubset of A
  for H being MSSubset of B st G = H
  holds GenMSAlg G = GenMSAlg H
  proof
    let S be non empty non void ManySortedSign;
    let A,B be MSAlgebra over S such that
A1: the MSAlgebra of A = the MSAlgebra of B;
    let G be MSSubset of A;
    let H be MSSubset of B such that
A2: G = H;
A3: G is MSSubset of GenMSAlg G & H is MSSubset of GenMSAlg H
    by MSUALG_2:def 17;
    GenMSAlg G is MSSubAlgebra of B & GenMSAlg H is MSSubAlgebra of A
    by A1,MSAFREE4:28;
    then GenMSAlg G is MSSubAlgebra of GenMSAlg H &
    GenMSAlg H is MSSubAlgebra of GenMSAlg G by A2,A3,MSUALG_2:def 17;
    hence GenMSAlg G = GenMSAlg H by MSUALG_2:7;
  end;

theorem Th32:
  for S being non empty non void ManySortedSign
  for A,B being MSAlgebra over S st the MSAlgebra of A = the MSAlgebra of B
  for G being GeneratorSet of A holds G is GeneratorSet of B
  proof
    let S be non empty non void ManySortedSign;
    let A,B be MSAlgebra over S such that
A1: the MSAlgebra of A = the MSAlgebra of B;
    let G be GeneratorSet of A;
    reconsider H = G as MSSubset of B by A1;
    GenMSAlg H = GenMSAlg G by A1,Th31;
    hence G is GeneratorSet of B by A1,MSAFREE:def 4;
  end;

theorem Th33:
  for S being non empty non void ManySortedSign
  for A,B being non-empty MSAlgebra over S
  st the MSAlgebra of A = the MSAlgebra of B
  for G being GeneratorSet of A
  for H being GeneratorSet of B st G = H
  holds G is free implies H is free
  proof
    let S be non empty non void ManySortedSign;
    let A,B be non-empty MSAlgebra over S such that
A1: the MSAlgebra of A = the MSAlgebra of B;
    let G be GeneratorSet of A;
    let H be GeneratorSet of B; assume
A2: G = H;
    assume
A3: for U1 be non-empty MSAlgebra over S
    for f be ManySortedFunction of G,the Sorts of U1
    ex h be ManySortedFunction of A,U1 st
    h is_homomorphism A,U1 & h || G = f;
    let U1 be non-empty MSAlgebra over S;
    let f be ManySortedFunction of H,the Sorts of U1;
    consider h being ManySortedFunction of A,U1 such that
A4: h is_homomorphism A,U1 & h || G = f by A2,A3;
    reconsider g = h as ManySortedFunction of B,U1 by A1;
    take g;
    the MSAlgebra of U1 = the MSAlgebra of U1;
    hence g is_homomorphism B,U1 by A1,A4,MSAFREE4:30;
    thus g || H = f by A1,A2,A4;
  end;

registration
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster all_vars_including inheriting_operations free_in_itself
  for (X,S)-terms strict VarMSAlgebra over S;
  existence
  proof
    set v = the ManySortedMSSet of the Sorts of Free(S,X),
    the Sorts of Free(S,X);
    set A=VarMSAlgebra(#the Sorts of Free(S,X), the Charact of Free(S,X), v#);
    A is (X,S)-terms
    proof
      thus the Sorts of A c= the Sorts of Free(S,X);
    end;
    then reconsider A as (X,S)-terms strict VarMSAlgebra over S;
    take A;
A1: the MSAlgebra of A = FreeMSA X by MSAFREE3:31;
    thus FreeGen X is ManySortedSubset of the Sorts of A &
    for o being OperSymbol of S, p being FinSequence holds
    (p in Args(o, Free(S,X)) &
    Den(o,Free(S,X)).p in (the Sorts of A).the_result_sort_of o implies
    p in Args(o,A) & Den(o,A).p = Den(o,Free(S,X)).p) by MSAFREE3:31;
    reconsider B = A as non-empty VarMSAlgebra over S;
    let f be ManySortedFunction of FreeGen X, the Sorts of A;
    let G be MSSubset of A; assume
A2: G = FreeGen X; then
    reconsider F = G as non-empty GeneratorSet of the MSAlgebra of B
    by MSAFREE3:31;
    reconsider H = F as non-empty GeneratorSet of B by Th32;
    H is free by Th33,A1,A2,MSAFREE:16;
    hence thesis by A2;
  end;
end;

definition
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let A be non-empty (X,S)-terms VarMSAlgebra over S;
  attr A is vf-free means: Def11:
  for s,r being SortSymbol of S
  for t being Element of A,s holds (vf t).r =
  {t|p where p is Element of dom t: ((t|p).{})`2 = r};
end;

scheme Scheme{I() -> non empty set,
  X,Y() -> non-empty ManySortedSet of I(),
    F(object,object,object) -> set}:
  ex f being ManySortedMSSet of X(),Y() st
  for s,r being Element of I() for t being Element of X().s
  holds f.s.t.r = F(s,r,t)
  provided
A1: for s,r being Element of I() for t being Element of X().s holds
    F(s,r,t) is Subset of Y().r
  proof
    defpred P[object,object] means
    ex f being ManySortedFunction of X().$1 st $2 = f &
    for r being Element of I() for t being Element of X().$1 holds
    dom (f.t) = I() & f.t.r = F($1,r,t);
A2: for s being object st s in I() ex y being object st P[s,y]
    proof
      let s be object; assume
      s in I(); then reconsider s0 = s as Element of I();
      defpred Q[object,object] means
ex g being Function st $2 = g & dom g = I() &
      for r being Element of I() holds g.r = F(s,r,$1);
A3:   for t being object st t in X().s ex y being object st Q[t,y]
      proof
        let t be object; assume
        t in X().s;
        deffunc G(set) = F(s,$1,t);
        consider g being Function such that
A4:     dom g = I() & for r being Element of I() holds g.r = G(r)
        from FUNCT_1:sch 4;
        take g,g; thus thesis by A4;
      end;
      consider f being Function such that
A5:   dom f = X().s & for t being object st t in X().s holds Q[t,f.t]
      from CLASSES1:sch 1(A3);
      reconsider f as ManySortedSet of X().s
      by A5,RELAT_1:def 18,PARTFUN1:def 2;
      f is Function-yielding
      proof
        let x be object; assume x in dom f; then
        Q[x,f.x] by A5;
        hence thesis;
      end; then
      reconsider f as ManySortedFunction of X().s;
      take f,f; thus f = f;
      let r be Element of I();
      let t be Element of X().s;
      t in X().s0; then
      Q[t,f.t] by A5;
      hence dom (f.t) = I() & f.t.r = F(s,r,t);
    end;
    consider F being Function such that
A6: dom F = I() & for x being object st x in I() holds P[x,F.x]
from CLASSES1:sch 1(A2);
    reconsider F as ManySortedSet of I() by A6,RELAT_1:def 18,PARTFUN1:def 2;
    F is Function-yielding
    proof
      let x be object; assume x in dom F; then
      P[x,F.x] by A6;
      hence thesis;
    end; then
    reconsider F as ManySortedFunction of I();
    F is ManySortedMSSet of X(),I()
    proof
      let i,j being set; assume i in I(); then
      consider f being ManySortedFunction of X().i such that
A7:   F.i = f &
      for r being Element of I() for t being Element of X().i holds
      dom (f.t) = I() & f.t.r = F(i,r,t) by A6;
      thus dom(F.i) = X().i by A7,PARTFUN1:def 2;
      assume j in X().i; then
      dom(f.j) = I() by A7;
      hence F.i.j is ManySortedSet of I() by A7,RELAT_1:def 18,PARTFUN1:def 2;
    end; then
    reconsider F as ManySortedMSSet of X(),I();
    F is ManySortedMSSet of X(),Y()
    proof
      let i,a be set; assume
A8:   i in I() & a in X().i; then
      reconsider g = F.i.a as ManySortedSet of I() by Def6;
      consider f being ManySortedFunction of X().i such that
A9:   F.i = f &
      for r being Element of I() for t being Element of X().i holds
      dom (f.t) = I() & f.t.r = F(i,r,t) by A6,A8;
      g is ManySortedSubset of Y()
      proof
        let x be object; assume x in I(); then
        g.x = F(i,x,a) & F(i,x,a) is Subset of Y().x by A1,A8,A9;
        hence thesis;
      end;
      hence thesis;
    end; then
    reconsider F as ManySortedMSSet of X(),Y();
    take F;
    let s,r be Element of I();
    let t be Element of X().s;
    P[s,F.s] by A6;
    hence F.s.t.r = F(s,r,t);
  end;

theorem Th34:
  for S being non empty non void ManySortedSign
  for X being non-empty ManySortedSet of the carrier of S
  for A being all_vars_including inheriting_operations free_in_itself
  (X,S)-terms MSAlgebra over S
  ex VF being ManySortedMSSet of the Sorts of A,the Sorts of A,
  B being all_vars_including inheriting_operations free_in_itself (X,S)-terms
  VarMSAlgebra over S
  st B = VarMSAlgebra(#the Sorts of A, the Charact of A, VF#) &
  B is vf-free
  proof
    let S be non empty non void ManySortedSign;
    let X be non-empty ManySortedSet of the carrier of S;
    let A be all_vars_including inheriting_operations free_in_itself
    (X,S)-terms (X,S)-terms MSAlgebra over S;
    deffunc F((Element of S),(Element of S),Element of A,$1) =
    {$3|p where p is Element of dom $3: (($3|p).{})`2 = $2};
A1: for s,r being SortSymbol of S for t being Element of A,s holds
    F(s,r,t) is Subset of (the Sorts of A).r
    proof
      let s,r be SortSymbol of S;
      let t be Element of (the Sorts of A).s;
      F(s,r,t) c= (the Sorts of A).r
      proof
        let x be object; assume x in F(s,r,t); then
        consider p being Element of dom t such that
A2:     x = t|p & ((t|p).{})`2 = r;
        reconsider tp = t|p as Element of A by MSAFREE4:44;
        reconsider t1 = tp as Term of S,X by MSAFREE4:42;
        per cases by MSATERM:2;
        suppose
          ex s being SortSymbol of S, v being Element of X.s st t1.{} = [v,s];
          then consider s1 being SortSymbol of S, v being Element of X.s1
          such that
A3:       tp.{} = [v,s1];
A4:       s1 = r by A2,A3; then
          t1 = root-tree [v,r] by A3,MSATERM:5; then
          the_sort_of t1 = r by A4,MSATERM:14; then
          t1 in FreeSort(X,r) by MSATERM:def 5; then
          tp in (the Sorts of FreeMSA X).r by MSAFREE:def 11; then
          tp in (the Sorts of Free(S,X)).r by MSAFREE3:31;
          hence thesis by A2,MSAFREE4:43;
        end;
        suppose tp.{} in [:the carrier' of S,{the carrier of S}:]; then
          (tp.{})`2 in {the carrier of S} by MCART_1:10; then
          r = the carrier of S & r in the carrier of S by A2,TARSKI:def 1;
          hence thesis;
        end;
      end;
      hence F(s,r,t) is Subset of (the Sorts of A).r;
    end;
    consider v being ManySortedMSSet of the Sorts of A,the Sorts of A such that
A5: for x,z being Element of the carrier of S
    for y being Element of (the Sorts of A).x holds v.x.y.z = F(x,z,y)
    from Scheme(A1);
    set B = VarMSAlgebra(#the Sorts of A, the Charact of A, v#);
    take v;
 B is (X,S)-terms
    proof
      thus the Sorts of B is ManySortedSubset of the Sorts of Free(S,X)
      by MSAFREE4:def 6;
    end;
    then reconsider B as (X,S)-terms strict VarMSAlgebra over S;
    B is all_vars_including inheriting_operations free_in_itself
    proof
      thus FreeGen X is ManySortedSubset of the Sorts of B by MSAFREE4:def 7;
      hereby
        let o be OperSymbol of S, p be FinSequence; assume
        p in Args(o, Free(S,X)) &
        Den(o,Free(S,X)).p in (the Sorts of B).the_result_sort_of o; then
        p in Args(o,A) & Den(o,A).p = Den(o,Free(S,X)).p by MSAFREE4:def 8;
        hence p in Args(o,B) & Den(o,B).p = Den(o,Free(S,X)).p;
      end;
      let f be ManySortedFunction of FreeGen X, the Sorts of B;
      let G be ManySortedSubset of the Sorts of B such that
A7:   G = FreeGen X;
      reconsider H = G as MSSubset of A;
      consider h being ManySortedFunction of A,A such that
A8:   h is_homomorphism A,A & f = h || H by A7,MSAFREE4:def 9;
      reconsider g = h as ManySortedFunction of B,B;
      take g;
      the MSAlgebra of B = the MSAlgebra of A;
      hence g is_homomorphism B,B by A8,MSAFREE4:30;
      thus thesis by A8;
    end;
    then reconsider B as all_vars_including inheriting_operations
    free_in_itself (X,S)-terms strict VarMSAlgebra over S;
    B is vf-free
    by A5;
    hence thesis;
  end;

registration
  let S be non empty non void ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster strict vf-free for all_vars_including inheriting_operations
  free_in_itself (X,S)-terms VarMSAlgebra over S;
  existence
  proof
    set A = the all_vars_including inheriting_operations free_in_itself
    (X,S)-terms MSAlgebra over S;
    consider VF being ManySortedMSSet of the Sorts of A,the Sorts of A,
    B being all_vars_including inheriting_operations free_in_itself
    (X,S)-terms VarMSAlgebra over S such that
A1: B = VarMSAlgebra(#the Sorts of A, the Charact of A, VF#) &
    B is vf-free by Th34;
    take B; thus thesis by A1;
  end;
end;

theorem Th35:
  for S being non empty non void ManySortedSign
  for X being non-empty ManySortedSet of the carrier of S
  for A being vf-free all_vars_including inheriting_operations free_in_itself
  (X,S)-terms VarMSAlgebra over S
  for s being SortSymbol of S
  for t being Element of A,s holds vf t is ManySortedSubset of FreeGen X
  proof
    let S be non empty non void ManySortedSign;
    let X be non-empty ManySortedSet of the carrier of S;
    let A be vf-free all_vars_including inheriting_operations free_in_itself
    (X,S)-terms VarMSAlgebra over S;
    let s be SortSymbol of S;
    let t be Element of A,s;
    let x be object; assume x in the carrier of S; then
    reconsider r = x as SortSymbol of S;
    let y be object; assume y in (vf t).x; then
    y in {t|p where p is Element of dom t: ((t|p).{})`2 = r} by Def11; then
    consider p being Element of dom t such that
A1: y = t|p & ((t|p).{})`2 = r;
    t is Element of (the Sorts of A).s; then
    reconsider tp = t|p as Element of A by MSAFREE4:44;
A2: tp is Term of S,X by MSAFREE4:42;
    per cases by A2,MSATERM:2;
    suppose tp.{} in [:the carrier' of S, {the carrier of S}:]; then
      r in {the carrier of S} by A1,MCART_1:10; then
      r = the carrier of S by TARSKI:def 1; then
      r in r;
      hence thesis;
    end;
    suppose
      ex s being SortSymbol of S, v being Element of X.s st tp.{} = [v,s]; then
      consider s1 being SortSymbol of S, v being Element of X.s1 such that
A3:   tp.{} = [v,s1];
      tp = root-tree [v,s1] by A2,A3,MSATERM:5; then
      tp in FreeGen(s1, X) by MSAFREE:def 15; then
      tp in (FreeGen X).s1 by MSAFREE:def 16;
      hence y in (FreeGen X).x by A1,A3;
    end;
  end;

theorem
  for S being non empty non void ManySortedSign
  for X being non-empty ManySortedSet of the carrier of S
  for A being vf-free all_vars_including (X,S)-terms VarMSAlgebra over S
  for s being SortSymbol of S
  for x being Element of A,s st x in (FreeGen X).s holds
  vf x = s-singleton(x)
  proof
    let S be non empty non void ManySortedSign;
    let X be non-empty ManySortedSet of the carrier of S;
    let A be vf-free all_vars_including (X,S)-terms VarMSAlgebra over S;
    let s be SortSymbol of S;
    let x be Element of A,s;
    assume x in (FreeGen X).s; then
    x in FreeGen(s,X) by MSAFREE:def 16; then
    consider a being set such that
A1: a in X.s & x = root-tree [a,s] by MSAFREE:def 15;
A2: dom root-tree [a,s] = {{}} & (root-tree [a,s]).{} = [a,s]
    by TREES_4:3,TREES_1:29;
A3: [a,s]`2 = s;
    now
      let y be object; assume y in the carrier of S; then
      reconsider r = y as SortSymbol of S;
A4:   {x|p where p is Element of dom x: ((x|p).{})`2 = r} = (s-singletonx).y
      proof
        thus
        {x|p where p is Element of dom x: ((x|p).{})`2 = r} c= (s-singletonx).y
        proof
          let z be object; assume
          z in {x|p where p is Element of dom x: ((x|p).{})`2 = r}; then
          consider p being Element of dom x such that
A5:       z = x|p & ((x|p).{})`2 = r;
          p = {} by A1,A2; then
A6:       z = x by A5,TREES_9:1; then
          (s-singletonx).r = {x} by A1,A2,A5,Th6;
          hence z in (s-singletonx).y by A6,TARSKI:def 1;
        end;
        let z be object;
        reconsider p = {} as Element of dom x by A1,A2,TARSKI:def 1;
        assume
A7:     z in (s-singletonx).y; then
A8:     r = s by Th6; then
        z in {x} by A7,Th6; then
A9:     z = x by TARSKI:def 1; then
        z = x|p by TREES_9:1;
        hence thesis by A1,A2,A3,A9,A8;
      end;
      thus (vf x).y = (s-singletonx).y by A4,Def11;
    end;
    hence vf x = s-singleton(x);
  end;

begin :: Algebra with undefined values

definition
  let I be set;
  let S be ManySortedSet of I;
  mode ManySortedElement of S -> ManySortedSet of I means
  for i being set st i in I holds it.i is Element of S.i;
  existence
  proof
    deffunc F(object) = the Element of S.$1;
    consider f being ManySortedSet of I such that
A1: for x being object st x in I holds f.x = F(x) from PBOOLE:sch 4;
    take f; let x; assume x in I; then
    f.x = F(x) by A1;
    hence thesis;
  end;
end;

definition
  let S be non empty non void ManySortedSign;
  struct (MSAlgebra over S) UndefMSAlgebra over S (#
  Sorts -> ManySortedSet of the carrier of S,
  Charact -> ManySortedFunction of (the Sorts)# * the Arity of S,
    the Sorts * the ResultSort of S,
  undefined-map -> ManySortedElement of the Sorts
  #);
end;

definition
  let S be non empty non void ManySortedSign;
  let A be UndefMSAlgebra over S;
  let s be SortSymbol of S;
  let a be Element of A,s;
  attr a is undefined means
  a = (the undefined-map of A).s;
end;

definition
  let S be non empty non void ManySortedSign;
  let A be UndefMSAlgebra over S;
  attr A is undef-consequent means
  for o being OperSymbol of S
  for p being FinSequence st p in Args(o, A) &
  ex i being Nat, s being SortSymbol of S,a being Element of A,s st
  i in dom the_arity_of o & s = (the_arity_of o).i & a = p.i & a is undefined
  for b being Element of A, the_result_sort_of o
  st b = Den(o,A).p holds b is undefined;
end;

definition
  let S be non empty non void ManySortedSign;
  let A be MSAlgebra over S;
  let B be UndefMSAlgebra over S;
  attr B is A-undef means
  B is undef-consequent &
  the undefined-map of B = the Sorts of A &
  (for s being SortSymbol of S holds
  (the Sorts of B).s = succ ((the Sorts of A).s)) &
  for o being OperSymbol of S, a being Element of Args(o,A)
  st Args(o,A) <> {} holds Den(o,B).a <> Den(o,A).a implies
  Den(o,B).a = (the undefined-map of B).the_result_sort_of o;
end;

registration
  let S be non empty ManySortedSign;
  let A be MSAlgebra over S;
  cluster the Charact of A -> Function-yielding;
  coherence;
end;

registration
  let S be non empty non void ManySortedSign;
  let A be non-empty MSAlgebra over S;
  cluster A-undef -> undef-consequent for UndefMSAlgebra over S;
  coherence;
  cluster A-undef non-empty for strict UndefMSAlgebra over S;
  existence
  proof
    deffunc F(object) = succ ((the Sorts of A).$1);
    consider X being ManySortedSet of the carrier of S such that
A1: for x being object st x in the carrier of S holds X.x = F(x)
from PBOOLE:sch 4;
    X is non-empty
    proof
      let x be object; assume x in the carrier of S; then
      X.x = F(x) by A1;
      hence thesis;
    end; then
    reconsider X as non-empty ManySortedSet of the carrier of S;
    deffunc G(object) = (((X#*the Arity of S).$1)-->
    ((the Sorts of A)*the ResultSort of S).$1)
    +*((the Charact of A).$1);
    consider ch being ManySortedSet of the carrier' of S such that
A2: for x being object st x in the carrier' of S holds ch.x = G(x)
from PBOOLE:sch 4;
    ch is Function-yielding
    proof let x be object; assume x in dom ch; then
      x in the carrier' of S by PARTFUN1:def 2; then
      ch.x = G(x) by A2;
      hence thesis;
    end; then
    reconsider ch as ManySortedFunction of the carrier' of S;
    the Sorts of A is ManySortedSubset of X
    proof
      let x be object; assume x in the carrier of S; then
      X.x = F(x) by A1 .= ((the Sorts of A).x)\/{(the Sorts of A).x};
      hence thesis by XBOOLE_1:7;
    end; then
    reconsider Y = the Sorts of A as ManySortedSubset of X;
    X is ManySortedSubset of X
    proof
      let x be object; thus thesis;
    end; then
    reconsider X1 = X as ManySortedSubset of X;
    ch is ManySortedFunction of X#*the Arity of S, X*the ResultSort of S
    proof
      let x be object; assume x in the carrier' of S; then
      reconsider x as OperSymbol of S;
      Y# c= X# & the_arity_of x in (the carrier of S)* &
      dom the Arity of S = the carrier' of S &
      the Charact of A is ManySortedFunction of Y#*the Arity of S,
      Y*the ResultSort of S
      by Th2,FUNCT_2:def 1, PBOOLE:def 18; then
      Y#.the_arity_of x c= X#.the_arity_of x &
      (Y#*the Arity of S).x = Y#.the_arity_of x &
      (X1#*the Arity of S).x = X#.the_arity_of x &
      (the Charact of A).x is Function of (Y#*the Arity of S).x,
      (Y*the ResultSort of S).x by FUNCT_1:13; then
      (X#*the Arity of S).x \/ (Y#*the Arity of S).x = (X#*the Arity of S).x &
      dom((X#*the Arity of S).x-->((the Sorts of A)*the ResultSort of S).x) =
      (X#*the Arity of S).x &
      dom((the Charact of A).x) = (Y#*the Arity of S).x & ch.x = G(x)
      by A2,XBOOLE_1:12,FUNCT_2:def 1; then
A3:   dom(ch.x) = (X#*the Arity of S).x by FUNCT_4:def 1;
      dom the ResultSort of S = the carrier' of S by FUNCT_2:def 1; then
A4:   (Y*the ResultSort of S).x = Y.the_result_sort_of x &
      (X*the ResultSort of S).x = X.the_result_sort_of x by FUNCT_1:13;
      then
A5:   (Y*the ResultSort of S).x c= (X*the ResultSort of S).x
      by PBOOLE:def 18,PBOOLE:def 2;
      X.the_result_sort_of x = succ(Y.the_result_sort_of x) by A1; then
      Y.the_result_sort_of x in X.the_result_sort_of x by ORDINAL1:8; then
      {Y.the_result_sort_of x} c= X.the_result_sort_of x by ZFMISC_1:31; then
A6:   rng ((X#*the Arity of S).x --> ((the Sorts of A)*the ResultSort of S).x)
      c= X.the_result_sort_of x by A4;
      rng((the Charact of A).x) c= X.the_result_sort_of x
      by A5,A4,RELAT_1:def 19; then
A7:   rng ((X#*the Arity of S).x --> ((the Sorts of A)*the ResultSort of S).x)
      \/rng((the Charact of A).x) c= X.the_result_sort_of x
      by A6,XBOOLE_1:8;
      rng G(x) c= rng ((X#*the Arity of S).x --> (Y*the ResultSort of S).x)
      \/rng((the Charact of A).x) by FUNCT_4:17; then
      rng G(x) c= (X*the ResultSort of S).x & ch.x = G(x) by A2,A4,A7;
      hence thesis by A3,FUNCT_2:2;
    end; then
    reconsider ch as ManySortedFunction of X#*the Arity of S,
    X*the ResultSort of S;
    the Sorts of A is ManySortedElement of X
    proof
      let x; assume x in the carrier of S; then
      X.x = F(x) by A1;
      hence thesis by ORDINAL1:8;
    end; then
    reconsider u = the Sorts of A as ManySortedElement of X;
    take B = UndefMSAlgebra(#X,ch,u#);
    hereby
      let o be OperSymbol of S;
      let p be FinSequence such that
A8:   p in Args(o, B);
      given i being Nat, s being SortSymbol of S, a being Element of B,s
      such that
A9:   i in dom the_arity_of o & s = (the_arity_of o).i & a = p.i &
      a is undefined;
A10:   now
        assume
A11:     p in Args(o, A);
A12:     dom (Y*the_arity_of o) = dom the_arity_of o by PARTFUN1:def 2;
        dom the Arity of S = the carrier' of S by FUNCT_2:def 1; then
        Args(o,A) = Y#.the_arity_of o by FUNCT_1:13
        .= product (Y*the_arity_of o) by FINSEQ_2:def 5; then
        p.i in (Y*the_arity_of o).i by A9,A11,A12,CARD_3:9; then
        a in Y.s & u.s = a by A9,FUNCT_1:13;
        hence contradiction;
      end;
      let b be Element of B, the_result_sort_of o;
      assume
A13:   b = Den(o,B).p;
A14:   dom Den(o,A) = Args(o,A) by FUNCT_2:def 1;
A15:   dom the ResultSort of S = the carrier' of S by FUNCT_2:def 1;
      b = G(o).p by A2,A13
      .= (Args(o,B)-->(Y*the ResultSort of S).o).p by A14,A10,FUNCT_4:11
      .= (Y*the ResultSort of S).o by A8,FUNCOP_1:7
      .= u.the_result_sort_of o by A15,FUNCT_1:13;
      hence b is undefined;
    end;
    thus the undefined-map of B = the Sorts of A;
    thus for s being SortSymbol of S holds
    (the Sorts of B).s = succ ((the Sorts of A).s) by A1;
    hereby let o be OperSymbol of S;
      let a be Element of Args(o,A);
      assume Args(o,A) <> {};
      assume
A16:   Den(o,B).a <> Den(o,A).a;
A17:   dom Den(o,A) = Args(o,A) by FUNCT_2:def 1;
      Den(o,B).a = ((((X#*the Arity of S).o)-->
      ((the Sorts of A)*the ResultSort of S).o)+*((the Charact of A).o)).a
      by A2
      .= Den(o,A).a by A17,FUNCT_4:13;
      hence Den(o,B).a = (the undefined-map of B).the_result_sort_of o by A16;
    end;
    thus the Sorts of B is non-empty;
    thus thesis;
  end;
end;

begin :: Program algebra

definition
  let J be non empty non void ManySortedSign;
  let T be MSAlgebra over J;
  let X be GeneratorSet of T;
  struct (UAStr) ProgramAlgStr over J,T,X(#
  carrier -> set,
  charact -> PFuncFinSequence of the carrier,
  assignments -> Function of Union [|X, the Sorts of T|], the carrier
  #);
end;

definition
  let J be non empty non void ManySortedSign;
  let T be MSAlgebra over J;
  let X be GeneratorSet of T;
  let A be ProgramAlgStr over J,T,X;
  attr A is disjoint_valued means
  the Sorts of T is disjoint_valued &
  the assignments of A is one-to-one;
end;

registration
  let J be non empty non void ManySortedSign;
  let T be MSAlgebra over J;
  let X be GeneratorSet of T;
  cluster partial quasi_total non-empty for strict ProgramAlgStr over J,T,X;
  existence
  proof
    set A = the non empty set;
    set char = the quasi_total homogeneous
    non empty non-empty PFuncFinSequence of A;
    set assign = the Function of Union [|X, the Sorts of T|], A;
    take P = ProgramAlgStr(#A, char, assign#);
    thus the charact of P is homogeneous quasi_total;
    thus the charact of P <> {};
    thus thesis;
  end;
end;

registration
  let J be non empty non void ManySortedSign;
  let T be MSAlgebra over J;
  let X be GeneratorSet of T;
  cluster with_empty-instruction with_catenation with_if-instruction
  with_while-instruction
  for partial quasi_total non-empty non empty strict ProgramAlgStr over J,T,X;
  existence
  proof
    set U = the IfWhileAlgebra;
    set I = the Function of Union [|X, the Sorts of T|], the carrier of U;
    set A = ProgramAlgStr(#the carrier of U, the charact of U, I#);
    A is partial quasi_total non-empty; then
    reconsider A as partial quasi_total non-empty strict
    ProgramAlgStr over J,T,X;
    take A;
    thus 1 in dom the charact of A &
    (the charact of A).1 is 0-ary non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A
    by AOFA_000:def 10;
    thus 2 in dom the charact of A &
    (the charact of A).2 is 2-ary non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A
    by AOFA_000:def 11;
    thus 3 in dom the charact of A &
    (the charact of A).3 is 3-ary non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A
    by AOFA_000:def 12;
    thus 4 in dom the charact of A &
    (the charact of A).4 is 2-ary non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A
    by AOFA_000:def 13;
    thus thesis;
  end;
end;

theorem
  for U1,U2 be preIfWhileAlgebra st the UAStr of U1 = the UAStr of U2
  holds EmptyIns U1 = EmptyIns U2 &
  for I1,J1 being Element of U1
  for I2,J2 being Element of U2 st I1 = I2 & J1 = J2
  holds I1\;J1 = I2\;J2 & while(I1,J1) = while(I2,J2) &
  for C1 being Element of U1
  for C2 being Element of U2 st C1 = C2
  holds if-then-else(C1,I1,J1) = if-then-else(C2,I2,J2);

theorem Th38:
  for U1,U2 be preIfWhileAlgebra st the UAStr of U1 = the UAStr of U2
  holds ElementaryInstructions U1 = ElementaryInstructions U2
  proof
    let U1,U2 be preIfWhileAlgebra;
    assume A1: the UAStr of U1 = the UAStr of U2;
    set Y1 = {I1 \; I2 where I1,I2 is Algorithm of U1: I1 <> I1\;I2 &
    I2 <> I1\;I2};
    set Y2 = {I1 \; I2 where I1,I2 is Algorithm of U2: I1 <> I1\;I2 &
    I2 <> I1\;I2};
A2: Y1 = Y2
    proof
      thus Y1 c= Y2
      proof
        let x be object; assume x in Y1; then
        consider I1,I2 being Algorithm of U1 such that
A3:     x = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
        reconsider I1,I2 as Algorithm of U2 by A1;
        x = I1\;I2 by A1,A3;
        hence thesis by A3;
      end;
      let x be object; assume x in Y2; then
      consider I1,I2 being Algorithm of U2 such that
A4:   x = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
      reconsider I1,I2 as Algorithm of U1 by A1;
      x = I1\;I2 by A1,A4;
      hence thesis by A4;
    end;
    thus ElementaryInstructions U1 = ElementaryInstructions U2 by A2,A1;
  end;

theorem Th39:
  for U1,U2 being Universal_Algebra
  for S1 being Subset of U1, S2 being Subset of U2 st S1 = S2
  for o1 being operation of U1, o2 being operation of U2 st o1 = o2
  holds S1 is_closed_on o1 implies S2 is_closed_on o2
  proof
    let U1,U2 be Universal_Algebra;
    let S1 be Subset of U1;
    let S2 be Subset of U2;
    assume A1: S1 = S2;
    let o1 be operation of U1;
    let o2 be operation of U2;
    assume A2: o1 = o2;
    assume
A3: for s being FinSequence of S1 st len s = arity o1 holds o1.s in S1;
    let s be FinSequence of S2;
    reconsider s1 = s as FinSequence of S1 by A1;
    assume len s = arity o2;
    hence thesis by A1,A2,A3;
  end;

theorem Th40:
  for U1,U2 being Universal_Algebra st the UAStr of U1 = the UAStr of U2
  for S1 being Subset of U1, S2 being Subset of U2 st S1 = S2
  holds S1 is opers_closed implies S2 is opers_closed
  proof
    let U1,U2 be Universal_Algebra;
    assume A1: the UAStr of U1 = the UAStr of U2;
    let S1 be Subset of U1;
    let S2 be Subset of U2;
    assume A2: S1 = S2;
    assume
A3: for o be operation of U1 holds S1 is_closed_on o;
    let o be operation of U2;
    reconsider o1 = o as operation of U1 by A1;
    thus thesis by A1,A2,A3,Th39;
  end;

theorem Th41:
  for U1,U2 being Universal_Algebra st the UAStr of U1 = the UAStr of U2
  for G being GeneratorSet of U1 holds G is GeneratorSet of U2
  proof
    let U1,U2 be Universal_Algebra;
    assume A1: the UAStr of U1 = the UAStr of U2;
    let G be GeneratorSet of U1;
    reconsider G2 = G as Subset of U2 by A1;
    G2 is GeneratorSet of U2
    proof
      let A be Subset of U2;
      reconsider B = A as Subset of U1 by A1;
      assume A is opers_closed;
      hence thesis by A1,Th40,FREEALG:def 4;
    end;
    hence G is GeneratorSet of U2;
  end;

theorem Th42:
  for U1,U2 be Universal_Algebra st the UAStr of U1 = the UAStr of U2
  holds signature U1 = signature U2
  proof
    let U1,U2 be Universal_Algebra;
    assume A1: the UAStr of U1 = the UAStr of U2;
A2: len signature U2 = len the charact of U1 by A1,UNIALG_1:def 4;
    for i st i in dom signature U2
    for h be homogeneous non empty PartFunc of (the carrier of U1)*,
    the carrier of U1 st h = (the charact of U1).i holds
    (signature U2).i = arity h by A1,UNIALG_1:def 4;
    hence signature U1 = signature U2 by A2,UNIALG_1:def 4;
  end;

registration
  let J be non empty non void ManySortedSign;
  let T be MSAlgebra over J;
  let X be GeneratorSet of T;
  cluster non degenerated well_founded ECIW-strict infinite
  for with_empty-instruction with_catenation with_if-instruction
  with_while-instruction
  partial quasi_total non-empty non empty strict ProgramAlgStr over J,T,X;
  existence
  proof
    set U = the infinite IfWhileAlgebra;
    set I = the Function of Union [|X, the Sorts of T|], the carrier of U;
    set A = ProgramAlgStr(#the carrier of U, the charact of U,I#);
    A is partial quasi_total non-empty; then
    reconsider A as partial quasi_total non-empty strict
    ProgramAlgStr over J,T,X;
    A is with_empty-instruction with_catenation with_if-instruction
    with_while-instruction
    by AOFA_000:def 10,AOFA_000:def 11,AOFA_000:def 12,AOFA_000:def 13; then
    reconsider A as with_empty-instruction with_catenation with_if-instruction
    with_while-instruction
    partial quasi_total non-empty strict ProgramAlgStr over J,T,X;
    take A; set W = U;
    hereby let I1,I2 be Element of A;
      reconsider J1 = I1, J2 = I2 as Element of W;
      EmptyIns A = EmptyIns W & I1\;I2 = J1\;J2;
      hence (I1 <> EmptyIns A implies I1\;I2 <> I2) &
      (I2 <> EmptyIns A implies I1\;I2 <> I1) &
      (I1 <> EmptyIns A or I2 <> EmptyIns A implies I1\;I2 <> EmptyIns A)
      by AOFA_000:def 24;
    end;
    hereby let C,I1,I2 be Element of A;
      reconsider C1 = C, J1 = I1, J2 = I2 as Element of W;
      if-then-else(C,I1,I2) = if-then-else(C1,J1,J2) & EmptyIns W = EmptyIns A;
      hence if-then-else(C,I1,I2) <> EmptyIns A by AOFA_000:def 24;
    end;
    hereby let C,I be Element of A;
      reconsider C1 = C, J = I as Element of W;
      EmptyIns A = EmptyIns W & while(C,I) = while(C1,J);
      hence while(C,I) <> EmptyIns A by AOFA_000:def 24;
    end;
    hereby let I1,I2,C,J1,J2 be Element of A;
      reconsider C1 = C, K1 = I1, K2 = I2, L1 = J1, L2 = J2 as Element of W;
      if-then-else(C,J1,J2) = if-then-else(C1,L1,L2) & I1\;I2 = K1\;K2 &
      EmptyIns W = EmptyIns A;
      hence I1 = EmptyIns A or I2 = EmptyIns A or
      I1\;I2 <> if-then-else(C,J1,J2) by AOFA_000:def 24;
    end;
    hereby let I1,I2,C,J be Element of A;
      reconsider C1 = C, K1 = I1, K2 = I2, L = J as Element of W;
      EmptyIns W = EmptyIns A & I1\;I2 = K1\;K2 & while(C,J) = while(C1,L);
      hence I1 <> EmptyIns A & I2 <> EmptyIns A implies I1\;I2 <> while(C,J)
      by AOFA_000:def 24;
    end;
    hereby let C1,I1,I2,C2,J be Element of A;
      reconsider C3 = C1, K1 = I1, K2 = I2, C4 = C2, L = J as Element of W;
      while(C2,J) = while(C4,L) &
      if-then-else(C1,I1,I2) = if-then-else(C3,K1,K2);
      hence if-then-else(C1,I1,I2) <> while(C2,J) by AOFA_000:def 24;
    end;
    thus A is well_founded
    proof
A1:   the UAStr of W = the UAStr of A; then
      ElementaryInstructions W = ElementaryInstructions A &
      ElementaryInstructions W is GeneratorSet of W by Th38,AOFA_000:def 25;
      hence ElementaryInstructions A is GeneratorSet of A by A1,Th41;
    end;
    the UAStr of A = the UAStr of W; then
    signature A = signature W by Th42;
    hence signature A = ECIW-signature by AOFA_000:def 27;
    the UAStr of A = the UAStr of U; then
    ElementaryInstructions A = ElementaryInstructions U by Th38;
    hence ElementaryInstructions A is infinite;
  end;
end;

definition
  let J be non empty non void ManySortedSign;
  let T be MSAlgebra over J;
  let X be GeneratorSet of T;
  mode preIfWhileAlgebra of X is
  with_empty-instruction with_catenation with_if-instruction
  with_while-instruction
  partial quasi_total non-empty non empty ProgramAlgStr over J,T,X;
end;

definition
  let J be non empty non void ManySortedSign;
  let T be MSAlgebra over J;
  let X be GeneratorSet of T;
  mode IfWhileAlgebra of X is
  non degenerated well_founded ECIW-strict preIfWhileAlgebra of X;
end;

definition
  let J be non empty non void ManySortedSign;
  let T be non-empty MSAlgebra over J;
  let X be non-empty GeneratorSet of T;
  let A be non empty ProgramAlgStr over J,T,X;
  let a be SortSymbol of J;
  let x be Element of X.a;
  let t be Element of T,a;
  func x:=(t,A) -> Algorithm of A equals (the assignments of A).[x,t];
  coherence
  proof
    [|X, the Sorts of T|].a = [:X.a, (the Sorts of T).a:] by PBOOLE:def 16;then
    dom [|X, the Sorts of T|] = the carrier of J &
    [x,t] in [|X, the Sorts of T|].a by ZFMISC_1:87,PARTFUN1:def 2;
    hence thesis by CARD_5:2,FUNCT_2:5;
  end;
end;

registration
  let S be set;
  let T be disjoint_valued non-empty ManySortedSet of S;
  cluster non-empty for ManySortedSubset of T;
  existence
  proof
    set Y = the non-empty ManySortedSubset of T;
    take Y; thus thesis;
  end;
end;

definition
  let J be non void non empty ManySortedSign;
  let T,C be non-empty MSAlgebra over J;
  let X be non-empty GeneratorSet of T;
  func C-States(X) -> Subset of MSFuncs(X, the Sorts of C) means: Def18:
  for s being ManySortedFunction of X, the Sorts of C holds s in it iff
  ex f being ManySortedFunction of T,C st f is_homomorphism T,C & s = f||X;
  existence
  proof
    defpred P[object] means ex f being ManySortedFunction of T, C st
    f is_homomorphism T,C & $1 = f||X;
    consider A being set such that
A1: for x being object holds x in A iff x in MSFuncs(X, the Sorts of C) & P[x]
    from XBOOLE_0:sch 1;
    A c= MSFuncs(X, the Sorts of C)
    by A1; then
    reconsider A as Subset of MSFuncs(X, the Sorts of C);
    take A; let s be ManySortedFunction of X, the Sorts of C;
    X is_transformable_to the Sorts of C;
    hence thesis by A1,AUTALG_1:20;
  end;
  uniqueness
  proof let A1,A2 be Subset of MSFuncs(X, the Sorts of C) such that
A2: for s being ManySortedFunction of X, the Sorts of C holds s in A1 iff
    ex f being ManySortedFunction of T,C st f is_homomorphism T,C & s = f||X
    and
A3: for s being ManySortedFunction of X, the Sorts of C holds s in A2 iff
    ex f being ManySortedFunction of T,C st f is_homomorphism T,C & s = f||X;
A4: X is_transformable_to the Sorts of C;
    thus A1 c= A2
    proof
      let x be object; assume
A5:   x in A1; then
      reconsider x as ManySortedFunction of X, the Sorts of C
      by A4,AUTALG_1:19;
      ex f being ManySortedFunction of T,C st f is_homomorphism T,C & x = f||X
      by A2,A5;
      hence thesis by A3;
    end;
    let x be object; assume
A6: x in A2; then
    reconsider x as ManySortedFunction of X, the Sorts of C
    by A4,AUTALG_1:19;
    ex f being ManySortedFunction of T,C st f is_homomorphism T,C & x = f||X
    by A3,A6;
    hence thesis by A2;
  end;
end;

registration
  let J be non void non empty ManySortedSign;
  let T be non-empty MSAlgebra over J;
  let C be non-empty image of T;
  let X be non-empty GeneratorSet of T;
  cluster C-States(X) -> non empty;
  coherence
  proof
    consider h being ManySortedFunction of T,C such that
A1: h is_epimorphism T,C by MSAFREE4:def 5;
    h is_homomorphism T,C by A1,MSUALG_3:def 8;
    then h||X in C-States(X) by Def18;
    hence thesis;
  end;
end;

theorem Th43:
  for B being non void non empty ManySortedSign
  for T,C being non-empty MSAlgebra over B
  for X being non-empty GeneratorSet of T
  for g being set st g in C-States(X)
  holds g is ManySortedFunction of X, the Sorts of C
  proof
    let B be non void non empty ManySortedSign;
    let T,C be non-empty MSAlgebra over B;
    let X be non-empty GeneratorSet of T;
    X is_transformable_to the Sorts of C;
    hence thesis by AUTALG_1:19;
  end;

registration
  let B be non void non empty ManySortedSign;
  let T,C be non-empty MSAlgebra over B;
  let X be non-empty GeneratorSet of T;
  cluster -> Relation-like Function-like for Element of C-States(X);
  coherence
  proof
    let g be Element of (C)-States(X);
    (C)-States(X) is empty or (C)-States(X) is non empty;
    hence thesis by Th43;
  end;
end;

registration
  let B be non void non empty ManySortedSign;
  let T,C be non-empty MSAlgebra over B;
  let X be non-empty GeneratorSet of T;
  cluster -> Function-yielding the carrier of B-defined
  for Element of (C)-States(X);
  coherence
  proof
    let g be Element of (C)-States(X);
    (C)-States(X) is empty or (C)-States(X) is non empty; then
    g is empty or g in (C)-States(X) by SUBSET_1:def 1;
    hence thesis by Th43,RELAT_1:171;
  end;
end;

registration
  let B be non void non empty ManySortedSign;
  let T be non-empty MSAlgebra over B;
  let C be non-empty image of T;
  let X be non-empty GeneratorSet of T;
  cluster -> total for Element of (C)-States(X);
  coherence by Th43;
end;

definition
  let B be non void non empty ManySortedSign;
  let T be non-empty MSAlgebra over B;
  let C be non-empty MSAlgebra over B;
  let X be non-empty GeneratorSet of T;
  let a be SortSymbol of B;
  let x be Element of X.a;
  let f be Element of C,a;
  func f-States(X,x) -> Subset of (C)-States(X) means
  for s being ManySortedFunction of X, the Sorts of C holds
  s in it iff s in (C)-States(X) & s.a.x <> f;
  existence
  proof
    defpred P[object] means
 ex s being ManySortedFunction of X, the Sorts of C
    st s = $1 & s.a.x <> f;
    consider S being set such that
A1: for x being object holds x in S iff x in C-StatesX & P[x]
from XBOOLE_0:sch 1;
    S c= C-StatesX
    by A1; then
    reconsider S as Subset of C-StatesX;
    take S; let s be ManySortedFunction of X, the Sorts of C;
    hereby
      assume s in S; then
      s in C-StatesX & P[s] by A1;
      hence s in (C)-States(X) & s.a.x <> f;
    end;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let S1,S2 be Subset of C-StatesX such that
A2: for s being ManySortedFunction of X, the Sorts of C holds
    s in S1 iff s in (C)-States(X) & s.a.x <> f and
A3: for s being ManySortedFunction of X, the Sorts of C holds
    s in S2 iff s in (C)-States(X) & s.a.x <> f;
    thus S1 c= S2
    proof
      let c be object; assume
A4:   c in S1; then
      reconsider s = c as ManySortedFunction of X, the Sorts of C by Th43;
      s in (C)-States(X) & s.a.x <> f by A2,A4;
      hence thesis by A3;
    end;
    let c be object; assume
A5: c in S2; then
    reconsider s = c as ManySortedFunction of X, the Sorts of C by Th43;
    s in (C)-States(X) & s.a.x <> f by A3,A5;
    hence thesis by A2;
  end;
end;

registration
  let B be non void non empty ManySortedSign;
  let T be free non-empty MSAlgebra over B;
  let C be non-empty MSAlgebra over B;
  let X be non-empty GeneratorSet of T;
  cluster C-States(X) -> non empty;
  coherence
  proof
    set G = the free GeneratorSet of T;
    set f = the ManySortedFunction of G, the Sorts of C;
    consider h being ManySortedFunction of T,C such that
A1: h is_homomorphism T,C & h||G = f by MSAFREE:def 5;
    h||X in C-StatesX by A1,Def18;
    hence thesis;
  end;
end;

registration
  let S be non empty non void ManySortedSign;
  let A be non-empty MSAlgebra over S;
  let o be OperSymbol of S;
  cluster -> Function-like Relation-like for Element of Args(o,A);
  coherence
  proof
    let a be Element of Args(o,A);
    dom the Arity of S = the carrier' of S by FUNCT_2:def 1; then
    Args(o,A) = (the Sorts of A)#.the_arity_of o by FUNCT_1:13
    .= product ((the Sorts of A)*the_arity_of o) by FINSEQ_2:def 5;
    hence thesis;
  end;
end;

registration
  let B be non void non empty ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of B;
  let T be (X,B)-terms non-empty MSAlgebra over B;
  let C be non-empty image of T;
  let G be non-empty GeneratorSet of T;
  cluster C-States(G) -> non empty;
  coherence;
end;

definition
  let B be non void non empty ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of B;
  let T be (X,B)-terms non-empty MSAlgebra over B;
  let C be non-empty image of T;
  let a be SortSymbol of B;
  let t be Element of T, a;
  let s be Function-yielding Function;
  given h being ManySortedFunction of T,C,
     Q being GeneratorSet of T such that
A1:  h is_homomorphism T,C & Q = doms s & s = h||Q;
  func t value_at(C, s) -> Element of C, a means
  ex f being ManySortedFunction of T,C,
     Q being GeneratorSet of T st
  f is_homomorphism T,C & Q = doms s & s = f||Q & it = f.a.t;
  existence
  proof
    reconsider d = h.a.t as Element of (the Sorts of C).a by FUNCT_2:5;
    take d;
    take h; thus thesis by A1;
  end;
  uniqueness by EXTENS_1:19;
end;

begin :: Generator system

definition
  let S,X;
  let T be all_vars_including inheriting_operations free_in_itself
  (X,S)-terms MSAlgebra over S;
  struct GeneratorSystem over S,X,T(#
  generators -> non-empty GeneratorSet of T,
  supported-var -> (ManySortedFunction of the generators, FreeGen X),
  supported-term -> ManySortedMSSet of the generators, the carrier of S
  #);
end;

definition
  let S,X;
  let T be all_vars_including inheriting_operations free_in_itself
  (X,S)-terms MSAlgebra over S;
  let G be GeneratorSystem over S,X,T;
  let s be SortSymbol of S;
  mode Element of G,s -> Element of T,s means: Def21:
  it in (the generators of G).s;
  existence
  proof
    set t = the Element of (the generators of G).s;
    (the generators of G).s c= (the Sorts of T).s &
    t in (the generators of G).s
    by PBOOLE:def 2,PBOOLE:def 18;
    hence thesis;
  end;
end;

definition
  let S,X;
  let T be all_vars_including inheriting_operations free_in_itself
  (X,S)-terms MSAlgebra over S;
  let G be GeneratorSystem over S,X,T;
  let s be SortSymbol of S;
  func G.s -> Component of the generators of G equals
  (the generators of G).s;
  coherence;
  let g be Element of G,s;
  func supp-var g -> Element of (FreeGen X).s equals
  (the supported-var of G).s.g;
  coherence by Def21,FUNCT_2:5;
end;

definition
  let S,X;
  let T be all_vars_including inheriting_operations free_in_itself
  (X,S)-terms VarMSAlgebra over S;
  let G be GeneratorSystem over S,X,T;
  let s be SortSymbol of S;
  let g be Element of G,s;
  assume
A1
: (the supported-term of G).s.g is ManySortedFunction of vf g, the Sorts of T;
  func supp-term g -> ManySortedFunction of vf g, the Sorts of T
  equals
  (the supported-term of G).s.g;
  coherence by A1;
end;

definition
  let S be non void non empty ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of S;
  let T be all_vars_including inheriting_operations free_in_itself
  (X,S)-terms VarMSAlgebra over S;
  let C be non-empty image of T;
  let G be GeneratorSystem over S,X,T;
  attr G is C-supported means
  FreeGen X is ManySortedSubset of the generators of G &
  for s being SortSymbol of S holds dom ((the supported-term of G).s) = G.s &
  for t being Element of G,s holds
  (the supported-term of G).s.t is ManySortedFunction of vf t, the Sorts of T &
  (t in (FreeGen X).s implies supp-term t = id (s-singleton(t)) &
  supp-var t = t) &
  (for v being Element of C-States the generators of G
    st v.s.(supp-var t) = v.s.t
  for r being SortSymbol of S
  for x being Element of (FreeGen X).r
  for q being Element of (the Sorts of T).r
    st x in (vf t).r & q = (supp-term t).r.x holds v.r.x = q value_at(C, v)) &
  (t nin (FreeGen X).s implies
    for H being ManySortedSubset of the generators of G st  H = FreeGen X
    for v being Element of C, s
    for f being ManySortedFunction of the generators of G, the Sorts of C
    st f in C-States the generators of G
    for u being ManySortedFunction of FreeGen X, the Sorts of C
    st for a being SortSymbol of S for z being Element of (FreeGen X).a
       st z in (vf t).a holds
       for q being Element of T,a st q = (supp-term t).a.z
       holds u.a.z = q value_at(C, (f||H)+*(s,supp-var t,v))
    for H being ManySortedSubset of the Sorts of T st  H = FreeGen X
    for h being ManySortedFunction of T,C st h is_homomorphism T,C & h||H = u
    holds v = h.s.t);
end;

definition
  let S;
  let X;
  let A be vf-free all_vars_including inheriting_operations free_in_itself
  (X,S)-terms VarMSAlgebra over S;
  let C be non-empty image of A;
  let G be GeneratorSystem over S,X,A such that
A1: G is C-supported;
  let s be Element of C-States the generators of G;
  let r be SortSymbol of S;
  let v be Element of C,r;
  let t be Element of G,r;
  func succ(s,t,v) -> Element of C-States the generators of G means
  it.r.t = v &
  for p being SortSymbol of S
  for x being Element of (FreeGen X).p st p = r implies x <> t holds
  (x nin (vf t).p implies it.p.x = s.p.x) &
  for u being ManySortedFunction of FreeGen X, the Sorts of C
  for H being ManySortedSubset of the generators of G st  H = FreeGen X
  for f being ManySortedFunction of the generators of G, the Sorts of C st
  f = s & u = (f||H)+*(r,supp-var t,v) holds
  (x in (vf t).p implies for q being Element of A,p st q = (supp-term t).p.x
  holds it.p.x = q value_at(C, u));
  existence
  proof
    reconsider H = FreeGen X as ManySortedSubset of the generators of G by A1;
    reconsider I = FreeGen X as  GeneratorSet of A by MSAFREE4:45;
    reconsider f1 = s as ManySortedFunction of the generators of G,
    the Sorts of C by Th43;
    set g = f1||H;
    set r0 = r;
    defpred P[object,object] means
    ex f being Function st f = $2 &
    dom f = H.$1 & ($1 = r0 & t in H.r0 implies f.t = v) &
    for r being SortSymbol of S st $1 = r
    for x being Element of H.r st r = r0 implies x <> t holds
    (x nin (vf t).r implies f.x = g.r.x) & (x in (vf t).r implies
    for q being Element of A,r st q = (supp-term t).r.x
    for u being ManySortedFunction of H, the Sorts of C
    st u = g+*(r0,supp-var t,v)
    holds f.x = q value_at(C, u));
A2: for x being object st x in the carrier of S ex y being object st P[x,y]
    proof
      let x be object;
      assume x in the carrier of S; then
      reconsider p = x as SortSymbol of S;
      defpred Q[object,object] means
      (p = r & $1 = t implies $2 = v) &
      ((p = r implies $1 <> t) implies
      ($1 nin (vf t).x implies $2 = g.x.$1) &
      ($1 in (vf t).x implies
      for r being SortSymbol of S st x = r
      for q being Element of (the Sorts of A).r st q = (supp-term t).r.$1
      for u being ManySortedFunction of H, the Sorts of C
      st u = g+*(r0,supp-var t,v)
      holds $2 = q value_at(C, u)));
A3:   for y being object st y in H.x ex z being object st Q[y,z]
      proof
        let y be object; assume y in H.x;
        per cases;
        suppose
A4:       p = r & y = t;
          take z = v;
          thus thesis by A4;
        end;
        suppose
A5:       (p = r implies y <> t) & y in (vf t).x; then
          reconsider q = (supp-term t).p.y as Element of (the Sorts of A).p
          by FUNCT_2:5;
          take z = q value_at(C, g+*(r0,supp-var t,v));
          thus thesis by A5;
        end;
        suppose
A6:       (p = r implies y <> t) & y nin (vf t).x;
          take z = g.x.y;
          thus thesis by A6;
        end;
      end;
      consider j being Function such that
A7:   dom j = H.x & for y being object st y in H.x holds Q[y,j.y]
from CLASSES1:sch 1(A3);
      take j;
      thus P[x,j]
      proof
        take f = j;
        thus f = j & dom f = H.x by A7;
        thus x = r0 & t in H.r0 implies f.t = v by A7;
        let r be SortSymbol of S; assume
A8:     x = r;
        let x be Element of H.r;
        assume
A9:     r = r0 implies x <> t;
        hence (x nin (vf t).r implies f.x = g.r.x) by A7,A8;
        thus (x in (vf t).r implies
        for q being Element of A,r st q = (supp-term t).r.x
        for u being ManySortedFunction of H, the Sorts of C
        st u = g+*(r0,supp-var t,v)
        holds f.x = q value_at(C, u)) by A8,A7,A9;
      end;
    end;
    consider k being Function such that
A10: dom k = the carrier of S &
  for x being object st x in the carrier of S holds P[x,k.x]
    from CLASSES1:sch 1(A2);
    reconsider k as ManySortedSet of the carrier of S
    by A10,RELAT_1:def 18,PARTFUN1:def 2;
    k is Function-yielding
    proof
      let x be object; assume x in dom k; then
      P[x,k.x] by A10;
      hence thesis;
    end; then
    reconsider k as ManySortedFunction of the carrier of S;
    k is ManySortedFunction of H, the Sorts of C
    proof
      let x be object; assume x in the carrier of S; then
      reconsider p = x as SortSymbol of S;
      consider f being Function such that
A11:   k.p = f & dom f = H.p & (p = r0 & t in H.r0 implies f.t = v) &
      for r being SortSymbol of S st p = r
      for x being Element of H.r st r = r0 implies x <> t holds
      (x nin (vf t).r implies f.x = g.r.x) & (x in (vf t).r implies
      for q being Element of A,r st q = (supp-term t).r.x
      for u being ManySortedFunction of H, the Sorts of C
      st u = g+*(r0,supp-var t,v)
      holds f.x = q value_at(C, u)) by A10;
      rng f c= (the Sorts of C).p
      proof
        let y be object; assume y in rng f; then
        consider z being object such that
A12:     z in dom f & y = f.z by FUNCT_1:def 3;
        per cases;
        suppose
A13:       r = p & z = t;
          thus y in (the Sorts of C).p by A11,A12,A13;
        end;
        suppose (p = r implies t <> z) & z nin (vf t).p; then
          y = g.p.z by A11,A12;
          hence y in (the Sorts of C).p by A11,A12,FUNCT_2:5;
        end;
        suppose
A14:       (p = r implies t <> z) & z in (vf t).p;
          vf t is ManySortedSubset of H by Th35; then
          (vf t).p c= H.p by PBOOLE:def 2,def 18; then
          reconsider z as Element of H.p by A14;
          reconsider q = (supp-term t).p.z as Element of (the Sorts of A).p
          by A14,FUNCT_2:5;
          reconsider u = g+*(r0,supp-var t,v) as
          ManySortedFunction of H, the Sorts of C;
          y = q value_at(C,u) by A12,A14,A11;
          hence thesis;
        end;
      end;
      hence thesis by A11,FUNCT_2:2;
    end; then
    reconsider k as ManySortedFunction of H, the Sorts of C;
    consider h being ManySortedFunction of A,C such that
A15: h is_homomorphism A,C & k = h||I by MSAFREE4:46;
    reconsider w = h||the generators of G as
    Element of C-States the generators of G by A15,Def18;
    take w;
    hereby per cases;
      suppose
A16:     t in H.r0;
A17:     P[r0,k.r0] by A10;
        thus w.r.t = ((h.r)|((the generators of G).r)).t by MSAFREE:def 1
        .= h.r.t by Def21,FUNCT_1:49 .= ((h.r)|(H.r)).t by A16,FUNCT_1:49
        .= v by A17,A16,A15,MSAFREE:def 1;
      end;
      suppose
A18:     t nin H.r0;
A19:     now let a be SortSymbol of S;
A20:       P[a,k.a] by A10;
          let z be Element of (FreeGen X).a;
          a = r0 implies t <> z by A18;
          hence z in (vf t).a implies
          for q being Element of A,a st q = (supp-term t).a.z
          holds k.a.z = q value_at(C, g+*(r0,supp-var t,v)) by A20;
        end;
        thus w.r.t = ((h.r)|((the generators of G).r)).t by MSAFREE:def 1
        .= h.r.t by Def21,FUNCT_1:49
        .= v by A15,A18,A19,A1;
      end;
    end;
    let p be SortSymbol of S;
    let x be Element of (FreeGen X).p; assume
A21: p = r implies x <> t;
    reconsider x0 = x as Element of H.p;
    consider f being Function such that
A22: f = k.p & dom f = H.p & (p = r & t in H.r0 implies f.t = v) &
    for r being SortSymbol of S st p = r
    for x being Element of H.r st r = r0 implies x <> t holds
    (x nin (vf t).r implies f.x = g.r.x) & (x in (vf t).r implies
    for q being Element of A,r st q = (supp-term t).r.x
    for u being ManySortedFunction of H, the Sorts of C
    st u = g+*(r0,supp-var t,v)
    holds f.x = q value_at(C, u)) by A10;
A23: x in H.p & H.p c= (the generators of G).p by PBOOLE:def 2,def 18;
A24: w.p.x = (h.p)|((the generators of G).p).x by MSAFREE:def 1
    .= h.p.x by A23,FUNCT_1:49
    .= (h.p)|(I.p).x by FUNCT_1:49
    .= k.p.x by A15,MSAFREE:def 1;
    g.p.x = (f1.p)|(H.p).x by MSAFREE:def 1 .= s.p.x by FUNCT_1:49;
    hence x nin (vf t).p implies w.p.x = s.p.x by A21,A22,A24;
    let u be ManySortedFunction of FreeGen X, the Sorts of C;
    let H be ManySortedSubset of the generators of G such that
A25: H = FreeGen X;
    let f be ManySortedFunction of the generators of G, the Sorts of C such
    that
A26: f = s & u = (f||H)+*(r,supp-var t,v);
    assume
A27: x in (vf t).p;
    let q be Element of A,p; assume q = (supp-term t).p.x;
    hence w.p.x = q value_at(C, u) by A21,A24,A22,A25,A26,A27;
  end;
  uniqueness
  proof
    let w1,w2 be Element of C-States the generators of G; assume that
A28: w1.r.t = v &
    for p being SortSymbol of S
    for x being Element of (FreeGen X).p st p = r implies x <> t holds
    (x nin (vf t).p implies w1.p.x = s.p.x) &
    for u being ManySortedFunction of FreeGen X, the Sorts of C
    for H being ManySortedSubset of the generators of G st  H = FreeGen X
    for f being ManySortedFunction of the generators of G, the Sorts of C st
    f = s & u = (f||H)+*(r,supp-var t,v) holds
    (x in (vf t).p implies for q being Element of A,p st q = (supp-term t).p.x
    holds w1.p.x = q value_at(C, u)) and
A29: w2.r.t = v &
    for p being SortSymbol of S
    for x being Element of (FreeGen X).p st p = r implies x <> t holds
    (x nin (vf t).p implies w2.p.x = s.p.x) &
    for u being ManySortedFunction of FreeGen X, the Sorts of C
    for H being ManySortedSubset of the generators of G st H = FreeGen X
    for f being ManySortedFunction of the generators of G, the Sorts of C st
    f = s & u = (f||H)+*(r,supp-var t,v) holds
    (x in (vf t).p implies for q being Element of A,p st q = (supp-term t).p.x
    holds w2.p.x = q value_at(C, u));
    reconsider g1 = w1, g2 = w2 as ManySortedFunction of the generators of G,
    the Sorts of C by Th43;
    reconsider H = FreeGen X as ManySortedSubset of the generators of G by A1;
A30: now let x be object; assume x in the carrier of S; then
      reconsider p = x as SortSymbol of S;
A31:   dom((g1||H).p) = H.p & dom((g2||H).p) = H.p by FUNCT_2:def 1;
      now let y be object; assume
A32:     y in H.p;
        per cases;
        suppose
A33:       y = t & p = r;
          thus (g1||H).p.y = ((g1.p)|(H.p)).y by MSAFREE:def 1
          .= v by A28,A33,A32,FUNCT_1:49
          .= ((g2.p)|(H.p)).y by A29,A33,A32,FUNCT_1:49
          .= (g2||H).p.y by MSAFREE:def 1;
        end;
        suppose
A34:       (p = r implies y <> t) & y nin (vf t).p;
          thus (g1||H).p.y = ((g1.p)|(H.p)).y by MSAFREE:def 1
          .= g1.p.y by A32,FUNCT_1:49
          .= s.p.y by A28,A34,A32 .= g2.p.y by A29,A34,A32
          .= ((g2.p)|(H.p)).y by A32,FUNCT_1:49
          .= (g2||H).p.y by MSAFREE:def 1;
        end;
        suppose
A35:       (p = r implies y <> t) & y in (vf t).p;
          reconsider q = (supp-term t).p.y as Element of A,p by A35,FUNCT_2:5;
          reconsider f = s as ManySortedFunction of the generators of G,
          the Sorts of C by Th43;
          reconsider u = (f||H)+*(r,supp-var t,v) as ManySortedFunction of
          FreeGen X, the Sorts of C;
          thus (g1||H).p.y = ((g1.p)|(H.p)).y by MSAFREE:def 1
          .= g1.p.y by A32,FUNCT_1:49 .= q value_at(C, u) by A28,A35,A32
          .= w2.p.y by A29,A35,A32
          .= ((g2.p)|(H.p)).y by A32,FUNCT_1:49
          .= (g2||H).p.y by MSAFREE:def 1;
        end;
      end;
      hence (g1||H).x = (g2||H).x by A31;
    end;
    consider h1 being ManySortedFunction of A,C such that
A36: h1 is_homomorphism A,C & g1 = h1||the generators of G by Def18;
    consider h2 being ManySortedFunction of A,C such that
A37: h2 is_homomorphism A,C & g2 = h2||the generators of G by Def18;
    reconsider I = H as GeneratorSet of A by MSAFREE4:45;
    h1||I = g1||H & h2||I = g2||H by A36,A37,EQUATION:5;
    hence thesis by A30,A36,A37,EXTENS_1:19,PBOOLE:3;
  end;
end;

definition
  let B be non void non empty ManySortedSign;
  let Y be non-empty ManySortedSet of the carrier of B;
  let T be vf-free all_vars_including inheriting_operations free_in_itself
  (Y,B)-terms VarMSAlgebra over B;
  let C be non-empty image of T;
  let X be GeneratorSystem over B,Y,T;
  let A be preIfWhileAlgebra of the generators of X;
  let a be SortSymbol of B;
  let x be Element of (the generators of X).a;
  let z be Element of C,a;
  func C -Execution (A,x,z) -> Subset of
  Funcs([:C-States(the generators of X), the carrier of A:],
  C-States(the generators of X)) means
  for f being Function of [:C-States(the generators of X), the carrier of A:],
  C-States(the generators of X) holds
  f in it iff f is ExecutionFunction of A, C-States(the generators of X),
  z-States(the generators of X, x) &
  for s being Element of C-States(the generators of X)
  for b being SortSymbol of B
  for v being Element of (the generators of X).b
  for v0 being Element of X,b st v0 = v
  for t being Element of T, b
  holds f.(s, v:=(t,A)) = succ(s,v0,t value_at(C,s));
  existence
  proof
    defpred P[object] means
    ex f being Function of [:C-States(the generators of X), the carrier of A:],
    C-States(the generators of X) st
    $1 = f & f is ExecutionFunction of A, C-States(the generators of X),
    z-States(the generators of X, x) &
    for s being Element of C-States(the generators of X)
    for b being SortSymbol of B
    for v being Element of (the generators of X).b
    for v0 being Element of X, b st v0 = v
    for t being Element of T, b
    holds f.(s, v:=(t,A)) = succ(s,v0,t value_at(C, s));
    consider Z being set such that
A1: for c being object holds c in Z iff
    c in Funcs([:C-States(the generators of X), the carrier of A:],
    C-States(the generators of X)) & P[c]
    from XBOOLE_0:sch 1;
    Z c= Funcs([:C-States(the generators of X), the carrier of A:],
    C-States(the generators of X))
    by A1; then
    reconsider Z as Subset of Funcs([:C-States(the generators of X),
    the carrier of A:],
    C-States(the generators of X));
    take Z;
    let f be Function of [:C-States(the generators of X), the carrier of A:],
    C-States(the generators of X);
    hereby assume f in Z; then P[f] by A1;
      hence f is ExecutionFunction of A, C-States(the generators of X),
      z-States(the generators of X, x) &
      for s being Element of C-States(the generators of X)
      for b being SortSymbol of B
      for v being Element of (the generators of X).b
      for v0 being Element of X, b st v0 = v
      for t being Element of T, b
      holds f.(s, v:=(t,A)) = succ(s,v0,t value_at(C, s));
    end;
    f in Funcs([:C-States(the generators of X), the carrier of A:],
    C-States(the generators of X)) by FUNCT_2:8;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let Z1,Z2 be Subset of Funcs([:C-States(the generators of X),
    the carrier of A:],C-States(the generators of X)) such that
A2: for f being Function of [:C-States(the generators of X),the carrier of A:],
    C-States(the generators of X) holds
    f in Z1 iff f is ExecutionFunction of A, C-States(the generators of X),
    z-States(the generators of X, x) &
    for s being Element of C-States(the generators of X)
    for b being SortSymbol of B
    for v being Element of (the generators of X).b
    for v0 being Element of X, b st v0 = v
    for t being Element of T, b
    holds f.(s, v:=(t,A)) = succ(s,v0,t value_at(C, s)) and
A3: for f being Function of [:C-States(the generators of X),the carrier of A:],
    C-States(the generators of X) holds
    f in Z2 iff f is ExecutionFunction of A, C-States(the generators of X),
    z-States(the generators of X, x) &
    for s being Element of C-States(the generators of X)
    for b being SortSymbol of B
    for v being Element of (the generators of X).b
    for v0 being Element of X, b st v0 = v
    for t being Element of T, b
    holds f.(s, v:=(t,A)) = succ(s,v0,t value_at(C, s));
    thus Z1 c= Z2
    proof
      let c be object; assume
A4:   c in Z1; then
      reconsider f = c as Function of [:C-States(the generators of X),
      the carrier of A:], C-States(the generators of X) by FUNCT_2:66;
      f is ExecutionFunction of A, C-States(the generators of X),
      z-States(the generators of X, x) &
      for s being Element of C-States(the generators of X)
      for b being SortSymbol of B
      for v being Element of (the generators of X).b
      for v0 being Element of X, b st v0 = v
      for t being Element of T, b
      holds f.(s, v:=(t,A)) = succ(s,v0,t value_at(C, s)) by A2,A4;
      hence thesis by A3;
    end;
    let c be object; assume
A5: c in Z2; then
    reconsider f = c as Function of [:C-States(the generators of X),
    the carrier of A:],
    C-States(the generators of X) by FUNCT_2:66;
    f is ExecutionFunction of A, C-States(the generators of X),
    z-States(the generators of X, x) &
    for s being Element of C-States(the generators of X)
    for b being SortSymbol of B
    for v being Element of (the generators of X).b
    for v0 being Element of X, b st v0 = v
    for t being Element of T, b
    holds f.(s, v:=(t,A)) = succ(s,v0,t value_at(C, s)) by A3,A5;
    hence thesis by A2;
  end;
end;

begin :: Boolean signature

definition
  struct (ManySortedSign) ConnectivesSignature (#
    carrier,carrier' -> set,
    Arity -> Function of the carrier',(the carrier)*,
    ResultSort -> Function of the carrier', the carrier,
    connectives -> FinSequence of the carrier'
  #);
end;

definition
  let S be ConnectivesSignature;
  attr S is 1-1-connectives means: Def28:
  the connectives of S is one-to-one;
end;

definition
  let n be Nat;
  let S be ConnectivesSignature;
  attr S is n-connectives means: Def29:
  len the connectives of S = n;
end;

registration
  let n be Nat;
  cluster n-connectives non empty non void for strict ConnectivesSignature;
  existence
  proof
    set S = the non empty non void ManySortedSign;
    set o = the OperSymbol of S;
    reconsider c = n|->o as n-element FinSequence of the carrier' of S;
    take C = ConnectivesSignature(# the carrier of S, the carrier' of S,
    the Arity of S, the ResultSort of S, c #);
    thus len the connectives of C = n by CARD_1:def 7;
    thus the carrier of C is non empty;
    thus the carrier' of C is non empty;
  end;
end;

definition
  struct (ConnectivesSignature) BoolSignature (#
    carrier,carrier' -> set,
    Arity -> Function of the carrier',(the carrier)*,
    ResultSort -> Function of the carrier', the carrier,
    bool-sort -> (Element of the carrier),
    connectives -> FinSequence of the carrier'
  #);
end;

registration
  let n be Nat;
  cluster n-connectives non empty non void for strict BoolSignature;
  existence
  proof
    set S = the non empty non void ManySortedSign;
    set o = the OperSymbol of S;
    reconsider c = n|->o as n-element FinSequence of the carrier' of S;
    set b = the SortSymbol of S;
    take C = BoolSignature(# the carrier of S, the carrier' of S,
    the Arity of S, the ResultSort of S, b, c #);
    thus len the connectives of C = n by CARD_1:def 7;
    thus the carrier of C is non empty;
    thus the carrier' of C is non empty;
  end;
end;

definition
  let B be BoolSignature;
  attr B is bool-correct means: Def30:
  len the connectives of B >= 3 &
  (the connectives of B).1 is_of_type {}, the bool-sort of B &
  (the connectives of B).2 is_of_type <*the bool-sort of B*>,
  the bool-sort of B &
  (the connectives of B).3 is_of_type
  <*the bool-sort of B, the bool-sort of B*>, the bool-sort of B;
end;

registration
  cluster 3-connectives 1-1-connectives bool-correct non empty non void
  for strict BoolSignature;
  existence
  proof
    set X = {0}, Y = {0,1,2};
    reconsider 00 = 0 as Element of X by TARSKI:def 1;
    reconsider 01 = 1, 02 = 2, y0 = 0 as Element of Y by ENUMSET1:def 1;
    set a = (0,1,2)-->({},<*00*>,<*00,00*>);
    set r = {0,1,2}-->00;
A1:   0,1,2 are_mutually_distinct;
    <*>X in X* & <*00*> in X* & <*00,00*> in X* by FINSEQ_1:def 11; then
    {{},<*00*>,<*00,00*>} c= X* by ZFMISC_1:133; then
    rng a c= X* & dom a = Y by FUNCT_4:128,FUNCT_4:147,A1; then
    reconsider a as Function of Y,X* by FUNCT_2:2;
    reconsider r as Function of Y,X;
    take B = BoolSignature(#X,Y,a,r,00,<*y0,01,02*>#);
    thus len the connectives of B = 3 by FINSEQ_1:45;
    thus the connectives of B is one-to-one by FINSEQ_3:95;
    thus len the connectives of B >= 3 by FINSEQ_1:45;
    (the connectives of B).1 = 0 by FINSEQ_1:45;
    hence (the Arity of B).((the connectives of B).1) = {} by FUNCT_4:134;
    thus (the ResultSort of B).((the connectives of B).1) = the bool-sort of B;
    (the connectives of B).2 = 1 by FINSEQ_1:45;
    hence (the Arity of B).((the connectives of B).2) = <*the bool-sort of B*>
    by FUNCT_4:135;
    thus (the ResultSort of B).((the connectives of B).2) = the bool-sort of B;
    (the connectives of B).3 = 2 by FINSEQ_1:45;
    hence (the Arity of B).((the connectives of B).3) =
    <*the bool-sort of B, the bool-sort of B*> by FUNCT_4:135;
    thus (the ResultSort of B).((the connectives of B).3) = the bool-sort of B;
    thus the carrier of B is non empty;
    thus the carrier' of B is non empty;
    thus thesis;
  end;
end;

registration
  cluster 1-1-connectives non empty non void for ConnectivesSignature;
  existence
  proof
    set S = the 1-1-connectives bool-correct non empty non void
    BoolSignature;
    take S;
    thus thesis;
  end;
end;

registration
  let S be 1-1-connectives non empty non void ConnectivesSignature;
  cluster the connectives of S -> one-to-one;
  coherence by Def28;
end;

definition
  let S be non empty non void BoolSignature;
  let B be MSAlgebra over S;
  attr B is bool-correct means: Def31:
  (the Sorts of B).the bool-sort of S = BOOLEAN &
  Den(In((the connectives of S).1, the carrier' of S), B).{} = TRUE &
  for x,y be boolean object holds
  Den(In((the connectives of S).2, the carrier' of S), B).<*x*> = 'not' x &
  Den(In((the connectives of S).3, the carrier' of S), B).<*x,y*> = x '&' y;
end;

theorem Th44:
  for A being non empty set, n being Nat
  for f being Function of n-tuples_on A,A holds
  f is homogeneous quasi_total non empty PartFunc of A*,A &
  for g being homogeneous Function st f = g holds g is n-ary
  proof
    let A be non empty set;
    let n be Nat;
    let f be Function of n-tuples_on A,A;
A1: n in NAT by ORDINAL1:def 12; then
    n-tuples_on A c= A*
    by FINSEQ_2:134; then
    reconsider f as PartFunc of A*,A by RELSET_1:7;
A2: dom f = n-tuples_on A by FUNCT_2:def 1; then
    reconsider f as homogeneous PartFunc of A*,A by A1,COMPUT_1:16;
    set t = the Element of n-tuples_on A;
    arity f = len t by A2,MARGREL1:def 25 .= n by A1,FINSEQ_2:133;
    hence thesis by A2,COMPUT_1:def 21,22;
  end;

registration
  let A be non empty set;
  let n be Nat;
  cluster n-ary for homogeneous quasi_total non empty PartFunc of A*,A;
  existence
  proof
    set f = the Function of n-tuples_on A,A;
A1: n in NAT by ORDINAL1:def 12; then
    n-tuples_on A c= A*
    by FINSEQ_2:134; then
    reconsider f as PartFunc of A*,A by RELSET_1:7;
A2: dom f = n-tuples_on A by FUNCT_2:def 1; then
    reconsider f as homogeneous PartFunc of A*,A by A1,COMPUT_1:16;
    set t = the Element of n-tuples_on A;
A3: arity f = len t by A2,MARGREL1:def 25 .= n by A1,FINSEQ_2:133; then
    reconsider f as homogeneous quasi_total non empty PartFunc of A*,A
    by A2,COMPUT_1:22;
    take f;
    thus thesis by A3,COMPUT_1:def 21;
  end;
end;

scheme Sch1 {A() -> non empty set, F(set) -> Element of A()}:
  ex f being 1-ary homogeneous quasi_total non empty PartFunc of A()*,A() st
  for a being Element of A() holds f.<*a*> = F(a)
  proof
    deffunc G(Element of 1-tuples_on A()) = F($1.1);
    consider f being Function of 1-tuples_on A(), A() such that
A1: for a being Element of 1-tuples_on A() holds f.a = G(a) from FUNCT_2:sch 4;
    reconsider f as 1-ary homogeneous quasi_total non empty PartFunc of
    A()*,A() by Th44;
    take f;
    let a be Element of A();
    reconsider p = <*a*> as Element of 1-tuples_on A() by FINSEQ_2:98;
    thus f.<*a*> = G(p) by A1 .= F(a) by FINSEQ_1:40;
  end;

scheme Sch2 {A() -> non empty set, F(set,set) -> Element of A()}:
  ex f being 2-ary homogeneous quasi_total non empty PartFunc of A()*,A() st
  for a,b being Element of A() holds f.<*a,b*> = F(a,b)
  proof
    deffunc G(Element of 2-tuples_on A()) = F($1.1,$1.2);
    consider f being Function of 2-tuples_on A(), A() such that
A1: for a being Element of 2-tuples_on A() holds f.a = G(a) from FUNCT_2:sch 4;
    reconsider f as 2-ary homogeneous quasi_total non empty PartFunc of
    A()*,A() by Th44;
    take f;
    let a,b be Element of A();
    reconsider p = <*a,b*> as Element of 2-tuples_on A() by FINSEQ_2:101;
    thus f.<*a,b*> = G(p) by A1 .= F(a,p.2) by FINSEQ_1:44
    .= F(a,b) by FINSEQ_1:44;
  end;

theorem Th45:
  for S being non empty non void ManySortedSign
  for A being non-empty ManySortedSet of the carrier of S
  for f being ManySortedFunction of A#*the Arity of S, A*the ResultSort of S
  for o being OperSymbol of S
  for d being Function of (A#*the Arity of S).o, (A*the ResultSort of S).o
  holds
  f+*(o,d) is ManySortedFunction of A#*the Arity of S, A*the ResultSort of S
  proof
    let S be non empty non void ManySortedSign;
    let A be non-empty ManySortedSet of the carrier of S;
    let f be ManySortedFunction of A#*the Arity of S, A*the ResultSort of S;
    let o be OperSymbol of S;
    let d be Function of (A#*the Arity of S).o, (A*the ResultSort of S).o;
    let x be object; assume x in the carrier' of S; then
    reconsider x as OperSymbol of S;
    dom f = the carrier' of S by PARTFUN1:def 2; then
    (x = o implies f+*(o,d).x = d) & (x <> o implies f+*(o,d).x = f.x)
    by FUNCT_7:31,32;
    hence thesis;
  end;

theorem Th46:
  for S being bool-correct non empty non void BoolSignature
  for A being non-empty ManySortedSet of the carrier of S
  ex B being non-empty strict MSAlgebra over S st
  the Sorts of B = A+*(the bool-sort of S, BOOLEAN) &
  B is bool-correct
  proof
    let S be bool-correct non empty non void BoolSignature;
    let A be non-empty ManySortedSet of the carrier of S;
    set A1 = A+*(the bool-sort of S, BOOLEAN);
    set Ch = the ManySortedFunction of A1#*the Arity of S,
    A1*the ResultSort of S;
    deffunc F((Element of BOOLEAN),Element of BOOLEAN) = $1 '&' $2;
    consider f being 2-ary homogeneous quasi_total non empty PartFunc of
    BOOLEAN*, BOOLEAN such that
A1: for a,b being Element of BOOLEAN holds f.<*a,b*> = F(a,b) from  Sch2;
    deffunc F(Element of BOOLEAN) = 'not' $1;
    consider f1 being 1-ary homogeneous quasi_total non empty PartFunc of
    BOOLEAN*, BOOLEAN such that
A2: for a being Element of BOOLEAN holds f1.<*a*> = F(a) from  Sch1;
A3: dom f1 = (arity f1)-tuples_on BOOLEAN by COMPUT_1:22
    .= 1-tuples_on BOOLEAN by COMPUT_1:def 21;
A4: rng f1 c= BOOLEAN by RELAT_1:def 19;
A5: dom f = (arity f)-tuples_on BOOLEAN by COMPUT_1:22
    .= 2-tuples_on BOOLEAN by COMPUT_1:def 21;
A6: rng f c= BOOLEAN by RELAT_1:def 19;
A7: 3 <= len the connectives of S by Def30; then
    1 <= len the connectives of S & 2 <= len the connectives of S
    by XXREAL_0:2; then
A8: 1 in dom the connectives of S & 2 in dom the connectives of S &
    3 in dom the connectives of S by A7,FINSEQ_3:25;
    reconsider o1 = (the connectives of S).2, o2 = (the connectives of S).3,
    o0 = (the connectives of S).1 as OperSymbol of S by A8,DTCONSTR:2;
    set Ch1 = Ch+*(o1, f1)+*(o2,f);
    set bs = the bool-sort of S;
A9: <*bs*> in (the carrier of S)* by FINSEQ_1:def 11;
A10: dom A = the carrier of S & dom A1 = the carrier of S
    by PARTFUN1:def 2; then
A11: A1.bs = BOOLEAN by FUNCT_7:31;
    o1 is_of_type <*bs*>,bs by Def30; then
A12: the_arity_of o1 = <*bs*> & the_result_sort_of o1 = bs; then
A13: (A1#*the Arity of S).o1 = A1#.<*bs*> by FUNCT_2:15
    .= product (A1*<*bs*>) by A9,FINSEQ_2:def 5
    .= product <*A1.bs*> by A10,FINSEQ_2:34
    .= 1-tuples_on BOOLEAN by A11,FINSEQ_3:126;
    (A1*the ResultSort of S).o1 = A1.bs by A12,FUNCT_2:15; then
    f1 is Function of (A1#*the Arity of S).o1, (A1*the ResultSort of S).o1
    by A13,A11,A3,A4,FUNCT_2:2; then
    reconsider Ch2 = Ch+*(o1,f1) as ManySortedFunction of A1#*the Arity of S,
    A1*the ResultSort of S by Th45;
A14: <*bs,bs*> in (the carrier of S)* by FINSEQ_1:def 11;
    o2 is_of_type <*bs,bs*>,bs by Def30; then
A15: the_arity_of o2 = <*bs,bs*> & the_result_sort_of o2 = bs; then
A16: (A1#*the Arity of S).o2 = A1#.<*bs,bs*> by FUNCT_2:15
    .= product (A1*<*bs,bs*>) by A14,FINSEQ_2:def 5
    .= product <*A1.bs,A1.bs*> by A10,FINSEQ_2:125
    .= 2-tuples_on BOOLEAN by A11,FINSEQ_3:128;
    (A1*the ResultSort of S).o2 = A1.bs by A15,FUNCT_2:15; then
    f is Function of (A1#*the Arity of S).o2, (A1*the ResultSort of S).o2
    by A16,A11,A5,A6,FUNCT_2:2; then
    reconsider Ch1 = Ch2+*(o2,f) as ManySortedFunction of A1#*the Arity of S,
    A1*the ResultSort of S by Th45;
    reconsider t = TRUE as Element of BOOLEAN;
    set f0 = (0-tuples_on BOOLEAN)-->t;
    dom f0 = 0-tuples_on BOOLEAN & rng f0 c= {t} & {t} c= BOOLEAN
    by ZFMISC_1:31; then
    reconsider f0 as Function of 0-tuples_on BOOLEAN, BOOLEAN
    by FUNCT_2:2;
A17: <*>the carrier of S in (the carrier of S)* by FINSEQ_1:def 11;
    o0 is_of_type {},bs by Def30; then
A18: the_arity_of o0 = {} & the_result_sort_of o0 = bs; then
A19: (A1#*the Arity of S).o0 = A1#.{} by FUNCT_2:15
    .= product (A1*{}) by A17,FINSEQ_2:def 5
    .= product (<*>BOOLEAN)
    .= 0-tuples_on BOOLEAN by FINSEQ_2:94,CARD_3:10;
    (A1*the ResultSort of S).o0 = A1.bs by A18,FUNCT_2:15; then
    reconsider Ch3 = Ch1+*(o0,f0) as ManySortedFunction of A1#*the Arity of S,
    A1*the ResultSort of S by A19,A11,Th45;
    set B = MSAlgebra(#A1,Ch3#);
    B is non-empty; then
    reconsider B as non-empty strict MSAlgebra over S;
    take B;
    thus the Sorts of B = A+*(the bool-sort of S, BOOLEAN);
    thus (the Sorts of B).the bool-sort of S = BOOLEAN by A10,FUNCT_7:31;
A20
: len the_arity_of o0 = 0 & len the_arity_of o1 = 1 & len the_arity_of o2 = 2
    by A12,A15,A18,FINSEQ_1:40,44;
A21: dom Ch2 = the carrier' of S & dom Ch = the carrier' of S &
    dom Ch1 = the carrier' of S by PARTFUN1:def 2;
A22: Ch3.o1 = Ch1.o1 by A12,A18,FUNCT_7:32 .= Ch2.o1 by A20,FUNCT_7:32
    .= f1 by A21,FUNCT_7:31;
A23: Ch3.o0 = f0 by A21,FUNCT_7:31;
    In((the connectives of S).1, the carrier' of S) = o0 & {} in {{}} &
    0-tuples_on BOOLEAN = {<*>BOOLEAN}
    by TARSKI:def 1,FINSEQ_2:94;
    hence Den(In((the connectives of S).1, the carrier' of S), B).{} =
    TRUE by A23,FUNCOP_1:7;
    hereby let x,y be boolean object;
A24:   x in BOOLEAN & y in BOOLEAN by MARGREL1:def 12;
      hence Den(In((the connectives of S).2, the carrier' of S), B).<*x*>
      = 'not' x by A2,A22;
     Ch3.o2 = Ch1.o2 by A15,A18,FUNCT_7:32 .= f by A21,FUNCT_7:31;
      hence Den(In((the connectives of S).3, the carrier' of S), B).<*x,y*>
      = x '&' y by A1,A24;
    end;
  end;

registration
  let S be bool-correct non empty non void BoolSignature;
  cluster bool-correct non-empty for strict MSAlgebra over S;
  existence
  proof
    set A = the non-empty ManySortedSet of the carrier of S;
    ex B being non-empty strict MSAlgebra over S st
    the Sorts of B = A+*(the bool-sort of S, BOOLEAN) & B is bool-correct
    by Th46;
    hence thesis;
  end;
end;

definition
  let S be bool-correct non empty non void BoolSignature;
  let B be non-empty MSAlgebra over S;
  set f = the bool-sort of S, L = B;
A1: (the connectives of S).1 is_of_type {}, f by Def30;
A2: (the connectives of S).2 is_of_type <*f*>, f by Def30;
A3: (the connectives of S).3 is_of_type <*f,f*>, f by Def30;
A4:len the connectives of S >= 3 by Def30; then
  1 <= len the connectives of S & 2 <= len the connectives of S
  by XXREAL_0:2; then
A5:2 in dom the connectives of S & 1 in dom the connectives of S &
  3 in dom the connectives of S by A4,FINSEQ_3:25;
A6: (the connectives of S).1 in rng the connectives of S &
  rng the connectives of S c= the carrier' of S
  by A5,RELAT_1:def 19,FUNCT_1:def 3;
  func \trueB -> Element of B, the bool-sort of S equals
  Den(In((the connectives of S).1, the carrier' of S), B).{};
  coherence by A1,Th26,A6;
  let p be Element of B, the bool-sort of S;
  func \notp -> Element of B, the bool-sort of S equals
  Den(In((the connectives of S).2, the carrier' of S), B).<*p*>;
  coherence by A2,Th27;
  let q be Element of B, the bool-sort of S;
  func p\andq -> Element of B, the bool-sort of S equals
  Den(In((the connectives of S).3, the carrier' of S), B).<*p,q*>;
  coherence by A3,Th28;
end;

definition
  let S be bool-correct non empty non void BoolSignature;
  let B be non-empty MSAlgebra over S;
  let p be Element of B, the bool-sort of S;
  let q be Element of B, the bool-sort of S;
  func p\orq -> Element of B, the bool-sort of S equals \not(\notp\and\notq);
  coherence;
  func p\impq -> Element of B, the bool-sort of S equals \not(p\and\notq);
  coherence;
end;

definition
  let S be bool-correct non empty non void BoolSignature;
  let B be non-empty MSAlgebra over S;
  let p be Element of B, the bool-sort of S;
  let q be Element of B, the bool-sort of S;
  func p\iffq -> Element of B, the bool-sort of S equals
  p\andq\or(\notp\and\notq);
  coherence;
end;

begin :: Algebra with integers

definition
  let i be Nat;
  let s be set;
  let S be BoolSignature;
  attr S is (i,s) integer means: Def38:
  len the connectives of S >= i+6 &
  ex I being Element of S st I = s &
  I <> the bool-sort of S &
  (the connectives of S).i is_of_type {},I & :: 0
  (the connectives of S).(i+1) is_of_type {},I & :: 1
  (the connectives of S).i <> (the connectives of S).(i+1) &
  (the connectives of S).(i+2) is_of_type <*I*>,I &  :: -
  (the connectives of S).(i+3) is_of_type <*I,I*>,I & :: +
  (the connectives of S).(i+4) is_of_type <*I,I*>,I & :: *
  (the connectives of S).(i+5) is_of_type <*I,I*>,I & :: div
  (the connectives of S).(i+3) <> (the connectives of S).(i+4) &
  (the connectives of S).(i+3) <> (the connectives of S).(i+5) &
  (the connectives of S).(i+4) <> (the connectives of S).(i+5) &
  (the connectives of S).(i+6) is_of_type <*I,I*>,the bool-sort of S; :: <=
end;

theorem Th47:
  ex S being 10-connectives non empty non void strict BoolSignature st
  S is 1-1-connectives (4,1) integer bool-correct & the carrier of S = {0,1} &
  ex I being SortSymbol of S st I = 1 &
  (the connectives of S).4 is_of_type {},I
  proof
    set X = {0,1}, Y = {0,1,2,3,4,5,6,7,8,9};
    reconsider 00 = 0, x1 = 1 as Element of X by TARSKI:def 2;
    reconsider y0 = 0, 01 = 1, 02 = 2, 03 = 3, 04 = 4, 05 = 5, 06 = 6,
    07 = 7, 08 = 8, 09 = 9 as Element of Y by ENUMSET1:def 8;
    set aa = <*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
    <*<*x1,x1*>*>;
    set a = aa+*({0}-->{});
    set r = ({0,1,2,9}-->00)\/({3,4,5,6,7,8}-->x1);
    <*00*> in X* & <*00,00*> in X* & <*x1*> in X* & <*x1,x1*> in X* &
    <*>X in X* by FINSEQ_1:def 11; then
A1: {{},<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>}
    c= X* &
    rng a c= rng aa \/ rng ({0}-->{}) & dom a =  dom aa \/ dom({0}-->{}) &
    dom ({0}-->{}) = {0} & rng ({0}-->{}) = {{}}
    by Th10,FUNCT_4:17,def 1; then
    rng a c= {<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>,
    <*x1,x1*>}\/{{}} by Th21; then
    rng a c= {{},<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>,
    <*x1,x1*>} & dom aa = Seg 9 by Th12,FINSEQ_1:89; then
    rng a c= X* & dom a = Y by A1,Th12,Th22; then
    reconsider a as Function of Y,X* by FUNCT_2:2;
A2: dom({0,1,2,9}-->00) = {0,1,2,9} & dom({3,4,5,6,7,8}-->x1) = {3,4,5,6,7,8};
    {0,1,2,9} misses {3,4,5,6,7,8}
    proof
      assume {0,1,2,9} meets {3,4,5,6,7,8}; then
      consider x being object such that
A3:   x in {0,1,2,9} & x in {3,4,5,6,7,8} by XBOOLE_0:3;
      (x = 0 or x = 1 or x = 2 or x = 9) & (x = 3 or x = 4 or x = 5 or x = 6 or
      x = 7 or x = 8) by A3,ENUMSET1:def 2,def 4;
      hence thesis;
    end; then
    reconsider r as Function by A2,GRFUNC_1:13;
A4: dom r = {0,1,2,9}\/{3,4,5,6,7,8} by A2,XTUPLE_0:23
    .= {0,1,2}\/{9}\/{3,4,5,6,7,8} by ENUMSET1:6
    .= {0,1,2}\/{3,4,5,6,7,8}\/{9} by XBOOLE_1:4
    .= {0,1,2,3,4,5,6,7,8}\/{9} by Th13
    .= Y by ENUMSET1:85;
    rng r = rng({0,1,2,9}-->00)\/rng({3,4,5,6,7,8}-->x1) by RELAT_1:12
    .={00}\/rng({3,4,5,6,7,8}-->x1) .= {00}\/{x1}
    .= X by ENUMSET1:1; then
    reconsider r as Function of Y,X by A4,FUNCT_2:2;
    set B = BoolSignature(#X,Y,a,r,00,<*y0,01,02,03,04,05,06,07*>^<*08,09*>#);
A5: len the connectives of B = len <*y0,01,02,03,04,05,06,07*>+len<*08,09*>
    by FINSEQ_1:22 .= 8+len <*08,09*> by Th19 .= 8+2 by FINSEQ_1:44 .= 10;
    B is 10-connectives non empty non void
    by A5; then
    reconsider B as 10-connectives non empty non void strict BoolSignature;
    take B;
    thus the connectives of B is one-to-one
    proof
      let x,y be object; assume
A6:   x in dom the connectives of B & y in dom the connectives of B;
      set c = the connectives of B;
A7:   dom c = Seg 10 by Th25;
A8:   y=1 or y=2 or y=3 or y=4 or y=5 or y=6 or y=7 or y=8 or y=9 or y=10
      by A6,A7,Th23,ENUMSET1:def 8;
      c.1 = y0 & c.2 = 01 & c.3 = 02 & c.4 = 03 & c.5 = 04 & c.6 = 05 &
      c.7 = 06 & c.8 = 07 & c.9 = 08 & c.10 = 09 by Th25;
      hence thesis by A7,A8,A6,Th23,ENUMSET1:def 8;
    end;
    thus B is (4,1) integer
    proof
      thus len the connectives of B >= 4+6 by A5;
      reconsider I = x1 as Element of B;
      take I; thus I = 1;
      thus I <> the bool-sort of B;
A9:   (the connectives of B).4 = 3 & 3 nin dom ({0}-->{})
      by Th25;
      hence (the Arity of B).((the connectives of B).4)
      = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
      <*<*x1,x1*>*>).3 by FUNCT_4:11 .= {} by Th24;
      3 in {3,4,5,6,7,8} & I in {I} by TARSKI:def 1,ENUMSET1:def 4; then
      [3,I] in {3,4,5,6,7,8}-->x1 by ZFMISC_1:87; then
      [3,I] in r by XBOOLE_0:def 3;
      hence (the ResultSort of B).((the connectives of B).4) = I
      by A9,FUNCT_1:1;
A10:   (the connectives of B).5 = 4 & 4 nin dom ({0}-->{})
      by Th25;
      hence (the Arity of B).((the connectives of B).(4+1))
      = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
      <*<*x1,x1*>*>).4 by FUNCT_4:11 .= {} by Th24;
      4 in {3,4,5,6,7,8} & I in {I} by TARSKI:def 1,ENUMSET1:def 4; then
      [4,I] in {3,4,5,6,7,8}-->x1 by ZFMISC_1:87; then
      [4,I] in r by XBOOLE_0:def 3;
      hence (the ResultSort of B).((the connectives of B).(4+1)) = I
      by A10,FUNCT_1:1;
      thus (the connectives of B).4 <> (the connectives of B).(4+1)
      by A9,Th25;
A11:   (the connectives of B).6 = 5 & 5 nin dom ({0}-->{})
      by Th25;
      hence (the Arity of B).((the connectives of B).(4+2))
      = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
      <*<*x1,x1*>*>).5 by FUNCT_4:11 .= <*I*> by Th24;
      5 in {3,4,5,6,7,8} & I in {I} by TARSKI:def 1,ENUMSET1:def 4; then
      [5,I] in {3,4,5,6,7,8}-->x1 by ZFMISC_1:87; then
      [5,I] in r by XBOOLE_0:def 3;
      hence (the ResultSort of B).((the connectives of B).(4+2)) = I
      by A11,FUNCT_1:1;
A12:   (the connectives of B).7 = 6 & 6 nin dom ({0}-->{})
      by Th25;
      hence (the Arity of B).((the connectives of B).(4+3))
      = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
      <*<*x1,x1*>*>).6 by FUNCT_4:11 .= <*I,I*> by Th24;
      6 in {3,4,5,6,7,8} & I in {I} by TARSKI:def 1,ENUMSET1:def 4; then
      [6,I] in {3,4,5,6,7,8}-->x1 by ZFMISC_1:87; then
      [6,I] in r by XBOOLE_0:def 3;
      hence (the ResultSort of B).((the connectives of B).(4+3)) = I
      by A12,FUNCT_1:1;
A13:  (the connectives of B).8 = 7 & 7 nin dom ({0}-->{})
      by Th25;
      hence (the Arity of B).((the connectives of B).(4+4))
      = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
      <*<*x1,x1*>*>).7 by FUNCT_4:11 .= <*I,I*> by Th24;
      7 in {3,4,5,6,7,8} & I in {I} by TARSKI:def 1,ENUMSET1:def 4; then
      [7,I] in {3,4,5,6,7,8}-->x1 by ZFMISC_1:87; then
      [7,I] in r by XBOOLE_0:def 3;
      hence (the ResultSort of B).((the connectives of B).(4+4)) = I
      by A13,FUNCT_1:1;
A14:   (the connectives of B).9 = 8 & 8 nin dom ({0}-->{})
      by Th25;
      hence (the Arity of B).((the connectives of B).(4+5))
      = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
      <*<*x1,x1*>*>).8 by FUNCT_4:11 .= <*I,I*> by Th24;
      8 in {3,4,5,6,7,8} & I in {I} by TARSKI:def 1,ENUMSET1:def 4; then
      [8,I] in {3,4,5,6,7,8}-->x1 by ZFMISC_1:87; then
      [8,I] in r by XBOOLE_0:def 3;
      hence (the ResultSort of B).((the connectives of B).(4+5)) = I
      by A14,FUNCT_1:1;
      thus (the connectives of B).(4+3) <> (the connectives of B).(4+4)
      by A13,Th25;
      thus (the connectives of B).(4+3) <> (the connectives of B).(4+5)
      by A14,Th25;
      thus (the connectives of B).(4+4) <> (the connectives of B).(4+5)
      by A14,Th25;
A15:   (the connectives of B).10 = 9 & 9 nin dom ({0}-->{})
      by Th25;
      hence (the Arity of B).((the connectives of B).(4+6))
      = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
      <*<*x1,x1*>*>).9 by FUNCT_4:11 .= <*I,I*> by Th24;
      9 in {0,1,2,9} & the bool-sort of B in {the bool-sort of B}
      by TARSKI:def 1,ENUMSET1:def 2; then
      [9,00] in {0,1,2,9}-->00 by ZFMISC_1:87; then
      [9,00] in r by XBOOLE_0:def 3;
      hence (the ResultSort of B).((the connectives of B).(4+6)) =
      the bool-sort of B by A15,FUNCT_1:1;
    end;
    thus len the connectives of B >= 3 by A5;
A16: (the connectives of B).1 = 0 & 0 in {0} by Th25,TARSKI:def 1;
    hence (the Arity of B).((the connectives of B).1)
    = ({0}-->{}).0 by A1,FUNCT_4:13
    .= {};
    0 in {0,1,2,9} & 00 in {00} by TARSKI:def 1,ENUMSET1:def 2; then
    [0,the bool-sort of B] in {0,1,2,9}-->00 by ZFMISC_1:87; then
    [0,the bool-sort of B] in r by XBOOLE_0:def 3;
    hence (the ResultSort of B).((the connectives of B).1) = the bool-sort of B
    by A16,FUNCT_1:1;
A17: (the connectives of B).2 = 1 & 1 nin {0} by Th25,TARSKI:def 1;
    hence (the Arity of B).((the connectives of B).2)
    = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
    <*<*x1,x1*>*>).1 by A1,FUNCT_4:11 .= <*the bool-sort of B*> by Th24;
    1 in {0,1,2,9} & 00 in {00} by TARSKI:def 1,ENUMSET1:def 2; then
    [1,the bool-sort of B] in {0,1,2,9}-->00 by ZFMISC_1:87; then
    [1,the bool-sort of B] in r by XBOOLE_0:def 3;
    hence (the ResultSort of B).((the connectives of B).2) = the bool-sort of B
    by A17,FUNCT_1:1;
A18: (the connectives of B).3 = 2 & 2 nin {0} by Th25,TARSKI:def 1;
    hence (the Arity of B).((the connectives of B).3)
    = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
    <*<*x1,x1*>*>).2 by A1,FUNCT_4:11
    .= <*the bool-sort of B,the bool-sort of B*> by Th24;
    2 in {0,1,2,9} & 00 in {00} by TARSKI:def 1,ENUMSET1:def 2; then
    [2,the bool-sort of B] in {0,1,2,9}-->00 by ZFMISC_1:87; then
    [2,the bool-sort of B] in r by XBOOLE_0:def 3;
    hence (the ResultSort of B).((the connectives of B).3) = the bool-sort of B
    by A18,FUNCT_1:1;
    thus the carrier of B = {0,1};
    reconsider I = 1 as SortSymbol of B;
    take I; thus I = 1;
A19: (the connectives of B).4 = 3 & 3 nin dom ({0}-->{})
    by Th25;
    hence (the Arity of B).((the connectives of B).4)
    = (<*<*00*>,<*00,00*>,{},{},<*x1*>,<*x1,x1*>,<*x1,x1*>,<*x1,x1*>*>^
    <*<*x1,x1*>*>).3 by FUNCT_4:11 .= {} by Th24;
    3 in {3,4,5,6,7,8} & I in {I} by TARSKI:def 1,ENUMSET1:def 4; then
    [3,I] in {3,4,5,6,7,8}-->x1 by ZFMISC_1:87; then
    [3,I] in r by XBOOLE_0:def 3;
    hence (the ResultSort of B).((the connectives of B).4) = I
    by A19,FUNCT_1:1;
  end;

registration
  cluster 10-connectives 1-1-connectives (4,1) integer
  bool-correct non empty non void for strict BoolSignature;
  existence by Th47;
end;

definition
  let S be non empty non void BoolSignature;
  let I be SortSymbol of S;
  attr I is integer means: Def39: I = 1;
end;

registration
  let S be (4,1) integer non empty non void BoolSignature;
  cluster integer for SortSymbol of S;
  existence
  proof
    consider I being SortSymbol of S such that
A1:  I = 1 and I <> the bool-sort of S &
    (the connectives of S).4 is_of_type {},I &
    (the connectives of S).(4+1) is_of_type {},I &
    (the connectives of S).4 <> (the connectives of S).(4+1) &
    (the connectives of S).(4+2) is_of_type <*I*>,I &
    (the connectives of S).(4+3) is_of_type <*I,I*>,I &
    (the connectives of S).(4+4) is_of_type <*I,I*>,I &
    (the connectives of S).(4+5) is_of_type <*I,I*>,I &
    (the connectives of S).(4+3) <> (the connectives of S).(4+4) &
    (the connectives of S).(4+3) <> (the connectives of S).(4+5) &
    (the connectives of S).(4+4) <> (the connectives of S).(4+5) &
    (the connectives of S).(4+6) is_of_type <*I,I*>,the bool-sort of S by Def38
;
    take I; thus I = 1 by A1;
  end;
end;

theorem Th48:
  for S being (4,1) integer non empty non void BoolSignature
  for I being integer SortSymbol of S holds
  I <> the bool-sort of S &
  (the connectives of S).4 is_of_type {},I &
  (the connectives of S).(4+1) is_of_type {},I &
  (the connectives of S).4 <> (the connectives of S).(4+1) &
  (the connectives of S).(4+2) is_of_type <*I*>,I &
  (the connectives of S).(4+3) is_of_type <*I,I*>,I &
  (the connectives of S).(4+4) is_of_type <*I,I*>,I &
  (the connectives of S).(4+5) is_of_type <*I,I*>,I &
  (the connectives of S).(4+3) <> (the connectives of S).(4+4) &
  (the connectives of S).(4+3) <> (the connectives of S).(4+5) &
  (the connectives of S).(4+4) <> (the connectives of S).(4+5) &
  (the connectives of S).(4+6) is_of_type <*I,I*>,the bool-sort of S
  proof
    let S be (4,1) integer non empty non void BoolSignature;
    let I be integer SortSymbol of S;
A1: I = 1 by Def39;
    ex I being SortSymbol of S st I = 1 &
    I <> the bool-sort of S &
    (the connectives of S).4 is_of_type {},I &
    (the connectives of S).(4+1) is_of_type {},I &
    (the connectives of S).4 <> (the connectives of S).(4+1) &
    (the connectives of S).(4+2) is_of_type <*I*>,I &
    (the connectives of S).(4+3) is_of_type <*I,I*>,I &
    (the connectives of S).(4+4) is_of_type <*I,I*>,I &
    (the connectives of S).(4+5) is_of_type <*I,I*>,I &
    (the connectives of S).(4+3) <> (the connectives of S).(4+4) &
    (the connectives of S).(4+3) <> (the connectives of S).(4+5) &
    (the connectives of S).(4+4) <> (the connectives of S).(4+5) &
    (the connectives of S).(4+6) is_of_type <*I,I*>,the bool-sort of S by Def38
;
    hence thesis by A1;
  end;

definition
  let S be (4,1) integer non empty non void BoolSignature;
  let A be non-empty MSAlgebra over S;
  let I be integer SortSymbol of S;
  set f = the bool-sort of S, L = A;
A1: I = 1 & I <> the bool-sort of S &
   (the connectives of S).4 is_of_type {},I &
   (the connectives of S).(4+1) is_of_type {},I &
   (the connectives of S).4 <> (the connectives of S).(4+1) &
   (the connectives of S).(4+2) is_of_type <*I*>,I &
   (the connectives of S).(4+3) is_of_type <*I,I*>,I &
   (the connectives of S).(4+4) is_of_type <*I,I*>,I &
   (the connectives of S).(4+5) is_of_type <*I,I*>,I &
   (the connectives of S).(4+3) <> (the connectives of S).(4+4) &
   (the connectives of S).(4+3) <> (the connectives of S).(4+5) &
   (the connectives of S).(4+4) <> (the connectives of S).(4+5) &
   (the connectives of S).(4+6) is_of_type <*I,I*>,the bool-sort of S
   by Def39,Th48;
  len the connectives of S >= 4+6 by Def38; then
  4 <= len the connectives of S & 5 <= len the connectives of S &
  6 <= len the connectives of S & 7 <= len the connectives of S &
  8 <= len the connectives of S & 9 <= len the connectives of S &
  10 <= len the connectives of S
  by XXREAL_0:2; then
A2:4 in dom the connectives of S & 5 in dom the connectives of S &
  6 in dom the connectives of S & 7 in dom the connectives of S &
  8 in dom the connectives of S & 9 in dom the connectives of S &
  10 in dom the connectives of S by FINSEQ_3:25;
A3: (the connectives of S).4 in rng the connectives of S &
  rng the connectives of S c= the carrier' of S
  by A2,RELAT_1:def 19,FUNCT_1:def 3;
  func \0(A,I) -> Element of (the Sorts of A).I equals
  Den(In((the connectives of S).4, the carrier' of S), A).{};
  coherence by Th48,Th26,A3;
A4: (the connectives of S).5 in rng the connectives of S &
  rng the connectives of S c= the carrier' of S
  by A2,RELAT_1:def 19,FUNCT_1:def 3;
  func \1(A,I) -> Element of (the Sorts of A).I equals
  Den(In((the connectives of S).5, the carrier' of S), A).{};
  coherence by Th48,Th26,A4;
  let a be Element of (the Sorts of A).I;
  func -a -> Element of (the Sorts of A).I equals
  Den(In((the connectives of S).6, the carrier' of S), A).<*a*>;
  coherence by A1,Th27;
  let b be Element of (the Sorts of A).I;
  func a+b -> Element of (the Sorts of A).I equals
  Den(In((the connectives of S).7, the carrier' of S), A).<*a,b*>;
  coherence by A1,Th28;
  func a*b -> Element of (the Sorts of A).I equals
  Den(In((the connectives of S).8, the carrier' of S), A).<*a,b*>;
  coherence by A1,Th28;
  func a div b -> Element of (the Sorts of A).I equals
  Den(In((the connectives of S).9, the carrier' of S), A).<*a,b*>;
  coherence by A1,Th28;
  func leq(a,b) -> Element of (the Sorts of A).the bool-sort of S equals
  Den(In((the connectives of S).10, the carrier' of S), A).<*a,b*>;
  coherence by A1,Th28;
end;

definition
  let S be (4,1) integer non empty non void BoolSignature;
  let A be non-empty MSAlgebra over S;
  let I be integer SortSymbol of S;
  let a,b be Element of A,I;
  func a-b -> Element of A,I equals a+-b;
  coherence;
  func a mod b -> Element of A,I equals a+-(a div b)*b;
  coherence;
end;

registration
  let S be (4,1) integer non empty non void BoolSignature;
  let X be non-empty ManySortedSet of the carrier of S;
  cluster X.1 -> non empty;
  coherence
  proof set i = 4;
    consider I being Element of S such that
A1: I = 1 and I <> the bool-sort of S &
    (the connectives of S).i is_of_type {},I &
    (the connectives of S).(i+1) is_of_type {},I &
    (the connectives of S).i <> (the connectives of S).(i+1) &
    (the connectives of S).(i+2) is_of_type <*I*>,I &
    (the connectives of S).(i+3) is_of_type <*I,I*>,I &
    (the connectives of S).(i+4) is_of_type <*I,I*>,I &
    (the connectives of S).(4+5) is_of_type <*I,I*>,I &
    (the connectives of S).(4+3) <> (the connectives of S).(4+4) &
    (the connectives of S).(4+3) <> (the connectives of S).(4+5) &
    (the connectives of S).(4+4) <> (the connectives of S).(4+5) &
    (the connectives of S).(4+6) is_of_type <*I,I*>,the bool-sort of S
    by Def38;
    thus thesis by A1;
  end;
end;

definition
  let n be Nat;
  let s be set;
  let S be bool-correct non empty non void BoolSignature;
  let A be bool-correct MSAlgebra over S;
  attr A is (n,s) integer means: Def49:
  ex I being SortSymbol of S st I = s &
  (the connectives of S).n is_of_type {},I & (the Sorts of A).I = INT &
  Den(In((the connectives of S).n, the carrier' of S), A).{} = 0 &
  Den(In((the connectives of S).(n+1), the carrier' of S), A).{} = 1 &
  for i,j being Integer holds
  Den(In((the connectives of S).(n+2), the carrier' of S), A).<*i*> = -i &
  Den(In((the connectives of S).(n+3), the carrier' of S), A).<*i,j*> = i+j &
  Den(In((the connectives of S).(n+4), the carrier' of S), A).<*i,j*> = i*j &
  (j <> 0 implies
  Den(In((the connectives of S).(n+5), the carrier' of S), A).<*i,j*>
  = i div j) &
  Den(In((the connectives of S).(n+6), the carrier' of S), A).<*i,j*>
  = IFGT(i,j,FALSE,TRUE);
end;

theorem Th49:
  for n being Nat, I being set st n >= 1
  for S being bool-correct non empty non void BoolSignature
  st S is (n,I) integer
  ex A being bool-correct non-empty strict MSAlgebra over S st
  A is (n,I) integer
  proof
    let n be Nat;
    let J be set; assume
A1: n >= 1;
    let S be bool-correct non empty non void BoolSignature;
    assume A2: S is (n,J) integer;
    then consider I being Element of S such that
A3: I = J & I <> the bool-sort of S &
    (the connectives of S).n is_of_type {},I &
    (the connectives of S).(n+1) is_of_type {},I &
    (the connectives of S).n <> (the connectives of S).(n+1) &
    (the connectives of S).(n+2) is_of_type <*I*>,I &
    (the connectives of S).(n+3) is_of_type <*I,I*>,I &
    (the connectives of S).(n+4) is_of_type <*I,I*>,I &
    (the connectives of S).(n+5) is_of_type <*I,I*>,I &
    (the connectives of S).(n+3) <> (the connectives of S).(n+4) &
    (the connectives of S).(n+3) <> (the connectives of S).(n+5) &
    (the connectives of S).(n+4) <> (the connectives of S).(n+5) &
    (the connectives of S).(n+6) is_of_type <*I,I*>,the bool-sort of S;
    set X = the non-empty ManySortedSet of the carrier of S;
    set A = X+*(I,INT);
    consider B being non-empty strict MSAlgebra over S such that
A4: the Sorts of B = A+*(the bool-sort of S,BOOLEAN) &
    B is bool-correct by Th46;
    set C = the Sorts of B;
    set Ch = the Charact of B;
    set bs = the bool-sort of S;
A5: len the connectives of S >= n+6 by A2;
    n+4 <= n+4+2 & n+3 <= n+3+3 & n+2 <= n+2+4 & n+1 <= n+1+5 & n <= n+6 &
    1 <= 1+(n+5) & 2 <= 2+(n+4) & 3 <= 3+(n+3) & 1 <= 1+(n+3) & 1 <= 1+(n+2) &
    n+5 <= n+5+1 & 1 <= 1+(n+1) & 1 <= n+1 by NAT_1:12;
    then n+5 <= len the connectives of S & n+4 <= len the connectives of S &
    n+3 <= len the connectives of S & n+2 <= len the connectives of S &
    n+1 <= len the connectives of S & 3 <= len the connectives of S &
    1 <= len the connectives of S & 2 <= len the connectives of S &
    n <= len the connectives of S by A5,XXREAL_0:2; then
    1 in dom the connectives of S & 2 in dom the connectives of S &
    3 in dom the connectives of S & n in dom the connectives of S &
    n+1 in dom the connectives of S & n+2 in dom the connectives of S &
    n+3 in dom the connectives of S & n+4 in dom the connectives of S &
    n+5 in dom the connectives of S & n+6 in dom the connectives of S
    by A5,A1,FINSEQ_3:25,NAT_1:12; then
    reconsider o01 = (the connectives of S).1, o02 = (the connectives of S).2,
    o03 = (the connectives of S).3,
    o1 = (the connectives of S).n, o2 = (the connectives of S).(n+1),
    o3 = (the connectives of S).(n+2), o4 = (the connectives of S).(n+3),
    o5 = (the connectives of S).(n+4), o6 = (the connectives of S).(n+5),
    o7 = (the connectives of S).(n+6) as OperSymbol of S by DTCONSTR:2;
    set g0 = (0-tuples_on INT)-->0;
    set g1 = (0-tuples_on INT)-->1;
A6: dom g0 = 0-tuples_on INT & dom g1 = 0-tuples_on INT;
    {0} c= INT & {1} c= INT by INT_1:def 2; then
    rng g0 c= INT & rng g1 c= INT; then
    reconsider g0,g1 as Function of 0-tuples_on INT, INT by A6,FUNCT_2:2;
    deffunc F(Element of INT) = In(-$1,INT) qua Element of INT;
    consider f1 being 1-ary homogeneous quasi_total non empty PartFunc of
    INT*, INT such that
A7: for a being Element of INT holds f1.<*a*> = F(a) from Sch1;
A8: dom f1 = (arity f1)-tuples_on INT by COMPUT_1:22
    .= 1-tuples_on INT by COMPUT_1:def 21;
A9: rng f1 c= INT by RELAT_1:def 19;
A10: <*I*> in (the carrier of S)* by FINSEQ_1:def 11;
A11: dom A = the carrier of S & dom X = the carrier of S &
    dom C = the carrier of S by PARTFUN1:def 2;
A12: C.I = A.I by A4,A3,FUNCT_7:32 .= INT by A11,FUNCT_7:31;
A13: the_arity_of o3 = <*I*> & the_result_sort_of o3 = I by A3; then
A14: (C#*the Arity of S).o3 = C#.<*I*> by FUNCT_2:15
    .= product (C*<*I*>) by A10,FINSEQ_2:def 5
    .= product <*C.I*> by A11,FINSEQ_2:34
    .= 1-tuples_on INT by A12,FINSEQ_3:126;
    (C*the ResultSort of S).o3 = C.I by A13,FUNCT_2:15; then
    f1 is Function of (C#*the Arity of S).o3, (C*the ResultSort of S).o3
    by A14,A12,A8,A9,FUNCT_2:2; then
    reconsider Ch1 = (the Charact of B)+*(o3,f1) as ManySortedFunction of
    C#*the Arity of S, C*the ResultSort of S by Th45;
    deffunc F((Element of INT),Element of INT) = In($1+$2,INT);
    consider f2 being 2-ary homogeneous quasi_total non empty PartFunc of
    INT*, INT such that
A15: for a,b being Element of INT holds f2.<*a,b*> = F(a,b) from Sch2;
A16: dom f2 = (arity f2)-tuples_on INT by COMPUT_1:22
    .= 2-tuples_on INT by COMPUT_1:def 21;
A17: rng f2 c= INT by RELAT_1:def 19;
A18: <*I,I*> in (the carrier of S)* by FINSEQ_1:def 11;
A19: the_arity_of o4 = <*I,I*> & the_result_sort_of o4 = I by A3; then
A20: (C#*the Arity of S).o4 = C#.<*I,I*> by FUNCT_2:15
    .= product (C*<*I,I*>) by A18,FINSEQ_2:def 5
    .= product <*C.I,C.I*> by A11,FINSEQ_2:125
    .= 2-tuples_on INT by A12,FINSEQ_3:128;
    (C*the ResultSort of S).o4 = C.I by A19,FUNCT_2:15; then
    f2 is Function of (C#*the Arity of S).o4, (C*the ResultSort of S).o4
    by A20,A12,A16,A17,FUNCT_2:2; then
    reconsider Ch2 = Ch1+*(o4,f2) as ManySortedFunction of
    C#*the Arity of S, C*the ResultSort of S by Th45;
    deffunc F((Element of INT),Element of INT) = In($1*$2,INT);
    consider f3 being 2-ary homogeneous quasi_total non empty PartFunc of
    INT*, INT such that
A21: for a,b being Element of INT holds f3.<*a,b*> = F(a,b) from Sch2;
A22: dom f3 = (arity f3)-tuples_on INT by COMPUT_1:22
    .= 2-tuples_on INT by COMPUT_1:def 21;
A23: rng f3 c= INT by RELAT_1:def 19;
A24: the_arity_of o5 = <*I,I*> & the_result_sort_of o5 = I by A3; then
A25: (C#*the Arity of S).o5 = C#.<*I,I*> by FUNCT_2:15
    .= product (C*<*I,I*>) by A18,FINSEQ_2:def 5
    .= product <*C.I,C.I*> by A11,FINSEQ_2:125
    .= 2-tuples_on INT by A12,FINSEQ_3:128;
    (C*the ResultSort of S).o5 = C.I by A24,FUNCT_2:15; then
    f3 is Function of (C#*the Arity of S).o5, (C*the ResultSort of S).o5
    by A25,A12,A22,A23,FUNCT_2:2; then
    reconsider Ch3 = Ch2+*(o5,f3) as ManySortedFunction of
    C#*the Arity of S, C*the ResultSort of S by Th45;
    deffunc F((Element of INT),Element of INT) = In($1 div $2,INT);
    consider fa being 2-ary homogeneous quasi_total non empty PartFunc of
    INT*, INT such that
A26: for a,b being Element of INT holds fa.<*a,b*> = F(a,b) from Sch2;
A27: dom fa = (arity fa)-tuples_on INT by COMPUT_1:22
    .= 2-tuples_on INT by COMPUT_1:def 21;
A28: rng fa c= INT by RELAT_1:def 19;
A29: the_arity_of o6 = <*I,I*> & the_result_sort_of o6 = I by A3; then
A30: (C#*the Arity of S).o6 = C#.<*I,I*> by FUNCT_2:15
    .= product (C*<*I,I*>) by A18,FINSEQ_2:def 5
    .= product <*C.I,C.I*> by A11,FINSEQ_2:125
    .= 2-tuples_on INT by A12,FINSEQ_3:128;
    (C*the ResultSort of S).o6 = C.I by A29,FUNCT_2:15; then
    fa is Function of (C#*the Arity of S).o6, (C*the ResultSort of S).o6
    by A30,A12,A27,A28,FUNCT_2:2; then
    reconsider Ch3a = Ch3+*(o6,fa) as ManySortedFunction of
    C#*the Arity of S, C*the ResultSort of S by Th45;
    deffunc G(Element of 2-tuples_on INT)
    = In(IFGT($1/.1,$1/.2,FALSE,TRUE),BOOLEAN);
    consider f4 being Function of 2-tuples_on INT, BOOLEAN such that
A31: for p being Element of 2-tuples_on INT holds f4.p = G(p)
    from FUNCT_2:sch 4;
A32: the_arity_of o7 = <*I,I*> & the_result_sort_of o7 = bs by A3; then
A33: (C#*the Arity of S).o7 = C#.<*I,I*> by FUNCT_2:15
    .= product (C*<*I,I*>) by A18,FINSEQ_2:def 5
    .= product <*C.I,C.I*> by A11,FINSEQ_2:125
    .= 2-tuples_on INT by A12,FINSEQ_3:128;
    (C*the ResultSort of S).o7 = C.bs by A32,FUNCT_2:15
    .= BOOLEAN by A4; then
    reconsider Ch4 = Ch3a+*(o7,f4) as ManySortedFunction of
    C#*the Arity of S, C*the ResultSort of S by A33,Th45;
A34: <*>the carrier of S in (the carrier of S)* by FINSEQ_1:def 11;
A35: the_arity_of o1 = {} & the_result_sort_of o1 = I by A3; then
A36: (C#*the Arity of S).o1 = C#.{} by FUNCT_2:15
    .= product (C*<*>INT) by A34,FINSEQ_2:def 5
    .= 0-tuples_on INT by CARD_3:10,FINSEQ_2:94;
    (C*the ResultSort of S).o1
    = INT by A12,A35,FUNCT_2:15; then
    reconsider Ch5 = Ch4+*(o1,g0) as ManySortedFunction of
    C#*the Arity of S, C*the ResultSort of S by A36,Th45;
A37: the_arity_of o2 = {} & the_result_sort_of o2 = I by A3; then
A38: (C#*the Arity of S).o2 = C#.{} by FUNCT_2:15
    .= product (C*<*>INT) by A34,FINSEQ_2:def 5
    .= 0-tuples_on INT by CARD_3:10,FINSEQ_2:94;
    (C*the ResultSort of S).o2 = INT by A12,A37,FUNCT_2:15; then
    reconsider Ch6 = Ch5+*(o2,g1) as ManySortedFunction of
    C#*the Arity of S, C*the ResultSort of S by A38,Th45;
A39: dom Ch5 = the carrier' of S & dom Ch4 = the carrier' of S &
    dom Ch3 = the carrier' of S & dom Ch2 = the carrier' of S &
    dom Ch1 = the carrier' of S & dom Ch = the carrier' of S &
    dom Ch3a = the carrier' of S by PARTFUN1:def 2;
    set D = MSAlgebra(#C,Ch6#);
    D is non-empty bool-correct
    proof
      thus the Sorts of D is non-empty;
      thus (the Sorts of D).the bool-sort of S = BOOLEAN by A4;
      o01 is_of_type {}, bs & o02 is_of_type <*bs*>, bs &
      o03 is_of_type <*bs,bs*>, bs by Def30; then
      the_arity_of o01 = {} & the_result_sort_of o01 = bs &
      the_result_sort_of o02 = bs & the_result_sort_of o03 = bs &
      the_arity_of o02 = <*bs*> & the_arity_of o03 = <*bs,bs*> &
      len <*bs*> = 1 & len <*I,I*> = 2 & <*I,I*>.1 = I & <*bs,bs*>.1 = bs
      by FINSEQ_1:40,44; then
A40:   o01 <> o4 & o01 <> o3 & o01 <> o2 & o01 <> o1 & o01 <> o5 & o01 <> o6 &
      o02 <> o4 & o02 <> o3 & o02 <> o2 & o02 <> o1 & o02 <> o5 & o02 <> o6 &
      o03 <> o4 & o03 <> o3 & o03 <> o2 & o03 <> o1 & o03 <> o5 & o03 <> o6 &
      o01 <> o7 & o02 <> o7 & o03 <> o7 by A3;
A41:   Ch6.o01 = Ch5.o01 by A40,FUNCT_7:32
      .= Ch4.o01 by A40,FUNCT_7:32
      .= Ch3a.o01 by A40,FUNCT_7:32
      .= Ch3.o01 by A40,FUNCT_7:32 .= Ch2.o01 by A40,FUNCT_7:32
      .= Ch1.o01 by A40,FUNCT_7:32
      .= Ch.o01 by A40,FUNCT_7:32;
      thus Den(In((the connectives of S).1, the carrier' of S), D).{}
      = Den(o01,B).{} by A41
      .= Den(In((the connectives of S).1, the carrier' of S), B).{}
      .= TRUE by A4;
      let x,y be boolean object;
A42:   Ch6.o02 = Ch5.o02 by A40,FUNCT_7:32
      .= Ch4.o02 by A40,FUNCT_7:32
      .= Ch3a.o02 by A40,FUNCT_7:32
      .= Ch3.o02 by A40,FUNCT_7:32
      .= Ch2.o02 by A40,FUNCT_7:32
      .= Ch1.o02 by A40,FUNCT_7:32
      .= Ch.o02 by A40,FUNCT_7:32;
      thus Den(In((the connectives of S).2, the carrier' of S), D).<*x*>
      = Den(o02,B).<*x*> by A42
      .= 'not' x by A4;
A44:   Ch6.o03 = Ch5.o03 by A40,FUNCT_7:32
      .= Ch4.o03 by A40,FUNCT_7:32
      .= Ch3a.o03 by A40,FUNCT_7:32
      .= Ch3.o03 by A40,FUNCT_7:32
      .= Ch2.o03 by A40,FUNCT_7:32
      .= Ch1.o03 by A40,FUNCT_7:32
      .= Ch.o03 by A40,FUNCT_7:32;
      thus Den(In((the connectives of S).3, the carrier' of S), D).<*x,y*>
      = Den(o03,B).<*x,y*> by A44 .= x '&' y by A4;
    end; then
    reconsider D as bool-correct non-empty strict MSAlgebra over S;
    take D,I; thus I = J by A3;
    thus (the connectives of S).n is_of_type {},I by A3;
    thus (the Sorts of D).I = A.I by A3,A4,FUNCT_7:32
    .= INT by A11,FUNCT_7:31;
A46: {} in {{}} & 0-tuples_on INT = {<*>INT} by TARSKI:def 1,FINSEQ_2:94;
    Ch6.o1 = Ch5.o1 by A3,FUNCT_7:32 .= g0 by A39,FUNCT_7:31;
    hence Den(In((the connectives of S).n, the carrier' of S), D).{} = 0;
    Ch6.o2 = g1 by A39,FUNCT_7:31;
    hence Den(In((the connectives of S).(n+1), the carrier' of S), D).{} = 1
    by A46,FUNCOP_1:7;
    let i,j being Integer;
    len <*I*> = 1 & len <*I,I*> = 2 by FINSEQ_1:40,44; then
A48: o3 <> o4 & o3 <> o5 & o3 <> o6 & o3 <> o1 & o3 <> o2 & o3 <> o7 by A3;
A49: Ch6.o3 = Ch5.o3 by A13,A37,FUNCT_7:32
    .= Ch4.o3 by A13,A35,FUNCT_7:32
    .= Ch3a.o3 by A48,FUNCT_7:32
    .= Ch3.o3 by A48,FUNCT_7:32
    .= Ch2.o3 by A48,FUNCT_7:32
    .= Ch1.o3 by A48,FUNCT_7:32 .= f1 by A39,FUNCT_7:31;
    In(o3, the carrier' of S) = o3 & i in INT & -i in INT
    by INT_1:def 2;
    hence Den(In((the connectives of S).(n+2), the carrier' of S), D).<*i*>
    = In(-i,INT) by A7,A49 .= -i;
A50: Ch6.o4 = Ch5.o4 by A19,A37,FUNCT_7:32
    .= Ch4.o4 by A19,A35,FUNCT_7:32
    .= Ch3a.o4 by A3,FUNCT_7:32
    .= Ch3.o4 by A3,FUNCT_7:32
    .= Ch2.o4 by A3,FUNCT_7:32
    .= f2 by A39,FUNCT_7:31;
    In(o4, the carrier' of S) = o4 & i in INT & j in INT & i+j in INT
    by INT_1:def 2;
    hence Den(In((the connectives of S).(n+3), the carrier' of S), D).<*i,j*>
    = In(i+j,INT) by A15,A50 .= i+j;
A51: o5 <> o6 & o5 <> o1 & o5 <> o2 & o5 <> o7 by A3;
A52: Ch6.o5 = Ch5.o5 by A51,FUNCT_7:32
    .= Ch4.o5 by A51,FUNCT_7:32
    .= Ch3a.o5 by A51,FUNCT_7:32
    .= Ch3.o5 by A3,FUNCT_7:32 .= f3 by A39,FUNCT_7:31;
A53: In(o5, the carrier' of S) = o5 & i in INT & j in INT & i*j in INT
    by INT_1:def 2;
    hence Den(In((the connectives of S).(n+4), the carrier' of S), D).<*i,j*>
    = In(i*j,INT) by A21,A52 .= i*j;
    hereby assume
      j <> 0;
A54:   o6 <> o1 & o6 <> o2 & o6 <> o7 by A3;
A55:   Ch6.o6 = Ch5.o6 by A54,FUNCT_7:32
      .= Ch4.o6 by A54,FUNCT_7:32
      .= Ch3a.o6 by A54,FUNCT_7:32 .= fa by A39,FUNCT_7:31;
      In(o6, the carrier' of S) = o6 & i in INT & j in INT & i div j in INT
      by INT_1:def 2;
      hence Den(In((the connectives of S).(n+5), the carrier' of S), D).<*i,j*>
      = In(i div j,INT) by A26,A55
      .= i div j;
    end;
A56: Ch6.o7 = Ch5.o7 by A32,A37,FUNCT_7:32
    .= Ch4.o7 by A32,A35,FUNCT_7:32
    .= f4 by A39,FUNCT_7:31;
    reconsider p = <*i,j*> as Element of 2-tuples_on INT by A53,FINSEQ_2:101;
    dom <*i,j*> = Seg 2 by FINSEQ_1:89; then
    1 in dom <*i,j*> & 2 in dom <*i,j*>; then
A57: p/.1 = p.1 & p/.2 = p.2 & p.1 = i & p.2 = j by FINSEQ_1:44,PARTFUN1:def 6;
A58: In(o7, the carrier' of S) = o7 & i in INT & j in INT &
    (i > j implies IFGT(i,j,FALSE,TRUE) = FALSE) & (i <= j implies
    IFGT(i,j,FALSE,TRUE) = TRUE) & FALSE in BOOLEAN & TRUE in BOOLEAN
    by INT_1:def 2,XXREAL_0:def 11;
    thus Den(In((the connectives of S).(n+6), the carrier' of S), D).<*i,j*>
    = G(p) by A56,A31
    .= IFGT(i,j,FALSE,TRUE) by A58,A57;
  end;

registration
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  cluster (4,1) integer for bool-correct non-empty strict MSAlgebra over S;
  existence by Th49;
end;

theorem
  for S being (4,1) integer bool-correct non empty non void BoolSignature
  for A being (4,1) integer bool-correct non-empty MSAlgebra over S
  for I being integer SortSymbol of S holds
  (the Sorts of A).I = INT & \0(A,I) = 0 & \1(A,I) = 1 &
  for i,j being Integer,a,b being Element of (the Sorts of A).I
  st a = i & b = j
  holds -a = -i & a+b = i+j & a*b = i*j & (j <> 0 implies a div b = i div j) &
  leq(a,b) = IFGT(i,j,FALSE,TRUE) &
  (leq(a,b) = TRUE iff i <= j) & (leq(a,b) = FALSE iff i > j)
  proof
    let S be (4,1) integer bool-correct non empty non void BoolSignature;
    let A be (4,1) integer bool-correct non-empty MSAlgebra over S;
    let I be integer SortSymbol of S;
    set n = 4;
    consider J being SortSymbol of S such that
A1: J = 1 &
    (the connectives of S).n is_of_type {},J & (the Sorts of A).J = INT &
    Den(In((the connectives of S).n, the carrier' of S), A).{} = 0 &
    Den(In((the connectives of S).(n+1), the carrier' of S), A).{} = 1 &
    for i,j being Integer holds
    Den(In((the connectives of S).(n+2), the carrier' of S), A).<*i*> = -i &
    Den(In((the connectives of S).(n+3), the carrier' of S), A).<*i,j*> = i+j &
    Den(In((the connectives of S).(n+4), the carrier' of S), A).<*i,j*> = i*j &
    (j <> 0 implies
    Den(In((the connectives of S).(n+5), the carrier' of S), A).<*i,j*>
    = i div j) &
    Den(In((the connectives of S).(n+6), the carrier' of S), A).<*i,j*>
    = IFGT(i,j,FALSE,TRUE) by Def49;
    thus (the Sorts of A).I = INT by A1,Def39;
    thus \0(A,I) = 0 by A1;
    thus \1(A,I) = 1 by A1;
    let i,j be Integer;
    let a,b be Element of (the Sorts of A).I;
    assume A2: a = i;
    assume A3: b = j;
    thus -a = -i by A1,A2;
    thus a+b = i+j by A1,A2,A3;
    thus a*b = i*j by A1,A2,A3;
    thus j <> 0 implies a div b = i div j by A1,A2,A3;
    thus
A4: leq(a,b) = IFGT(i,j,FALSE,TRUE) by A1,A2,A3;
    thus (leq(a,b) = TRUE iff i <= j) by A4,XXREAL_0:def 11;
    thus leq(a,b) = FALSE implies i > j by A4,XXREAL_0:def 11;
    assume i > j;
    hence leq(a,b) = FALSE by A4,XXREAL_0:def 11;
  end;

registration
  let S be (4,1) integer bool-correct non empty non void BoolSignature;
  let A be (4,1) integer bool-correct non-empty MSAlgebra over S;
  cluster -> integer for Element of (the Sorts of A).1;
  coherence
  proof set n = 4;
    consider I being SortSymbol of S such that
A1: I = 1 &
    (the connectives of S).n is_of_type {},I & (the Sorts of A).I = INT and
    Den(In((the connectives of S).n, the carrier' of S), A).{} = 0 &
    Den(In((the connectives of S).(n+1), the carrier' of S), A).{} = 1 &
    for i,j being Integer holds
    Den(In((the connectives of S).(n+2), the carrier' of S), A).<*i*> = -i &
    Den(In((the connectives of S).(n+3), the carrier' of S), A).<*i,j*> = i+j &
    Den(In((the connectives of S).(n+4), the carrier' of S), A).<*i,j*> = i*j &
    (j <> 0 implies
    Den(In((the connectives of S).(n+5), the carrier' of S), A).<*i,j*>
    = i div j) &
    Den(In((the connectives of S).(n+6), the carrier' of S), A).<*i,j*>
    = IFGT(i,j,FALSE,TRUE) by Def49;
    thus thesis by A1;
  end;
end;

begin :: Algebras with arrays

definition
  let I,N be set;
  let n be Nat;
  let S be ConnectivesSignature;
  attr S is (n,I,N)-array means: Def50:
  len the connectives of S >= n+3 &  :: I=L - type of elements of an array
                                     :: N=K - intgers
                                     :: J - array of I
  ex J,K,L being Element of S st L = I & K = N & J <> L & J <> K &
  (the connectives of S).n is_of_type <*J,K*>, L & ::(a,i) -> a[i]
  (the connectives of S).(n+1) is_of_type <*J,K,L*>, J & :: a[i]:=x
  (the connectives of S).(n+2) is_of_type <*J*>, K & :: length
  (the connectives of S).(n+3) is_of_type <*K,L*>, J; :: init
end;

definition
  let S be non empty non void ConnectivesSignature;
  let I,N be set;
  let n be Nat;
  let A be MSAlgebra over S;
  attr A is (n,I,N)-array means
  ex J,K being Element of S st K = I &
  (the connectives of S).n is_of_type <*J,N*>, K &
  (the Sorts of A).J = ((the Sorts of A).K)^omega &
  (the Sorts of A).N = INT &
  (for a being 0-based finite array of (the Sorts of A).K holds
  (for i being Integer st i in dom a holds
  Den((the connectives of S)/.n,A).<*a,i*> = a.i &
  for x being Element of A,K holds
  Den((the connectives of S)/.(n+1),A).<*a,i,x*> = a+*(i,x)) &
  Den((the connectives of S)/.(n+2),A).<*a*> = card a) &
  for i being Integer, x being Element of A,K st i >= 0 holds
  Den((the connectives of S)/.(n+3),A).<*i,x*> = Segm(i)-->x;
end;

definition
  let B be non empty BoolSignature;
  let C be non empty ConnectivesSignature;
  func B+*C -> strict BoolSignature means: Def52:
  the ManySortedSign of it = B+*C &
  the bool-sort of it = the bool-sort of B &
  the connectives of it = (the connectives of B)^the connectives of C;
  uniqueness;
  existence
  proof
    the carrier of B+*C = (the carrier of B)\/the carrier of C
    by CIRCCOMB:def 2; then
    reconsider b = the bool-sort of B as SortSymbol of B+*C by XBOOLE_0:def 3;
A1: the carrier' of B+*C = (the carrier' of B)\/the carrier' of C
    by CIRCCOMB:def 2;
    rng the connectives of B c= the carrier' of B &
    rng the connectives of C c= the carrier' of C by RELAT_1:def 19; then
    (rng the connectives of B)\/rng the connectives of C c=
    the carrier' of B+*C by A1,XBOOLE_1:13; then
    rng((the connectives of B)^the connectives of C) c=
    the carrier' of B+*C by FINSEQ_1:31; then
    reconsider c = (the connectives of B)^the connectives of C as
    FinSequence of the carrier' of B+*C by FINSEQ_1:def 4;
    take BoolSignature(#
    the carrier of B+*C, the carrier' of B+*C,
    the Arity of B+*C, the ResultSort of B+*C, b, c #);
    thus thesis;
  end;
end;

theorem Th51:
  for B being non empty BoolSignature
  for C being non empty ConnectivesSignature holds
  the carrier of B+*C = (the carrier of B)\/the carrier of C &
  the carrier' of B+*C = (the carrier' of B)\/the carrier' of C &
  the Arity of B+*C = (the Arity of B)+*the Arity of C &
  the ResultSort of B+*C = (the ResultSort of B)+*the ResultSort of C
  proof
    let B be non empty BoolSignature;
    let C be non empty ConnectivesSignature;
    the ManySortedSign of B+*C = (B qua non empty ManySortedSign)+*C by Def52;
    hence thesis by CIRCCOMB:def 2;
  end;

registration
  let B be non empty BoolSignature;
  let C be non empty ConnectivesSignature;
  cluster B+*C -> non empty;
  coherence
  proof
    the carrier of B+*C = (the carrier of B)\/the carrier of C by Th51;
    hence the carrier of B+*C is non empty;
  end;
end;

registration
  let B be non void non empty BoolSignature;
  let C be non empty ConnectivesSignature;
  cluster B+*C -> non void;
  coherence
  proof
    the carrier' of B+*C = (the carrier' of B)\/the carrier' of C by Th51;
    hence the carrier' of B+*C is non empty;
  end;
end;

registration
  let n1,n2 be Nat;
  let B be n1-connectives non empty non void BoolSignature;
  let C be n2-connectives non empty non void ConnectivesSignature;
  cluster B+*C -> n1+n2-connectives;
  coherence
  proof
    thus len the connectives of B+*C
    = len((the connectives of B)^the connectives of C) by Def52
    .= (len the connectives of B)+len the connectives of C by FINSEQ_1:22
    .= n1+len the connectives of C by Def29
    .= n1+n2 by Def29;
  end;
end;

theorem Th52:
  for M,O,N,I being set st I in M & N in M
  ex C being 4-connectives non empty non void strict ConnectivesSignature st
  C is (1,I,N)-array 1-1-connectives &
  M c= the carrier of C & O misses the carrier' of C &
  (the ResultSort of C).((the connectives of C).2) nin M
  proof
    let M,O,N,I be set;
    assume A1: I in M & N in M;
    set X = succ M; set Y = {O, succ O, succ succ O, succ succ succ O};
    reconsider o0 = O, o1 = succ O, o2 = succ succ O,
    o3 = succ succ succ O as Element of Y by ENUMSET1:def 2;
    reconsider m = M, i = I, n = N as Element of X
    by A1,XBOOLE_0:def 3,ORDINAL1:6;
    set A = (o0,o1,o2,o3)-->(<*m,n*>,<*m,n,i*>,<*m*>,<*n,i*>);
A3: o0 in o1 & o1 in o2 & o2 in o3 by ORDINAL1:6; then
A4: o0,o1,o2,o3 are_mutually_distinct by XREGULAR:7; then
    rng A = {<*m,n*>,<*m,n,i*>,<*m*>,<*n,i*>} & <*m,n*> in X* &
    <*m,n,i*> in X* &
    <*m*> in X* & <*n,i*> in X* by FUNCT_4:143,FINSEQ_1:def 11; then
    dom A = Y & rng A c= X* by FUNCT_4:137,QUATERNI:5; then
    reconsider A as Function of Y,X* by FUNCT_2:2;
    set R = (o0,o1,o2,o3)-->(i,m,n,m);
    rng R = {i,m,n,m} by A4,FUNCT_4:143; then
    dom R = Y & rng R c= X by FUNCT_4:137,QUATERNI:5; then
    reconsider R as Function of Y,X by FUNCT_2:2;
    set c = <*o0,o1,o2,o3*>;
    set C = ConnectivesSignature(#X,Y,A,R,c#);
    C is 4-connectives
    by CARD_1:def 7; then
    reconsider C as 4-connectives non empty non void strict
    ConnectivesSignature;
    take C;
    thus C is (1,I,N)-array
    proof
      thus len the connectives of C >= 1+3 by CARD_1:def 7;
      reconsider K = n, L = i, J = m as Element of C;
      take J,K,L;
      thus L = I & K = N;
      thus J <> L & J <> K by A1;
      c.1 = o0 & o0 <> o1 & o0 <> o2 & o0 <> o3 by A3,FINSEQ_4:76,XREGULAR:7;
      hence (the Arity of C).((the connectives of C).1) = <*J,K*> &
      (the ResultSort of C).((the connectives of C).1) = L
         by FUNCT_4:142;
      c.2 = o1 & o2 <> o1 & o1 <> o3 by A3,FINSEQ_4:76;
      hence (the Arity of C).((the connectives of C).(1+1)) = <*J,K,L*> &
      (the ResultSort of C).((the connectives of C).(1+1)) = J
        by FUNCT_4:141;
      c.3 = o2 & o2 <> o3 by A3,FINSEQ_4:76;
      hence (the Arity of C).((the connectives of C).(1+2)) = <*J*> &
      (the ResultSort of C).((the connectives of C).(1+2)) = K
        by FUNCT_4:140;
      c.4 = o3 by FINSEQ_4:76;
      hence (the Arity of C).((the connectives of C).(1+3)) = <*K,L*> &
      (the ResultSort of C).((the connectives of C).(1+3)) = J
        by FUNCT_4:139;
    end;
    thus the connectives of C is one-to-one by A4,Th14;
    thus M c= the carrier of C by XBOOLE_1:7;
    now
      given x being object such that
A5:   x in O & x in the carrier' of C;
      x = o0 or x = o1 or x = o2 or x = o3 by A5,ENUMSET1:def 2;
      hence contradiction by A5,A3,XREGULAR:7,8;
    end;
    hence O misses the carrier' of C by XBOOLE_0:3;
    c.2 = o1 & o2 <> o1 & o1 <> o3 by A3,FINSEQ_4:76;
    then A: (the ResultSort of C).((the connectives of C).(1+1)) = m
            by FUNCT_4:141;
    reconsider nn = (the ResultSort of C).((the connectives of C).2)
      as set; 
    not nn in nn; 
    hence thesis by A;
  end;

registration
  let I,N be set;
  cluster (1,I,N)-array 4-connectives for non empty non void strict
  ConnectivesSignature;
  existence
  proof
    I in {I,N} & N in {I,N} by TARSKI:def 2; then
    ex C being 4-connectives non empty non void strict ConnectivesSignature st
    C is (1,I,N)-array 1-1-connectives &
    {I,N} c= the carrier of C & {} misses the carrier' of C &
    (the ResultSort of C).((the connectives of C).2) nin {I,N} by Th52;
    hence thesis;
  end;
end;

theorem Th53:
  for n,m being Nat st m > 0
  for B being n-connectives non empty non void BoolSignature
  for I,N being set
  for C being non empty non void ConnectivesSignature
  st C is (m,I,N)-array
  holds B+*C is (n+m,I,N)-array
  proof
    let n,m be Nat such that
A1: m > 0;
    let B be n-connectives non empty non void BoolSignature;
    let I,N be set;
    let C be non empty non void ConnectivesSignature;
    assume A2: len the connectives of C >= m+3;
    given J,K,L being Element of C such that
A3: L = I & K = N & J <> L & J <> K &
    (the connectives of C).m is_of_type <*J,K*>, L &
    (the connectives of C).(m+1) is_of_type <*J,K,L*>, J &
    (the connectives of C).(m+2) is_of_type <*J*>, K &
    (the connectives of C).(m+3) is_of_type <*K,L*>, J;
    set S = B+*C;
A4: len the connectives of B = n by Def29;
A5: the connectives of S = (the connectives of B)^the connectives of C
    by Def52; then
A6: len the connectives of S = n+len the connectives of C by A4,FINSEQ_1:22;
    n+(m+3) = n+m+3;
    hence len the connectives of S >= n+m+3 by A2,A6,XREAL_1:6;
    the carrier of S = (the carrier of B)\/the carrier of C by Th51; then
    reconsider J0 = J, K0 = K, L0 = L as Element of S by XBOOLE_0:def 3;
    take J0,K0,L0;
    thus L0 = I & K0 = N & J0 <> L0 & J0 <> K0 by A3;
    m+0 <= m+3 by XREAL_1:6; then
    0+1 <= m & m <= len the connectives of C by A1,A2,XXREAL_0:2,NAT_1:13; then
A7: m in dom the connectives of C by FINSEQ_3:25;
A8: dom the Arity of C = the carrier' of C by FUNCT_2:def 1;
A9: the Arity of S = (the Arity of B)+*the Arity of C by Th51; then
A10: (the Arity of S).((the connectives of C).m) =
    (the Arity of C).((the connectives of C).m)
    by A7,A8,FUNCT_1:102,FUNCT_4:13;
A11: (the connectives of S).(n+m) = (the connectives of C).m
    by A4,A5,A7,FINSEQ_1:def 7;
    hence (the Arity of S).((the connectives of S).(n+m)) = <*J0,K0*>
    by A3,A10;
A12: dom the ResultSort of C = the carrier' of C by FUNCT_2:def 1;
A13: the ResultSort of S = (the ResultSort of B)+*the ResultSort of C by Th51;
    then
    (the ResultSort of S).((the connectives of C).m) =
    (the ResultSort of C).((the connectives of C).m)
    by A7,A12,FUNCT_1:102,FUNCT_4:13;
    hence (the ResultSort of S).((the connectives of S).(n+m)) = L0
    by A3,A11;
    m+1 <= m+3 by XREAL_1:6; then
    1 <= m+1 & m+1 <= len the connectives of C by A2,XXREAL_0:2,NAT_1:11;
    then
A14: m+1 in dom the connectives of C by FINSEQ_3:25;
A15: (the Arity of S).((the connectives of C).(m+1)) =
    (the Arity of C).((the connectives of C).(m+1))
    by A14,A8,A9,FUNCT_1:102,FUNCT_4:13;
    n+m+1 = n+(m+1); then
A16: (the connectives of S).(n+m+1) = (the connectives of C).(m+1)
    by A4,A5,A14,FINSEQ_1:def 7;
    hence (the Arity of S).((the connectives of S).(n+m+1)) = <*J0,K0,L0*>
    by A3,A15;
    (the ResultSort of S).((the connectives of C).(m+1)) =
    (the ResultSort of C).((the connectives of C).(m+1))
    by A14,A12,A13,FUNCT_1:102,FUNCT_4:13;
    hence (the ResultSort of S).((the connectives of S).(n+m+1)) = J0
    by A3,A16;
    m+2 <= m+2+1 by NAT_1:11;
    then m+2 <= len the connectives of C by A2,XXREAL_0:2;
    then
A17: m+2 in dom the connectives of C by NAT_1:12,FINSEQ_3:25;
A18: (the Arity of S).((the connectives of C).(m+2)) =
    (the Arity of C).((the connectives of C).(m+2))
    by A17,A8,A9,FUNCT_1:102,FUNCT_4:13;
    n+m+2 = n+(m+2); then
A19: (the connectives of S).(n+m+2) = (the connectives of C).(m+2)
    by A4,A5,A17,FINSEQ_1:def 7;
    hence (the Arity of S).((the connectives of S).(n+m+2)) = <*J0*>
    by A3,A18;
    (the ResultSort of S).((the connectives of C).(m+2)) =
    (the ResultSort of C).((the connectives of C).(m+2))
    by A17,A12,A13,FUNCT_1:102,FUNCT_4:13;
    hence (the ResultSort of S).((the connectives of S).(n+m+2)) = K0
    by A3,A19;
A20: m+3 in dom the connectives of C by A2,NAT_1:12,FINSEQ_3:25;
A21: (the Arity of S).((the connectives of C).(m+3)) =
    (the Arity of C).((the connectives of C).(m+3))
    by A20,A8,A9,FUNCT_1:102,FUNCT_4:13;
    n+m+3 = n+(m+3); then
A22: (the connectives of S).(n+m+3) = (the connectives of C).(m+3)
    by A4,A5,A20,FINSEQ_1:def 7;
    hence (the Arity of S).((the connectives of S).(n+m+3)) = <*K0,L0*>
    by A3,A21;
    (the ResultSort of S).((the connectives of C).(m+3)) =
    (the ResultSort of C).((the connectives of C).(m+3))
    by A20,A12,A13,FUNCT_1:102,FUNCT_4:13;
    hence (the ResultSort of S).((the connectives of S).(n+m+3)) = J0
    by A3,A22;
  end;

theorem Th54:
  for m being Nat st m > 0
  for s being set
  for B being non empty non void BoolSignature
  for C being non empty non void ConnectivesSignature
  st B is (m,s) integer & the carrier' of B misses the carrier' of C
  holds B+*C is (m,s) integer
  proof
    let m be Nat;
    assume A1: m > 0;
    let s be set;
    let B be non empty non void BoolSignature;
    let C be non empty non void ConnectivesSignature;
    assume A2: len the connectives of B >= m+6;
    given I being Element of B such that
A3: I = s & I <> the bool-sort of B &
    (the connectives of B).m is_of_type {},I &
    (the connectives of B).(m+1) is_of_type {},I &
    (the connectives of B).m <> (the connectives of B).(m+1) &
    (the connectives of B).(m+2) is_of_type <*I*>,I &
    (the connectives of B).(m+3) is_of_type <*I,I*>,I &
    (the connectives of B).(m+4) is_of_type <*I,I*>,I &
    (the connectives of B).(m+5) is_of_type <*I,I*>,I &
    (the connectives of B).(m+3) <> (the connectives of B).(m+4) &
    (the connectives of B).(m+3) <> (the connectives of B).(m+5) &
    (the connectives of B).(m+4) <> (the connectives of B).(m+5) &
    (the connectives of B).(m+6) is_of_type <*I,I*>,the bool-sort of B;
    assume A4: the carrier' of B misses the carrier' of C;
    set S = B+*C;
A5: the connectives of S = (the connectives of B)^the connectives of C
    by Def52; then
    len the connectives of S = (len the connectives of B)+
    len the connectives of C by FINSEQ_1:22;
    hence len the connectives of S >= m+6 by A2,NAT_1:12;
    the carrier of S = (the carrier of B)\/the carrier of C by Th51; then
    reconsider I as Element of S by XBOOLE_0:def 3;
    take I; thus I = s by A3;
    thus I <> the bool-sort of S by A3,Def52;
A6: now
      let i be Nat;
      assume 1 <= i & i <= len the connectives of B; then
A7:   i in dom the connectives of B by FINSEQ_3:25; then
      (the connectives of B).i in the carrier' of B by FUNCT_1:102; then
A8:   (the connectives of B).i nin the carrier' of C by A4,XBOOLE_0:3;
A9:   dom the Arity of C = the carrier' of C &
      dom the ResultSort of C = the carrier' of C by FUNCT_2:def 1;
      the Arity of S = (the Arity of B)+*the Arity of C &
      the ResultSort of S = (the ResultSort of B)+*the ResultSort of C
      by Th51; then
A10:   (the Arity of S).((the connectives of B).i) =
      (the Arity of B).((the connectives of B).i) &
      (the ResultSort of S).((the connectives of B).i) =
      (the ResultSort of B).((the connectives of B).i) by A8,A9,FUNCT_4:11;
      thus
A11:   (the connectives of S).i = (the connectives of B).i
      by A5,A7,FINSEQ_1:def 7;
      let x; let I be Element of B; let J be Element of S;
      assume
A12:   I = J & (the connectives of B).i is_of_type x,I;
      thus (the connectives of S).i is_of_type x,J
      by A10,A12,A11;
    end;
    m+0 <= m+6 by XREAL_1:6; then
A13: 0+1 <= m & m <= len the connectives of B by A1,A2,XXREAL_0:2,NAT_1:13;
    hence (the connectives of S).m is_of_type {},I by A6,A3;
    m+1 <= m+6 by XREAL_1:6; then
A14: 0+1 <= m+1 & m+1 <= len the connectives of B by A2,XXREAL_0:2,NAT_1:11;
    hence (the connectives of S).(m+1) is_of_type {},I by A6,A3;
    (the connectives of S).m = (the connectives of B).m &
    (the connectives of S).(m+1) = (the connectives of B).(m+1) by A13,A14,A6;
    hence (the connectives of S).m <> (the connectives of S).(m+1) by A3;
    m+2 <= m+6 by XREAL_1:6; then
    0+1 <= m+2 & m+2 <= len the connectives of B by A2,XXREAL_0:2,NAT_1:12;
    hence (the connectives of S).(m+2) is_of_type <*I*>,I by A6,A3;
    m+3 <= m+6 by XREAL_1:6; then
A15: 0+1 <= m+3 & m+3 <= len the connectives of B by A2,XXREAL_0:2,NAT_1:12;
    hence (the connectives of S).(m+3) is_of_type <*I,I*>,I by A3,A6;
    m+4 <= m+6 by XREAL_1:6; then
A16: 0+1 <= m+4 & m+4 <= len the connectives of B by A2,XXREAL_0:2,NAT_1:12;
    hence (the connectives of S).(m+4) is_of_type <*I,I*>,I by A3,A6;
    m+5 <= m+6 by XREAL_1:6; then
A17: 0+1 <= m+5 & m+5 <= len the connectives of B by A2,XXREAL_0:2,NAT_1:12;
    hence (the connectives of S).(m+5) is_of_type <*I,I*>,I by A3,A6;
    (the connectives of S).(m+3) = (the connectives of B).(m+3) &
    (the connectives of S).(m+5) = (the connectives of B).(m+5) &
    (the connectives of S).(m+4) = (the connectives of B).(m+4) by A15,A16,A17,
A6;
    hence (the connectives of S).(m+3) <> (the connectives of S).(m+4)&
    (the connectives of S).(m+3) <> (the connectives of S).(m+5)&
    (the connectives of S).(m+4) <> (the connectives of S).(m+5) by A3;
    0+1 <= m+6 & the bool-sort of S = the bool-sort of B by Def52,NAT_1:12;
    hence (the connectives of S).(m+6) is_of_type <*I,I*>,the bool-sort of S
    by A2,A3,A6;
  end;

theorem Th55:
  for B being bool-correct non empty non void BoolSignature
  for C being non empty non void ConnectivesSignature
  st the carrier' of B misses the carrier' of C
  holds B+*C is bool-correct
  proof
    let B be bool-correct non empty non void BoolSignature;
    let C be non empty non void ConnectivesSignature;
    assume A1: the carrier' of B misses the carrier' of C;
    set S = B+*C;
A2: the connectives of S = (the connectives of B)^the connectives of C
    by Def52; then
A3: len the connectives of S = (len the connectives of B)+
    len the connectives of C by FINSEQ_1:22;
A4: len the connectives of B >= 3 by Def30;
    hence len the connectives of S >= 3 by A3,NAT_1:12;
A5: now
      let i be Nat;
      assume 1 <= i & i <= len the connectives of B; then
A6:   i in dom the connectives of B by FINSEQ_3:25; then
      (the connectives of B).i in the carrier' of B by FUNCT_1:102; then
A7:   (the connectives of B).i nin the carrier' of C by A1,XBOOLE_0:3;
A8:   dom the Arity of C = the carrier' of C &
      dom the ResultSort of C = the carrier' of C by FUNCT_2:def 1;
      the Arity of S = (the Arity of B)+*the Arity of C &
      the ResultSort of S = (the ResultSort of B)+*the ResultSort of C
      by Th51; then
A9:   (the Arity of S).((the connectives of B).i) =
      (the Arity of B).((the connectives of B).i) &
      (the ResultSort of S).((the connectives of B).i) =
      (the ResultSort of B).((the connectives of B).i) by A7,A8,FUNCT_4:11;
      thus
A10:   (the connectives of S).i = (the connectives of B).i
      by A2,A6,FINSEQ_1:def 7;
      let x; let I be Element of B; let J be Element of S;
      assume
A11:   I = J & (the connectives of B).i is_of_type x,I;
      thus (the connectives of S).i is_of_type x,J
      by A9,A11,A10;
    end;
A12: the bool-sort of S = the bool-sort of B by Def52;
A13: 1 <= len the connectives of B by A4,XXREAL_0:2;
    (the connectives of B).1 is_of_type {}, the bool-sort of B by Def30;
    hence (the connectives of S).1 is_of_type {}, the bool-sort of S
    by A5,A12,A13;
A14: 2 <= len the connectives of B by A4,XXREAL_0:2;
    (the connectives of B).2 is_of_type <*the bool-sort of B*>,
    the bool-sort of B by Def30;
    hence (the connectives of S).2 is_of_type <*the bool-sort of S*>,
    the bool-sort of S by A5,A12,A14;
    (the connectives of B).3 is_of_type
    <*the bool-sort of B, the bool-sort of B*>, the bool-sort of B by Def30;
    hence thesis by A5,A4,A12;
  end;

definition
  let n be Nat;
  let B be BoolSignature;
  attr B is n array-correct means: Def53:
  (the ResultSort of B).((the connectives of B).(n+1)) <> the bool-sort of B;
end;

registration
  cluster 1-1-connectives 14-connectives (11,1,1)-array 11 array-correct
  (4,1) integer bool-correct non empty non void for strict BoolSignature;
  existence
  proof
    consider S being 1-1-connectives 10-connectives (4,1) integer bool-correct
    non empty non void strict BoolSignature such that
A1: the carrier of S = {0,1} &
    ex I being SortSymbol of S st I = 1 &
    (the connectives of S).4 is_of_type {},I by Th47;
    consider C being 4-connectives non empty non void
    strict ConnectivesSignature such that
A2: C is (1,1,1)-array 1-1-connectives &
    the carrier of S c= the carrier of C &
    the carrier' of S misses the carrier' of C &
    (the ResultSort of C).((the connectives of C).2) nin {0,1}
    by A1,Th52;
    take G = S+*C;
A3: the connectives of G = (the connectives of S)^the connectives of C by Def52
;
A4: the ResultSort of G = (the ResultSort of S)+*the ResultSort of C by Th51;
    rng the connectives of S c= the carrier' of S &
    rng the connectives of C c= the carrier' of C by RELAT_1:def 19;
    hence the connectives of G is one-to-one by A3,A2,XBOOLE_1:64,FINSEQ_3:91;
    thus G is 14-connectives;
    10+1=11 & 1 > 0;
    hence G is (11,1,1)-array by A2,Th53;
    the bool-sort of G = the bool-sort of S by Def52;
    then
A5: the bool-sort of G in {0,1} by A1;
    1+3 <= len the connectives of C by A2;
    then 2 <= len the connectives of C by XXREAL_0:2;
    then 2 in dom the connectives of C &
    len the connectives of S = 10 by Def29,FINSEQ_3:25;
    then (the connectives of C).(1+1) = (the connectives of G).(10+(1+1)) &
    (the connectives of C).(1+1) in the carrier' of C &
    dom the ResultSort of C = the carrier' of C
    by A3,FUNCT_1:102,FINSEQ_1:def 7,FUNCT_2:def 1;
    hence (the ResultSort of G).((the connectives of G).(11+1))
    <> the bool-sort of G by A2,A5,A4,FUNCT_4:13;
    thus G is (4,1) integer by A2,Th54;
    thus G is bool-correct by A2,Th55;
    thus G is non empty non void;
  end;
end;

registration
  let S be (11,1,1)-array non empty non void BoolSignature;
  cluster integer for SortSymbol of S;
  existence
  proof
    consider J,K,L being Element of S such that
A1: L = 1 & K = 1 & J <> L & J <> K &
    (the connectives of S).11 is_of_type <*J,K*>, L &
    (the connectives of S).(11+1) is_of_type <*J,K,L*>, J &
    (the connectives of S).(11+2) is_of_type <*J*>, K &
    (the connectives of S).(11+3) is_of_type <*K,L*>, J by Def50;
    take K; thus K = 1 by A1;
  end;
end;

definition
  let S be (11,1,1)-array non empty non void BoolSignature;
  consider J,K,L being Element of S such that
A1: L = 1 & K = 1 & J <> L & J <> K &
   (the connectives of S).11 is_of_type <*J,K*>, L &
   (the connectives of S).(11+1) is_of_type <*J,K,L*>, J &
   (the connectives of S).(11+2) is_of_type <*J*>, K &
   (the connectives of S).(11+3) is_of_type <*K,L*>, J by Def50;
  func the_array_sort_of S -> SortSymbol of S equals
  (the ResultSort of S).((the connectives of S).12);
  coherence by A1;
end;

definition
  let S be (4,1) integer (11,1,1)-array non empty non void BoolSignature;
  let A be non-empty MSAlgebra over S;
  let a be Element of (the Sorts of A).the_array_sort_of S;
  let I be integer SortSymbol of S;
  consider J,K,L being Element of S such that
A1: L = 1 & K = 1 & J <> L & J <> K &
   (the connectives of S).11 is_of_type <*J,K*>, L &
   (the connectives of S).(11+1) is_of_type <*J,K,L*>, J &
   (the connectives of S).(11+2) is_of_type <*J*>, K &
   (the connectives of S).(11+3) is_of_type <*K,L*>, J by Def50;
A2: I = 1 by Def39;
  func length(a,I) -> Element of (the Sorts of A).I equals
  Den(In((the connectives of S).13, the carrier' of S), A).<*a*>;
  coherence by A1,A2,Th27;
  let i be Element of (the Sorts of A).I;
  func a.(i) -> Element of (the Sorts of A).I equals
  Den(In((the connectives of S).11, the carrier' of S), A).<*a,i*>;
  coherence by A1,A2,Th28;
  let x be Element of (the Sorts of A).I;
  func (a,i)<-x -> Element of (the Sorts of A).the_array_sort_of S equals
  Den(In((the connectives of S).12, the carrier' of S), A).<*a,i,x*>;
  coherence by A1,A2,Th29;
end;

definition
  let S be (4,1) integer (11,1,1)-array non empty non void BoolSignature;
  let A be non-empty MSAlgebra over S;
  let I be integer SortSymbol of S;
  consider J,K,L being Element of S such that
A1: L = 1 & K = 1 & J <> L & J <> K &
   (the connectives of S).11 is_of_type <*J,K*>, L &
   (the connectives of S).(11+1) is_of_type <*J,K,L*>, J &
   (the connectives of S).(11+2) is_of_type <*J*>, K &
   (the connectives of S).(11+3) is_of_type <*K,L*>, J by Def50;
A2: I = 1 by Def39;
  let i be Element of (the Sorts of A).I;
  let x be Element of (the Sorts of A).I;
  func init.array(i,x) -> Element of (the Sorts of A).the_array_sort_of S
  equals
  Den(In((the connectives of S).14, the carrier' of S), A).<*i,x*>;
  coherence by A1,A2,Th28;
end;

registration
  let X be non empty set;
  cluster <*X*> -> non-empty;
  coherence
  proof
    now
      let x be object; assume x in dom <*X*>;
      then x in Seg 1 by FINSEQ_1:89;
      then x = 1 by FINSEQ_1:2,TARSKI:def 1;
      hence <*X*>.x is non empty by FINSEQ_1:40;
    end;
    hence thesis;
  end;
  let Y,Z be non empty set;
  cluster <*X,Y,Z*> -> non-empty;
  coherence;
end;

registration
  let X be functional non empty set;
  let Y,Z be non empty set;
  let f be Element of product <*X,Y,Z*>;
  cluster f.1 -> Relation-like Function-like;
  coherence
  proof
    consider x,y,z being object such that
A1: x in X & y in Y & z in Z & f = <*x,y,z*> by FINSEQ_3:125;
    thus thesis by A1,FINSEQ_1:45;
  end;
end;

registration
  let X be integer-membered non empty set;
  let Y be non empty set;
  let f be Element of product <*X,Y*>;
  cluster f.1 -> integer;
  coherence
  proof
    consider x,y being object such that
A1: x in X & y in Y & f = <*x,y*> by FINSEQ_3:124;
    thus thesis by A1,FINSEQ_1:44;
  end;
end;

theorem Th56:
  for I,N being set
  for S being (1,I,N)-array non empty non void ConnectivesSignature
  for Y being non empty set
  for X being non-empty ManySortedSet of Y st
  ((the ResultSort of S).((the connectives of S).2) nin Y or
  X.((the ResultSort of S).((the connectives of S).2)) = (X.I)^omega) &
  X.N = INT & I in Y
  ex A being non-empty strict MSAlgebra over S st A is (1,I,N)-array &
  the Sorts of A tolerates X
  proof
    let I,N be set;
    let S be (1,I,N)-array non empty non void ConnectivesSignature;
    let A be non empty set;
    let V be non-empty ManySortedSet of A;
    assume A1: (the ResultSort of S).((the connectives of S).2) nin A or
    V.((the ResultSort of S).((the connectives of S).2)) = (V.I)^omega;
    assume A2: V.N = INT & I in A;
    set X0 = the non-empty ManySortedSet of the carrier of S;
    set X = (X0)+*(V|the carrier of S);
    reconsider X as non-empty ManySortedSet of the carrier of S;
A3: len the connectives of S >= 1+3 by Def50;
    consider J,K,L being Element of S such that
A4: L = I & K = N & J <> L & J <> K &
    (the connectives of S).1 is_of_type <*J,K*>, L &
    (the connectives of S).(1+1) is_of_type <*J,K,L*>, J &
    (the connectives of S).(1+2) is_of_type <*J*>, K &
    (the connectives of S).(1+3) is_of_type <*K,L*>, J by Def50;
A5: J nin A or V.J = (V.L)^omega by A1,A4;
    set Z = X+*(N,INT);
    set Y = Z+*(J,(Z.L)^omega);
    set O = the ManySortedFunction of Y# * the Arity of S,
    Y * the ResultSort of S;
A6: dom V = A & dom X = the carrier of S by PARTFUN1:def 2;
    then
A7: dom (V|the carrier of S) = A /\ the carrier of S by RELAT_1:61;
    then I in dom (V|the carrier of S) by A2,A4,XBOOLE_0:def 4;
    then
A8: X.I = (V|the carrier of S).I by FUNCT_4:13 .= V.I by A4,FUNCT_1:49;
    N in dom V by A2,FUNCT_1:def 2;
    then N in dom (V|the carrier of S) by A6,A7,A4,XBOOLE_0:def 4;
    then
A9: X.N = (V|the carrier of S).N by FUNCT_4:13 .= V.N by A4,FUNCT_1:49;
    deffunc F(Function) = IFIN($1.2,proj1($1.1),$1..(1,$1.2),
    the Element of Y.L);
    N = I or N <> I;
    then
A10: Z.I = X.I or Z.I = INT & X.I = INT by A2,A4,A9,A6,FUNCT_7:31,32;
    consider f being Function such that
A11: dom f = product <*Y.J,Y.K*> &
    for x being Element of product <*Y.J,Y.K*> holds f.x = F(x)
    from FUNCT_1:sch 4;
A12: dom Y = the carrier of S & dom Z = the carrier of S &
    dom X = the carrier of S by PARTFUN1:def 2;
    then
A13: Y.L = Z.L & Z.K = INT by A4,FUNCT_7:31,32;
    then
A14: Y.J = (Y.L)^omega & Y.K = INT by A12,A4,FUNCT_7:31,32;
    rng f c= Y.L
    proof
      let x be object; assume x in rng f;
      then consider y being object such that
A15:   y in dom f & x = f.y by FUNCT_1:def 3;
      reconsider y as Element of product <*Y.J,Y.K*> by A11,A15;
A16:   x = F(y) by A11,A15;
      consider a,b being object such that
A17:   a in Y.J & b in Y.K & y = <*a,b*> by FINSEQ_3:124;
      reconsider a as Element of (Y.L)^omega by A13,A17,A12,FUNCT_7:31;
A18:   a = y.1 & b = y.2 & a is XFinSequence of Y.L by A17,FINSEQ_1:44;
      per cases;
      suppose
A19:     y.2 in proj1(y.1);
        then x = y..(1,y.2) by A16,MATRIX_7:def 1 .= a.b by A18,Th5;
        hence thesis by A18,A19,FUNCT_1:102;
      end;
      suppose y.2 nin proj1(y.1);
        then x = the Element of Y.L by A16,MATRIX_7:def 1;
        hence thesis;
      end;
    end;
    then reconsider f as Function of product <*Y.J,Y.K*>, Y.L by A11,FUNCT_2:2;
    1 <= len the connectives of S by A3,XXREAL_0:2;
    then
A20: 1 in dom the connectives of S by FINSEQ_3:25;
    then reconsider o1 = (the connectives of S).1 as OperSymbol of S
    by FUNCT_1:102;
A21: (the Arity of S).o1 = <*J,K*> & (the ResultSort of S).o1 = L by A4;
    <*J,K*> in (the carrier of S)* by FINSEQ_1:def 11;
    then Y#.((the Arity of S).o1) = product (Y*<*J,K*>) &
    Y*<*J,K*> = <*Y.J,Y.K*> &
    Y.((the ResultSort of S).o1) = Y.L by A21,A12,FINSEQ_2:def 5,125;
    then (Y#*(the Arity of S)).o1 = product <*Y.J,Y.K*> &
    (Y*(the ResultSort of S)).o1 = Y.L by FUNCT_2:15;
    then reconsider f as Function of (Y#*(the Arity of S)).o1,
    (Y*(the ResultSort of S)).o1;
    deffunc G(Element of product <*(Y.L)^omega,Y.K,Y.L*>) = $1.1+*($1.2,$1.3);
    consider g being Function such that
A22: dom g = product <*(Y.L)^omega,Y.K,Y.L*> &
    for x being Element of product <*(Y.L)^omega,Y.K,Y.L*> holds g.x = G(x)
    from FUNCT_1:sch 4;
    rng g c= Y.J
    proof
      let x be object; assume x in rng g;
      then consider y being object such that
A23:   y in dom g & x = g.y by FUNCT_1:def 3;
      reconsider y as Element of product <*(Y.L)^omega,Y.K,Y.L*> by A22,A23;
      consider a,b,c being object such that
A24:   a in (Y.L)^omega & b in Y.K & c in Y.L & y = <*a,b,c*> by FINSEQ_3:125;
      reconsider a as XFinSequence of Y.L by A24;
      reconsider c as Element of Y.L by A24;
A25:   a = y.1 & b = y.2 & c = y.3 by A24,FINSEQ_1:45;
A26:    x = a+*(b,c) by A25,A22,A23;
      x is XFinSequence of Y.L by A26;
      then x in (Y.L)^omega by AFINSQ_1:def 7;
      hence thesis by A14;
    end;
    then reconsider g as Function of product <*Y.J,Y.K,Y.L*>, Y.J
    by A14,A22,FUNCT_2:2;
    2 <= len the connectives of S by A3,XXREAL_0:2;
    then
A27: 2 in dom the connectives of S by FINSEQ_3:25;
    then reconsider o2 = (the connectives of S).2 as OperSymbol of S
    by FUNCT_1:102;
A28: (the Arity of S).o2 = <*J,K,L*> & (the ResultSort of S).o2 = J
    by A4;
    <*J,K,L*> in (the carrier of S)* by FINSEQ_1:def 11;
    then Y#.((the Arity of S).o2) = product (Y*<*J,K,L*>) &
    Y*<*J,K,L*> = <*Y.J,Y.K,Y.L*> &
    Y.((the ResultSort of S).o2) = Y.J by A28,A12,FINSEQ_2:def 5,126;
    then (Y#*(the Arity of S)).o2 = product <*Y.J,Y.K,Y.L*> &
    (Y*(the ResultSort of S)).o2 = Y.J by FUNCT_2:15;
    then reconsider g as Function of (Y#*(the Arity of S)).o2,
    (Y*(the ResultSort of S)).o2;
    deffunc H(Element of product <*(Y.L)^omega *>) = card ($1.1);
    consider h being Function such that
A29: dom h = product <*(Y.L)^omega *> &
    for x being Element of product <*(Y.L)^omega *> holds h.x = H(x)
    from FUNCT_1:sch 4;
    rng h c= Y.K
    proof
      let x be object; assume x in rng h;
      then consider y being object such that
A30:   y in dom h & x = h.y by FUNCT_1:def 3;
      reconsider y as Element of product <*(Y.L)^omega*> by A29,A30;
A31:   x = H(y) by A29,A30;
      consider a being object such that
A32:   a in (Y.L)^omega & y = <*a*> by FINSEQ_3:123;
      reconsider a as 0-based finite array of Y.L by A32;
      x = len a by A31,A32,FINSEQ_1:40;
      hence thesis by A14,INT_1:def 2;
    end;
    then reconsider h as Function of product <*Y.J*>, Y.K by A14,A29,FUNCT_2:2;
    3 <= len the connectives of S by A3,XXREAL_0:2; then
A33: 3 in dom the connectives of S by FINSEQ_3:25;
    then reconsider o3 = (the connectives of S).3 as OperSymbol of S
    by FUNCT_1:102;
A34: (the Arity of S).o3 = <*J*> & (the ResultSort of S).o3 = K by A4;
    <*J*> in (the carrier of S)* by FINSEQ_1:def 11;
    then Y#.((the Arity of S).o3) = product (Y*<*J*>) & Y*<*J*> = <*Y.J*> &
    Y.((the ResultSort of S).o3) = Y.K by A34,A12,FINSEQ_2:def 5,FINSEQ_2:34;
    then (Y#*(the Arity of S)).o3 = product <*Y.J*> &
    (Y*(the ResultSort of S)).o3 = Y.K by FUNCT_2:15;
    then reconsider h as Function of (Y#*(the Arity of S)).o3,
    (Y*(the ResultSort of S)).o3;
    deffunc H(Element of product <*INT,Y.L*>)
    = IFGT(0,$1.1,{},($1.1)-->($1.2));
    consider j being Function such that
A35: dom j = product <*INT,Y.L*> &
    for x being Element of product <*INT,Y.L*> holds j.x = H(x)
    from FUNCT_1:sch 4;
    rng j c= Y.J
    proof
      let x be object; assume x in rng j;
      then consider y being object such that
A36:   y in dom j & x = j.y by FUNCT_1:def 3;
      reconsider y as Element of product <*Y.K,Y.L*>
      by A35,A36,A13,A4,FUNCT_7:32;
      consider b,c being object such that
A37:   b in Y.K & c in Y.L & y = <*b,c*> by FINSEQ_3:124;
      reconsider c as Element of Y.L by A37;
      reconsider b as Integer by A37,A14;
A38:  b = y.1 & c = y.2 by A37,FINSEQ_1:44;
      x = IFGT(0,b,{},Segm(b)-->c) by A38,A35,A36;
      then x = {} or b >= 0 & x = Segm(b)-->c &
      (b is non negative implies b is Nat) by XXREAL_0:def 11;
      then x = <%>(Y.L) or ex b being non negative Nat st x = b-->c;
      hence thesis by A14,AFINSQ_1:def 7;
    end;
    then reconsider j as Function of product <*Y.K,Y.L*>, Y.J
    by A14,A35,FUNCT_2:2;
A39: 4 in dom the connectives of S by A3,FINSEQ_3:25;
    then reconsider o4 = (the connectives of S).4 as OperSymbol of S
    by FUNCT_1:102;
A40: (the Arity of S).o4 = <*K,L*> & (the ResultSort of S).o4 = J
    by A4;
    <*K,L*> in (the carrier of S)* by FINSEQ_1:def 11;
    then Y#.((the Arity of S).o4) = product (Y*<*K,L*>) &
    Y*<*K,L*> = <*Y.K,Y.L*> &
    Y.((the ResultSort of S).o4) = Y.J by A40,A12,FINSEQ_2:def 5,125;
    then (Y#*(the Arity of S)).o4 = product <*Y.K,Y.L*> &
    (Y*(the ResultSort of S)).o4 = Y.J by FUNCT_2:15;
    then reconsider j as Function of (Y#*(the Arity of S)).o4,
    (Y*(the ResultSort of S)).o4;
    set U = O+*(o1,f)+*(o2,g)+*(o3,h)+*(o4,j);
A41: dom O = the carrier' of S & dom (O+*(o1,f)) = the carrier' of S &
    dom (O+*(o1,f)+*(o2,g)) = the carrier' of S & dom U = the carrier' of S &
    dom (O+*(o1,f)+*(o2,g)+*(o3,h)) = the carrier' of S by PARTFUN1:def 2;
    card ((the Arity of S).o1) = 2 & card ((the Arity of S).o2) = 3 &
    card ((the Arity of S).o3) = 1 & card ((the Arity of S).o4) = 2
    by A21,A28,A34,A40,CARD_1:def 7;
    then
A42: o1 <> o2 & o2 <> o3 & o3 <> o1 & o1 <> o4 & o2 <> o4 & o3 <> o4 by A4;
A43: U.o1 = (O+*(o1,f)+*(o2,g)+*(o3,h)).o1 by A42,FUNCT_7:32
    .= (O+*(o1,f)+*(o2,g)).o1 by A42,FUNCT_7:32
    .= (O+*(o1,f)).o1 by A42,FUNCT_7:32 .= f by A41,FUNCT_7:31;
A44: U.o2 = (O+*(o1,f)+*(o2,g)+*(o3,h)).o2 by A42,FUNCT_7:32
    .= (O+*(o1,f)+*(o2,g)).o2 by A42,FUNCT_7:32 .= g by A41,FUNCT_7:31;
A45: U.o3 = (O+*(o1,f)+*(o2,g)+*(o3,h)).o3 by A42,FUNCT_7:32
    .= h by A41,FUNCT_7:31;
A46: U.o4 = j by A41,FUNCT_7:31;
    U is ManySortedFunction of Y#*the Arity of S, Y*the ResultSort of S
    proof
      let x be object; assume x in the carrier' of S;
      then reconsider o = x as OperSymbol of S;
      per cases;
      suppose o = o1 or o = o2 or o = o3 or o = o4;
        hence U.x is Function of (Y#*the Arity of S).x,
        (Y*the ResultSort of S).x
        by A43,A44,A45,A41,FUNCT_7:31;
      end;
      suppose
A47:     o <> o1 & o <> o2 & o <> o3 & o <> o4;
        U.o = (O+*(o1,f)+*(o2,g)+*(o3,h)).o by A47,FUNCT_7:32
        .= (O+*(o1,f)+*(o2,g)).o by A47,FUNCT_7:32
        .= (O+*(o1,f)).o by A47,FUNCT_7:32 .= O.o by A47,FUNCT_7:32;
        hence U.x is Function of (Y#*the Arity of S).x,
        (Y*the ResultSort of S).x;
      end;
    end;
    then reconsider U as ManySortedFunction of Y#*the Arity of S,
    Y*the ResultSort of S;
    set A = MSAlgebra(#Y, U#);
    A is non-empty;
    then reconsider A as non-empty strict MSAlgebra over S;
    take A;
    thus A is (1,I,N)-array
    proof
    take J,L; thus L = I by A4;
    thus (the connectives of S).1 is_of_type <*J,N*>, L by A4;
    thus (the Sorts of A).J = ((the Sorts of A).L)^omega &
    (the Sorts of A).N = INT by A4,A13,A12,FUNCT_7:31,32;
    hereby
      let a be 0-based finite array of (the Sorts of A).L;
A48:   a in (Y.L)^omega by AFINSQ_1:def 7;
      hereby let i be Integer; assume
A49:     i in dom a;
A50:     i in Y.N by A4,A14,INT_1:def 2;
        then
A51:     <*a,i*> in product <*(Y.L)^omega,Y.N*> by A48,FINSEQ_3:124;
A52:     <*a,i*>.1 = a & <*a,i*>.2 = i by FINSEQ_1:44;
        (the connectives of S)/.1 = o1 by A20,PARTFUN1:def 6;
        hence Den((the connectives of S)/.1,A).<*a,i*> = F(<*a,i*>)
        by A4,A11,A14,A43,A51
        .= <*a,i*>..(1,i) by A52,A49,MATRIX_7:def 1 .= a.i by A52,Th5;
        let x be Element of A,L;
A53:     <*a,i,x*> in product <*(Y.L)^omega,Y.N,Y.L*> by A48,A50,FINSEQ_3:125;
A54:     <*a,i,x*>.1 = a & <*a,i,x*>.2 = i & <*a,i,x*>.3 = x by FINSEQ_1:45;
        (the connectives of S)/.2 = o2 by A27,PARTFUN1:def 6;
        hence Den((the connectives of S)/.(1+1),A).<*a,i,x*> = a+*(i,x)
        by A4,A22,A44,A53,A54;
      end;
A55:   <*a*> in product <*(Y.L)^omega*> by A48,FINSEQ_3:123;
A56:   <*a*>.1 = a by FINSEQ_1:40;
      (the connectives of S)/.3 = o3 by A33,PARTFUN1:def 6;
      hence Den((the connectives of S)/.(1+2),A).<*a*> = card a by A29,A45,A55,
A56;
    end;
    let i be Integer;
    let x be Element of A,L;
    assume A57: i >= 0;
A58: o4 = (the connectives of S)/.(1+3) by A39,PARTFUN1:def 6;
    i in INT & x in Y.L by INT_1:def 2;
    then <*i,x*> in product <*INT,Y.L*> & <*i,x*>.1 = i & <*i,x*>.2 = x
    by FINSEQ_1:44,FINSEQ_3:124;
    hence Den((the connectives of S)/.(1+3),A).<*i,x*>
    = IFGT(0,i,{},Segm(i)-->x) by A35,A46,A58
    .= Segm(i)-->x by A57,XXREAL_0:def 11;
    end;
    thus the Sorts of A tolerates V
    proof
      let x be object; assume
A59:   x in dom (the Sorts of A)/\dom V;
      then x in (the carrier of S)/\dom V by PARTFUN1:def 2;
      then
A60:   x in dom(V|the carrier of S) by RELAT_1:61;
      then
A61:   X.x = (V|the carrier of S).x by FUNCT_4:13 .= V.x by A60,FUNCT_1:47;
      per cases;
      suppose x <> N & x <> J;
        then Z.x = X.x & Y.x = Z.x by FUNCT_7:32;
        hence (the Sorts of A).x = V.x by A61;
      end;
      suppose x = N;
        hence (the Sorts of A).x = V.x by A2,A13,A4,FUNCT_7:32;
      end;
      suppose
A62:     x = J;
        then x nin dom V or x in dom V & V.x = (V.L)^omega
        by A5,PARTFUN1:def 2;
        hence (the Sorts of A).x = V.x
        by A59,A10,A62,A12,A4,FUNCT_7:31,XBOOLE_0:def 4,A8;
      end;
    end;
  end;

registration
  let I,N be set;
  let S be (1,I,N)-array non empty non void ConnectivesSignature;
  cluster (1,I,N)-array for non-empty strict MSAlgebra over S;
  existence
  proof
    set Y = {I,N};
    set V = (I,N)-->(INT,INT);
    consider J,K,L being Element of S such that
A1: L = I & K = N & J <> L & J <> K &
    (the connectives of S).1 is_of_type <*J,K*>, L &
    (the connectives of S).(1+1) is_of_type <*J,K,L*>, J &
    (the connectives of S).(1+2) is_of_type <*J*>, K &
    (the connectives of S).(1+3) is_of_type <*K,L*>, J by Def50;
A2: (the ResultSort of S).((the connectives of S).2) nin Y by A1,TARSKI:def 2;
    dom V = Y & V = (I.-->INT)+*(N.-->INT) by FUNCT_4:62,def 4;
    then reconsider V as non-empty ManySortedSet of Y
    by RELAT_1:def 18,PARTFUN1:def 2;
    V.N = INT & I in Y by TARSKI:def 2,FUNCT_4:63;
    then consider A being non-empty strict MSAlgebra over S such that
A3: A is (1,I,N)-array & the Sorts of A tolerates V by A2,Th56;
    take A; thus thesis by A3;
  end;
end;

definition
  let S1 be non empty BoolSignature;
  let S2 be non empty ConnectivesSignature;
  let A1 be non-empty MSAlgebra over S1;
  let A2 be non-empty MSAlgebra over S2;
  func (S1,A1) +* A2 -> strict non-empty MSAlgebra over S1+*S2 equals
  A1 +* A2;
  coherence
  proof
    the ManySortedSign of S1+*S2 = (S1 qua non empty ManySortedSign)+*S2
    by Def52; then
    reconsider A = A1+*A2 as MSAlgebra over S1+*S2;
    A is non-empty; then
    reconsider A = A1+*A2 as non-empty MSAlgebra over S1+*S2;
    A = MSAlgebra(#the Sorts of A, the Charact of A#);
    hence thesis;
  end;
end;

theorem Th57:
  for B being bool-correct non empty non void BoolSignature
  for A1 being bool-correct non-empty MSAlgebra over B
  for C being non empty non void ConnectivesSignature
  st the carrier' of B misses the carrier' of C
  for A2 being non-empty MSAlgebra over C
  st the Sorts of A1 tolerates the Sorts of A2
  holds (B,A1)+*A2 is bool-correct
  proof
    let B be bool-correct non empty non void BoolSignature;
    let A1 be bool-correct non-empty MSAlgebra over B;
    let C be non empty non void ConnectivesSignature;
    assume A1: the carrier' of B misses the carrier' of C;
    let A2 be non-empty MSAlgebra over C;
    assume A2: the Sorts of A1 tolerates the Sorts of A2;
    set S = B+*C;
    set A = (B,A1)+*A2;
A3: (the Sorts of A1).the bool-sort of B = BOOLEAN &
    Den(In((the connectives of B).1, the carrier' of B), A1).{} = TRUE &
    for x,y be boolean object holds
    Den(In((the connectives of B).2, the carrier' of B), A1).<*x*> = 'not' x &
    Den(In((the connectives of B).3, the carrier' of B), A1).<*x,y*> = x '&' y
    by Def31;
A4: dom the Sorts of A1 = the carrier of B by PARTFUN1:def 2;
A5: the Sorts of A = (the Sorts of A1)+*the Sorts of A2 &
    the Charact of A = (the Charact of A1)+*the Charact of A2
    by A2,CIRCCOMB:def 4;
    the bool-sort of S = the bool-sort of B by Def52;
    hence (the Sorts of A).the bool-sort of S = BOOLEAN
    by A2,A3,A4,A5,FUNCT_4:15;
A6: the connectives of S = (the connectives of B)^the connectives of C by Def52
;
A7: len the connectives of B >= 3 by Def30; then
    len the connectives of B >= 2 & len the connectives of B >= 1
    by XXREAL_0:2; then
A8: 1 in dom the connectives of B & 2 in dom the connectives of B &
    3 in dom the connectives of B by A7,FINSEQ_3:25;
A9: dom the connectives of B c= dom the connectives of S
    by A6,FINSEQ_1:26;
A10: dom the Charact of A1 = the carrier' of B &
    dom the Charact of A2 = the carrier' of C by PARTFUN1:def 2;
A11: (the connectives of S).1 in the carrier' of S &
    (the connectives of S).2 in the carrier' of S &
    (the connectives of S).3 in the carrier' of S &
    (the connectives of B).1 in the carrier' of B &
    (the connectives of B).2 in the carrier' of B &
    (the connectives of B).3 in the carrier' of B by A9,A8,FUNCT_1:102;
    (the connectives of S).1 = (the connectives of B).1 &
    (the connectives of S).2 = (the connectives of B).2 &
    (the connectives of S).3 = (the connectives of B).3
    by A6,A8,FINSEQ_1:def 7; then
    (the connectives of S).1
    = In((the connectives of B).1, the carrier' of B) &
    (the connectives of S).2
    = In((the connectives of B).2, the carrier' of B) &
    (the connectives of S).3
    = In((the connectives of B).3, the carrier' of B)
    by A8,FUNCT_1:102,SUBSET_1:def 8; then
    In((the connectives of S).1, the carrier' of S)
    = In((the connectives of B).1, the carrier' of B) &
    In((the connectives of S).2, the carrier' of S)
    = In((the connectives of B).2, the carrier' of B) &
    In((the connectives of S).3, the carrier' of S)
    = In((the connectives of B).3, the carrier' of B)
    by A11,SUBSET_1:def 8; then
    Den(In((the connectives of S).1, the carrier' of S),A)
    = Den(In((the connectives of B).1, the carrier' of B),A1) &
    Den(In((the connectives of S).2, the carrier' of S),A)
    = Den(In((the connectives of B).2, the carrier' of B),A1) &
    Den(In((the connectives of S).3, the carrier' of S),A)
    = Den(In((the connectives of B).3, the carrier' of B),A1)
    by A1,A5,A10,FUNCT_4:16;
    hence
    Den(In((the connectives of S).1, the carrier' of S), A).{} = TRUE &
    for x,y be boolean object holds
    Den(In((the connectives of S).2, the carrier' of S), A).<*x*> = 'not' x &
    Den(In((the connectives of S).3, the carrier' of S), A).<*x,y*> = x '&' y
    by Def31;
  end;

theorem Th58:
  for n being Nat, I being set st n >= 4
  for B being bool-correct non empty non void BoolSignature
  st B is (n,I) integer
  for A1 being bool-correct non-empty MSAlgebra over B
  st A1 is (n,I) integer
  for C being non empty non void ConnectivesSignature
  st the carrier' of B misses the carrier' of C
  for A2 being non-empty MSAlgebra over C
  st the Sorts of A1 tolerates the Sorts of A2
  for S being bool-correct non empty non void BoolSignature
  st the BoolSignature of S = B+*C
  for A being bool-correct non-empty MSAlgebra over S
  st A = (B,A1)+*A2 holds A is (n,I) integer
  proof
    let n be Nat, s be set such that
A1: n >= 4;
    let B be bool-correct non empty non void BoolSignature;
    assume A2: B is (n,s) integer;
    let A1 be bool-correct non-empty MSAlgebra over B;
    given I being SortSymbol of B such that
A3: I = s &
    (the connectives of B).n is_of_type {},I & (the Sorts of A1).I = INT &
    Den(In((the connectives of B).n, the carrier' of B), A1).{} = 0 &
    Den(In((the connectives of B).(n+1), the carrier' of B), A1).{} = 1 &
    for i,j being Integer holds
    Den(In((the connectives of B).(n+2), the carrier' of B), A1).<*i*> = -i &
    Den(In((the connectives of B).(n+3), the carrier' of B), A1).<*i,j*>
    = i+j &
    Den(In((the connectives of B).(n+4), the carrier' of B), A1).<*i,j*>
    = i*j &
    (j <> 0 implies
    Den(In((the connectives of B).(n+5), the carrier' of B), A1).<*i,j*>
    = i div j) &
    Den(In((the connectives of B).(n+6), the carrier' of B), A1).<*i,j*>
    = IFGT(i,j,FALSE,TRUE);
    let C be non empty non void ConnectivesSignature;
    assume A4: the carrier' of B misses the carrier' of C;
    let A2 be non-empty MSAlgebra over C;
    assume A5: the Sorts of A1 tolerates the Sorts of A2;
    let S be bool-correct non empty non void BoolSignature;
    assume A6: the BoolSignature of S = B+*C;
    let A be bool-correct non-empty MSAlgebra over S;
    assume A7: A = (B,A1)+*A2;
    the carrier of S = (the carrier of B)\/the carrier of C by A6,Th51; then
    reconsider I as SortSymbol of S by XBOOLE_0:def 3;
    take I; thus I = s by A3;
A8: dom the Sorts of A1 = the carrier of B by PARTFUN1:def 2;
A9: the Sorts of A = (the Sorts of A1)+*the Sorts of A2 &
    the Charact of A = (the Charact of A1)+*the Charact of A2
    by A5,A7,CIRCCOMB:def 4;
A10: len the connectives of B >= n+6 & n <= n+6 by A2,NAT_1:12;
    then 1 <= n & n <= len the connectives of B by A1,XXREAL_0:2;
    then
A11: n in dom the connectives of B &
    the connectives of S = (the connectives of B)^the connectives of C
    by A6,Def52,FINSEQ_3:25;
    then
A12: (the connectives of S).n = (the connectives of B).n &
    (the connectives of B).n in the carrier' of B
    by FUNCT_1:102,FINSEQ_1:def 7;
A13: dom the ResultSort of B = the carrier' of B &
    dom the ResultSort of C = the carrier' of C &
    dom the Arity of B = the carrier' of B &
    dom the Arity of C = the carrier' of C by FUNCT_2:def 1;
    the ResultSort of S = (the ResultSort of B)+*the ResultSort of C &
    the Arity of S = (the Arity of B)+*the Arity of C by A6,Th51;
    then (the ResultSort of S).((the connectives of S).n) =
    (the ResultSort of B).((the connectives of B).n) &
    (the Arity of S).((the connectives of S).n) =
    (the Arity of B).((the connectives of B).n) by A4,A12,A13,FUNCT_4:16;
    hence (the Arity of S).((the connectives of S).n) = {} &
    (the ResultSort of S).((the connectives of S).n) = I by A3;
    thus (the Sorts of A).I = INT by A8,A9,A3,A5,FUNCT_4:15;
A14: now
      let i be Nat;
      assume i >= 4 & i <= n+6;
      then 1 <= i & i <= len the connectives of B by A10,XXREAL_0:2;
      then
A15:   i in dom the connectives of B by FINSEQ_3:25;
      then
A16:   (the connectives of B).i in the carrier' of B &
      (the connectives of B).i = (the connectives of S).i
      by A11,FUNCT_1:102,FINSEQ_1:def 7;
      the carrier' of S = (the carrier' of B)\/the carrier' of C
      by A6,Th51;
      then (the connectives of S).i in the carrier' of S by A16,XBOOLE_0:def 3;
      then
A17:   In((the connectives of B).i, the carrier' of B) =
      (the connectives of B).i &
      In((the connectives of S).i, the carrier' of S) =
      (the connectives of S).i by A15,FUNCT_1:102,SUBSET_1:def 8;
      dom the Charact of A1 = the carrier' of B &
      dom the Charact of A2 = the carrier' of C by PARTFUN1:def 2;
      hence Den(In((the connectives of S).i, the carrier' of S), A)
      = Den(In((the connectives of B).i, the carrier' of B), A1)
      by A9,A16,A17,A4,FUNCT_4:16;
    end;
    n <= n+6 by NAT_1:11;
    hence Den(In((the connectives of S).n, the carrier' of S), A).{} = 0
    by A1,A3,A14;
    n+1 >= 4 & n+1 <= n+6 by A1,NAT_1:12,XREAL_1:6;
    hence Den(In((the connectives of S).(n+1), the carrier' of S), A).{} = 1
    by A3,A14;
    let i,j be Integer;
    n+2 >= 4 & n+2 <= n+6 by A1,NAT_1:12,XREAL_1:6;
    hence Den(In((the connectives of S).(n+2), the carrier' of S), A).<*i*>
    = Den(In((the connectives of B).(n+2), the carrier' of B), A1).<*i*> by A14
    .= -i by A3;
    n+3 >= 4 & n+3 <= n+6 by A1,NAT_1:12,XREAL_1:6;
    hence Den(In((the connectives of S).(n+3), the carrier' of S), A).<*i,j*>
    = Den(In((the connectives of B).(n+3), the carrier' of B), A1).<*i,j*>
    by A14
    .= i+j by A3;
    n+4 >= 4 & n+4 <= n+6 by NAT_1:12,XREAL_1:6;
    hence Den(In((the connectives of S).(n+4), the carrier' of S), A).<*i,j*>
    = Den(In((the connectives of B).(n+4), the carrier' of B), A1).<*i,j*>
    by A14
    .= i*j by A3;
    hereby assume
A18:   j <> 0;
      n+5 >= 4 & n+5 <= n+6 by NAT_1:12,XREAL_1:6;
      hence Den(In((the connectives of S).(n+5), the carrier' of S), A).<*i,j*>
      = Den(In((the connectives of B).(n+5), the carrier' of B), A1).<*i,j*>
      by A14
      .= i div j by A18,A3;
    end;
    n+6 >= 4 by NAT_1:12;
    hence Den(In((the connectives of S).(n+6), the carrier' of S), A).<*i,j*>
    = Den(In((the connectives of B).(n+6), the carrier' of B), A1).<*i,j*>
    by A14
    .= IFGT(i,j,FALSE,TRUE) by A3;
  end;

theorem Th59:
  for n,m being Nat, s,r being set st n >= 1 & m >= 1
  for B being m-connectives non empty non void BoolSignature
  for A1 being non-empty MSAlgebra over B
  for C being non empty non void ConnectivesSignature
  st C is (n,s,r)-array
  for A2 being non-empty MSAlgebra over C
  st the Sorts of A1 tolerates the Sorts of A2 & A2 is (n,s,r)-array
  for S being non empty non void BoolSignature
  st the BoolSignature of S = B+*C
  for A being non-empty MSAlgebra over S
  st A = (B,A1)+*A2 holds A is (m+n,s,r)-array
  proof
    let n,m be Nat;
    let s,r be set;
    assume A1: n >= 1 & m >= 1;
    let B be m-connectives non empty non void BoolSignature;
    let A1 be non-empty MSAlgebra over B;
    let C be non empty non void ConnectivesSignature;
    assume A2: C is (n,s,r)-array;
    then
A3: len the connectives of C >= n+3 &
    ex J,K,L being Element of C st L = s & K = r & J <> L & J <> K &
    (the connectives of C).n is_of_type <*J,K*>, L &
    (the connectives of C).(n+1) is_of_type <*J,K,L*>, J &
    (the connectives of C).(n+2) is_of_type <*J*>, K &
    (the connectives of C).(n+3) is_of_type <*K,L*>, J;
    let A2 be non-empty MSAlgebra over C;
    assume A4: the Sorts of A1 tolerates the Sorts of A2;
    given J,K being Element of C such that
A5: K = s &
    (the connectives of C).n is_of_type <*J,r*>, K &
    (the Sorts of A2).J = ((the Sorts of A2).K)^omega &
    (the Sorts of A2).r = INT &
    (for a being 0 -based finite array of (the Sorts of A2).K holds
    (for i being Integer st i in dom a holds
    Den((the connectives of C)/.n,A2).<*a,i*> = a.i &
    for x being Element of A2,K holds
    Den((the connectives of C)/.(n+1),A2).<*a,i,x*> = a+*(i,x)) &
    Den((the connectives of C)/.(n+2),A2).<*a*> = card a) &
    for i being Integer, x being Element of A2,K st i >= 0
    holds Den((the connectives of C)/.(n+3),A2).<*i,x*> = Segm(i)-->x;
    let S be non empty non void BoolSignature;
    assume A6: the BoolSignature of S = B+*C;
    set k = K;
    the carrier of S = (the carrier of B)\/the carrier of C by A6,Th51;
    then reconsider J,K as Element of S by XBOOLE_0:def 3;
    reconsider k0 = K as Element of B+*C by A6;
    let A be non-empty MSAlgebra over S;
    assume A7: A = (B,A1)+*A2;
    take J,K; thus K = s by A5;
A8: len the connectives of B = m by Def29;
A9: the connectives of S = (the connectives of B)^the connectives of C
    by A6,Def52;
A10: dom the Sorts of A2 = the carrier of C by PARTFUN1:def 2;
A11: r in dom the Sorts of A2 by A5,FUNCT_1:def 2;
    reconsider R = r as Element of C by A10,A5,FUNCT_1:def 2;
A12: the Arity of S = (the Arity of B)+*the Arity of C by A6,Th51;
    n > 0 by A1;
    then
A13: B+*C is (m+n,s,r)-array by A2,Th53;
    then
A14: len the connectives of B+*C >= m+n+3;
    consider J0,K0,L0 being Element of B+*C such that
A15: L0 = s & K0 = r & J0 <> L0 & J0 <> K0 &
    (the connectives of B+*C).(m+n) is_of_type <*J0,K0*>, L0 &
    (the connectives of B+*C).(m+n+1) is_of_type <*J0,K0,L0*>, J0 and
    (the connectives of B+*C).(m+n+2) is_of_type <*J0*>, K0 &
    (the connectives of B+*C).(m+n+3) is_of_type <*K0,L0*>, J0 by A13;
A16: the Sorts of A = (the Sorts of A1)+*the Sorts of A2 &
    the Charact of A = (the Charact of A1)+*the Charact of A2
    by A4,A7,CIRCCOMB:def 4;
    m+n <= m+n+3 & n <= n+3 by NAT_1:11;
    then 1 <= m+n & m+n <= len the connectives of S &
    1 <= n & n <= len the connectives of C
    by A1,A6,A3,A14,NAT_1:12,XXREAL_0:2;
    then
A17: m+n in dom the connectives of S & n in dom the connectives of C &
    dom the Sorts of A2 = the carrier of C &
    dom the Arity of C = the carrier' of C
    by PARTFUN1:def 2,FINSEQ_3:25;
    then
A18: (the connectives of S)/.(m+n) = (the connectives of S).(m+n) &
    (the connectives of C)/.n = (the connectives of C).n &
    (the connectives of C).n = (the connectives of S).(m+n)
    by A9,A8,PARTFUN1:def 6,FINSEQ_1:def 7;
    (the Arity of S).((the connectives of S).(m+n))
    = (the Arity of C).((the connectives of C).n) by A12,A18,A17,FUNCT_4:13;
    then <*J0,r*> = (the Arity of C).((the connectives of C).n) by A6,A15
    .= <*J,r*> by A5;
    then J0 = <*J,r*>.1 by FINSEQ_1:44 .= J by FINSEQ_1:44;
    then (the connectives of B+*C).(m+n) is_of_type <*J,r*>, k0 &
    the ManySortedSign of S = the ManySortedSign of B+*C by A6,A15,A5;
    hence (the connectives of S).(m+n) is_of_type <*J,r*>, K by A6;
    (the Sorts of A).K = (the Sorts of A2).K &
    (the Sorts of A).r = (the Sorts of A2).r &
    (the Sorts of A).J = (the Sorts of A2).J by A10,A11,A16,FUNCT_4:13;
    hence (the Sorts of A).J = ((the Sorts of A).K)^omega &
    (the Sorts of A).r = INT by A5;
    hereby
      let a be 0 -based finite array of (the Sorts of A).K;
      hereby
        let i be Integer; assume
A19:     i in dom a;
        (the connectives of C).n in the carrier' of C &
        dom the Charact of A2 = the carrier' of C &
        dom the Sorts of A2 = the carrier of C
        by A18,PARTFUN1:def 2;
        then (the Charact of A2).((the connectives of C)/.n)
        = (the Charact of A).((the connectives of S)/.(m+n)) &
        (the Sorts of A2).s = (the Sorts of A).s
        by A5,A16,A18,FUNCT_4:13;
        hence Den((the connectives of S)/.(m+n),A).<*a,i*> = a.i by A19,A5;
        let x be Element of A,K;
        m+n+1 <= m+n+1+2 & n+1 <= n+1+2 by NAT_1:11;
        then 1 <= m+n+1 & m+n+1 <= len the connectives of S &
        1 <= n+1 & n+1 <= len the connectives of C
        by A6,A3,A14,NAT_1:12,XXREAL_0:2;
        then
A20:     m+n+1 in dom the connectives of S & n+1 in dom the connectives of C &
        dom the Sorts of A2 = the carrier of C
        by PARTFUN1:def 2,FINSEQ_3:25;
A21:     (the connectives of S)/.(m+n+1) = (the connectives of S).(m+n+1) &
        (the connectives of C)/.(n+1) = (the connectives of C).(n+1) &
        (the connectives of C).(n+1) = (the connectives of S).(m+(n+1))
        by A9,A8,A20,PARTFUN1:def 6,FINSEQ_1:def 7;
        then (the connectives of C).(n+1) in the carrier' of C &
        dom the Charact of A2 = the carrier' of C & m+(n+1) = m+n+1 &
        dom the Sorts of A2 = the carrier of C
        by PARTFUN1:def 2;
        then (the Charact of A2).((the connectives of C)/.(n+1))
        = (the Charact of A).((the connectives of S)/.(m+n+1)) &
        (the Sorts of A2).k = (the Sorts of A).k0
        by A16,A21,FUNCT_4:13;
        hence Den((the connectives of S)/.(m+n+1),A).<*a,i,x*> = a+*(i,x)
        by A5,A19;
      end;
      m+n+2 <= m+n+2+1 & m+n+3 <= len the connectives of S &
      n+2+1 >= n+2 & n+3 <= len the connectives of C
      by A13,A2,A6,NAT_1:11;
      then 1 <= m+n+2 & m+n+2 <= len the connectives of S &
      1 <= n+2 & n+2 <= len the connectives of C by XXREAL_0:2,NAT_1:12;
      then
A22:   m+n+2 in dom the connectives of S & n+2 in dom the connectives of C &
      dom the Sorts of A2 = the carrier of C
      by PARTFUN1:def 2,FINSEQ_3:25;
A23:   (the connectives of S)/.(m+n+2) = (the connectives of S).(m+n+2) &
      (the connectives of C)/.(n+2) = (the connectives of C).(n+2) &
      (the connectives of C).(n+2) = (the connectives of S).(m+(n+2))
      by A9,A8,A22,PARTFUN1:def 6,FINSEQ_1:def 7;
      then (the connectives of C).(n+2) in the carrier' of C &
      dom the Charact of A2 = the carrier' of C & m+(n+2) = m+n+2 &
      dom the Sorts of A2 = the carrier of C
      by PARTFUN1:def 2;
      then (the Charact of A2).((the connectives of C)/.(n+2))
      = (the Charact of A).((the connectives of S)/.(m+n+2)) &
      (the Sorts of A2).k = (the Sorts of A).k0
      by A16,A23,FUNCT_4:13;
      hence Den((the connectives of S)/.(m+n+2),A).<*a*> = card a by A5;
    end;
    let i be Integer;
    let x be Element of A,K;
    assume A24: i >= 0;
    1 <= m+n+3 & m+n+3 <= len the connectives of S &
    1 <= n+3 & n+3 <= len the connectives of C
    by A2,A6,A13,NAT_1:12;
    then
A25: m+n+3 in dom the connectives of S & n+3 in dom the connectives of C &
    dom the Sorts of A2 = the carrier of C
    by PARTFUN1:def 2,FINSEQ_3:25;
A26: (the connectives of S)/.(m+n+3) = (the connectives of S).(m+n+3) &
    (the connectives of C)/.(n+3) = (the connectives of C).(n+3) &
    (the connectives of C).(n+3) = (the connectives of S).(m+(n+3))
    by A9,A8,A25,PARTFUN1:def 6,FINSEQ_1:def 7;
    then (the connectives of C).(n+3) in the carrier' of C &
    dom the Charact of A2 = the carrier' of C & m+(n+3) = m+n+3 &
    dom the Sorts of A2 = the carrier of C
    by PARTFUN1:def 2;
    then (the Charact of A2).((the connectives of C)/.(n+3))
    = (the Charact of A).((the connectives of S)/.(m+n+3)) &
    (the Sorts of A2).k = (the Sorts of A).k0
    by A16,A26,FUNCT_4:13;
    hence Den((the connectives of S)/.(m+n+3),A).<*i,x*> = Segm(i)-->x 
      by A5,A24;
  end;

theorem Th60:
  for n being Nat, s being set
  for S1,S2 being BoolSignature st
    the bool-sort of S1 = the bool-sort of S2 &
    len the connectives of S2 >= 3 &
    for i st i >= 1 & i <= 3 holds
    (the Arity of S1).((the connectives of S1).i)
    = (the Arity of S2).((the connectives of S2).i) &
    (the ResultSort of S1).((the connectives of S1).i)
    = (the ResultSort of S2).((the connectives of S2).i)
  holds S1 is bool-correct implies S2 is bool-correct
  proof
    let n be Nat;
    let s be set;
    let S1,S2 be BoolSignature;
    assume A1: the bool-sort of S1 = the bool-sort of S2;
    assume A2: len the connectives of S2 >= 3;
    assume A3: for i st i >= 1 & i <= 3 holds
    (the Arity of S1).((the connectives of S1).i)
    = (the Arity of S2).((the connectives of S2).i) &
    (the ResultSort of S1).((the connectives of S1).i)
    = (the ResultSort of S2).((the connectives of S2).i);
    set B = S1;
    assume
A4: len the connectives of B >= 3 &
    (the connectives of B).1 is_of_type {}, the bool-sort of B &
    (the connectives of B).2 is_of_type <*the bool-sort of B*>,
    the bool-sort of B &
    (the connectives of B).3 is_of_type
    <*the bool-sort of B, the bool-sort of B*>, the bool-sort of B;
    thus len the connectives of S2 >= 3 by A2;
    thus (the Arity of S2).((the connectives of S2).1)
    = (the Arity of S1).((the connectives of S1).1) by A3
    .= {} by A4;
    thus (the ResultSort of S2).((the connectives of S2).1)
    = (the ResultSort of S1).((the connectives of S1).1) by A3
    .= the bool-sort of S2 by A1,A4;
    thus (the Arity of S2).((the connectives of S2).2)
    = (the Arity of S1).((the connectives of S1).2) by A3
    .= <*the bool-sort of S2*> by A1,A4;
    thus (the ResultSort of S2).((the connectives of S2).2)
    = (the ResultSort of S1).((the connectives of S1).2) by A3
    .= the bool-sort of S2 by A1,A4;
    thus (the Arity of S2).((the connectives of S2).3)
    = (the Arity of S1).((the connectives of S1).3) by A3
    .= <*the bool-sort of S2,the bool-sort of S2*> by A1,A4;
    thus (the ResultSort of S2).((the connectives of S2).3)
    = (the ResultSort of S1).((the connectives of S1).3) by A3
    .= the bool-sort of S2 by A1,A4;
  end;

theorem Th61:
  for n being Nat, s being set
  for S1,S2 being non empty BoolSignature st
    n >= 1 & the bool-sort of S1 = the bool-sort of S2 &
    len the connectives of S2 >= n+6 &
    (the connectives of S2).n <> (the connectives of S2).(n+1) &
    (the connectives of S2).(n+3) <> (the connectives of S2).(n+4) &
    (the connectives of S2).(n+3) <> (the connectives of S2).(n+5) &
    (the connectives of S2).(n+4) <> (the connectives of S2).(n+5) &
    for i st i >= n & i <= n+6 holds
    (the Arity of S1).((the connectives of S1).i)
    = (the Arity of S2).((the connectives of S2).i) &
    (the ResultSort of S1).((the connectives of S1).i)
    = (the ResultSort of S2).((the connectives of S2).i)
  holds S1 is (n,s) integer implies S2 is (n,s) integer
  proof
    let n be Nat;
    let s be set;
    let S1,S2 be non empty BoolSignature;
    assume A1: n >= 1 & the bool-sort of S1 = the bool-sort of S2;
    assume A2: len the connectives of S2 >= n+6;
    assume
A3: (the connectives of S2).n <> (the connectives of S2).(n+1) &
    (the connectives of S2).(n+3) <> (the connectives of S2).(n+4) &
    (the connectives of S2).(n+3) <> (the connectives of S2).(n+5) &
    (the connectives of S2).(n+4) <> (the connectives of S2).(n+5);
    assume A4: for i st i >= n & i <= n+6 holds
    (the Arity of S1).((the connectives of S1).i)
    = (the Arity of S2).((the connectives of S2).i) &
    (the ResultSort of S1).((the connectives of S1).i)
    = (the ResultSort of S2).((the connectives of S2).i);
    assume len the connectives of S1 >= n+6;
    given I being Element of S1 such that
A5: I = s & I <> the bool-sort of S1 &
    (the connectives of S1).n is_of_type {},I &
    (the connectives of S1).(n+1) is_of_type {},I &
    (the connectives of S1).n <> (the connectives of S1).(n+1) &
    (the connectives of S1).(n+2) is_of_type <*I*>,I &
    (the connectives of S1).(n+3) is_of_type <*I,I*>,I &
    (the connectives of S1).(n+4) is_of_type <*I,I*>,I &
    (the connectives of S1).(n+5) is_of_type <*I,I*>,I &
    (the connectives of S1).(n+3) <> (the connectives of S1).(n+4) &
    (the connectives of S1).(n+3) <> (the connectives of S1).(n+5) &
    (the connectives of S1).(n+4) <> (the connectives of S1).(n+5) &
    (the connectives of S1).(n+6) is_of_type <*I,I*>,the bool-sort of S1;
    thus len the connectives of S2 >= n+6 by A2;
A6: n <= n+6 by NAT_1:11;
    then n <= len the connectives of S2 by A2,XXREAL_0:2;
    then
A7: n in dom the connectives of S2 by A1,FINSEQ_3:25;
A8: (the ResultSort of S2).((the connectives of S2).n)
    = (the ResultSort of S1).((the connectives of S1).n) by A4,A6
    .= I by A5;
    reconsider J = I as Element of S2 by A8,A7,FUNCT_2:5,FUNCT_1:102;
    take J;
    thus J = s & J <> the bool-sort of S2 by A1,A5;
    thus (the Arity of S2).((the connectives of S2).n)
    = (the Arity of S1).((the connectives of S1).n) by A4,A6
    .= {} by A5;
    thus (the ResultSort of S2).((the connectives of S2).n)
    = (the ResultSort of S1).((the connectives of S1).n) by A4,A6
    .= J by A5;
A9: n+0 <= n+1 & n+1 <= n+6 by XREAL_1:6;
    hence (the Arity of S2).((the connectives of S2).(n+1))
    = (the Arity of S1).((the connectives of S1).(n+1)) by A4
    .= {} by A5;
    thus (the ResultSort of S2).((the connectives of S2).(n+1))
    = (the ResultSort of S1).((the connectives of S1).(n+1)) by A4,A9
    .= J by A5;
    thus (the connectives of S2).n <> (the connectives of S2).(n+1) by A3;
A10: n+0 <= n+2 & n+2 <= n+6 by XREAL_1:6;
    hence (the Arity of S2).((the connectives of S2).(n+2))
    = (the Arity of S1).((the connectives of S1).(n+2)) by A4
    .= <*J*> by A5;
    thus (the ResultSort of S2).((the connectives of S2).(n+2))
    = (the ResultSort of S1).((the connectives of S1).(n+2)) by A4,A10
    .= J by A5;
A11: n+0 <= n+3 & n+3 <= n+6 by XREAL_1:6;
    hence (the Arity of S2).((the connectives of S2).(n+3))
    = (the Arity of S1).((the connectives of S1).(n+3)) by A4
    .= <*J,J*> by A5;
    thus (the ResultSort of S2).((the connectives of S2).(n+3))
    = (the ResultSort of S1).((the connectives of S1).(n+3)) by A4,A11
    .= J by A5;
A12: n+0 <= n+4 & n+4 <= n+6 by XREAL_1:6;
    hence (the Arity of S2).((the connectives of S2).(n+4))
    = (the Arity of S1).((the connectives of S1).(n+4)) by A4
    .= <*J,J*> by A5;
    thus (the ResultSort of S2).((the connectives of S2).(n+4))
    = (the ResultSort of S1).((the connectives of S1).(n+4)) by A4,A12
    .= J by A5;
A13: n+0 <= n+5 & n+5 <= n+6 by XREAL_1:6;
    hence (the Arity of S2).((the connectives of S2).(n+5))
    = (the Arity of S1).((the connectives of S1).(n+5)) by A4
    .= <*J,J*> by A5;
    thus (the ResultSort of S2).((the connectives of S2).(n+5))
    = (the ResultSort of S1).((the connectives of S1).(n+5)) by A4,A13
    .= J by A5;
    thus (the connectives of S2).(n+3) <> (the connectives of S2).(n+4) by A3;
    thus (the connectives of S2).(n+3) <> (the connectives of S2).(n+5) by A3;
    thus (the connectives of S2).(n+4) <> (the connectives of S2).(n+5) by A3;
A14: n+0 <= n+6 by XREAL_1:6;
    hence (the Arity of S2).((the connectives of S2).(n+6))
    = (the Arity of S1).((the connectives of S1).(n+6)) by A4
    .= <*J,J*> by A5;
    thus (the ResultSort of S2).((the connectives of S2).(n+6))
    = (the ResultSort of S1).((the connectives of S1).(n+6)) by A4,A14
    .= the bool-sort of S2 by A1,A5;
  end;

theorem Th62:
  for n,m being Nat, s,r being set
  for S1,S2 being non empty ConnectivesSignature st
    1 <= n & len the connectives of S1 >= n+3 &
    for i st i >= n & i <= n+3 holds
    (the Arity of S1).((the connectives of S1).i)
    = (the Arity of S2).((the connectives of S2).(i+m)) &
    (the ResultSort of S1).((the connectives of S1).i)
    = (the ResultSort of S2).((the connectives of S2).(i+m))
  holds S2 is (n+m,s,r)-array implies S1 is (n,s,r)-array
  proof
    let n,m be Nat;
    let s,r be set;
    let S1,S2 be non empty ConnectivesSignature;
    assume A1: 1 <= n;
    assume A2: len the connectives of S1 >= n+3;
    assume A3: for i st i >= n & i <= n+3 holds
    (the Arity of S1).((the connectives of S1).i)
    = (the Arity of S2).((the connectives of S2).(i+m)) &
    (the ResultSort of S1).((the connectives of S1).i)
    = (the ResultSort of S2).((the connectives of S2).(i+m));
    assume len the connectives of S2 >= n+m+3;
    given J,K,L being Element of S2 such that
A4: L = s & K = r & J <> L & J <> K &
    (the connectives of S2).(n+m) is_of_type <*J,K*>, L &
    (the connectives of S2).(n+m+1) is_of_type <*J,K,L*>, J &
    (the connectives of S2).(n+m+2) is_of_type <*J*>, K &
    (the connectives of S2).(n+m+3) is_of_type <*K,L*>, J;
    thus len the connectives of S1 >= n+3 by A2;
A5: n <= n+3 by NAT_1:11;
    then (the Arity of S1).((the connectives of S1).n)
    = (the Arity of S2).((the connectives of S2).(n+m)) &
    (the ResultSort of S1).((the connectives of S1).n)
    = (the ResultSort of S2).((the connectives of S2).(n+m)) by A3;
    then
A6: (the Arity of S1).((the connectives of S1).n) = <*J,K*> &
    (the ResultSort of S1).((the connectives of S1).n) = L by A4;
A7: n <= n+1 & n+1 <= n+1+2 & n+3 = n+1+2 by NAT_1:11;
    then (the Arity of S1).((the connectives of S1).(n+1))
    = (the Arity of S2).((the connectives of S2).(n+1+m)) &
    (the ResultSort of S1).((the connectives of S1).(n+1))
    = (the ResultSort of S2).((the connectives of S2).(n+1+m)) by A3;
    then
A8: (the Arity of S1).((the connectives of S1).(n+1)) = <*J,K,L*> &
    (the ResultSort of S1).((the connectives of S1).(n+1)) = J by A4;
A9: n+2 <= n+2+1 & n <= n+2 by NAT_1:11;
    then (the Arity of S1).((the connectives of S1).(n+2))
    = (the Arity of S2).((the connectives of S2).(n+2+m)) &
    (the ResultSort of S1).((the connectives of S1).(n+2))
    = (the ResultSort of S2).((the connectives of S2).(n+2+m)) by A3;
    then
A10: (the Arity of S1).((the connectives of S1).(n+2)) = <*J*> &
    (the ResultSort of S1).((the connectives of S1).(n+2)) = K by A4;
    n <= n+3 by NAT_1:11;
    then (the Arity of S1).((the connectives of S1).(n+3))
    = (the Arity of S2).((the connectives of S2).(n+3+m)) &
    (the ResultSort of S1).((the connectives of S1).(n+3))
    = (the ResultSort of S2).((the connectives of S2).(n+3+m)) by A3;
    then
A11: (the Arity of S1).((the connectives of S1).(n+3)) = <*K,L*> &
    (the ResultSort of S1).((the connectives of S1).(n+3)) = J by A4;
    n <= len the connectives of S1 & 1 <= n+1 & 1 <= n+1+1 &
    n+1 <= len the connectives of S1 & n+2 <= len the connectives of S1 &
    1 <= n+3 by A2,A5,A7,A9,XXREAL_0:2,NAT_1:11;
    then n in dom the connectives of S1 & n+1 in dom the connectives of S1 &
    n+2 in dom the connectives of S1 by A1,FINSEQ_3:25;
    then reconsider J,K,L as Element of S1 by A6,A8,A10,FUNCT_1:102,FUNCT_2:5;
    take J,K,L;
    thus L = s & K = r & J <> L & J <> K by A4;
    thus thesis by A6,A8,A10,A11;
  end;

theorem Th63:
  for j,k be set, i,m,n being Nat st m >= 4 & m+6 <= n & i >= 1
  for S being 1-1-connectives bool-correct non empty non void BoolSignature
  st S is (n+i,j,k)-array (m,k) integer
  ex B being bool-correct non empty non void BoolSignature,
  C being non empty non void ConnectivesSignature st
  the BoolSignature of S = B+*C &
  B is n-connectives (m,k) integer & C is (i,j,k)-array &
  the carrier of B = the carrier of C &
  the carrier' of B = (the carrier' of S)\rng the connectives of C &
  the carrier' of C = rng the connectives of C &
  the connectives of B = (the connectives of S)|n &
  the connectives of C = (the connectives of S)/^n
  proof
    let j,k be set;
    let i,m,n be Nat;
    assume A1: m >= 4;
    assume A2: m+6 <= n & i >= 1;
    let S be 1-1-connectives bool-correct non empty non void BoolSignature;
    assume A3: len the connectives of S >= n+i+3;
    given J,K,L being Element of S such that
A4: L = j & K = k & J <> L & J <> K &
    (the connectives of S).(n+i) is_of_type <*J,K*>, L &
    (the connectives of S).(n+i+1) is_of_type <*J,K,L*>, J &
    (the connectives of S).(n+i+2) is_of_type <*J*>, K &
    (the connectives of S).(n+i+3) is_of_type <*K,L*>, J;
A5: S is (i+n,j,k)-array by A3,A4;
    assume A6: len the connectives of S >= m+6;
    given I being Element of S such that
A7: I = k & I <> the bool-sort of S &
    (the connectives of S).m is_of_type {},I &
    (the connectives of S).(m+1) is_of_type {},I &
    (the connectives of S).m <> (the connectives of S).(m+1) &
    (the connectives of S).(m+2) is_of_type <*I*>,I &
    (the connectives of S).(m+3) is_of_type <*I,I*>,I &
    (the connectives of S).(m+4) is_of_type <*I,I*>,I &
    (the connectives of S).(m+5) is_of_type <*I,I*>,I &
    (the connectives of S).(m+3) <> (the connectives of S).(m+4) &
    (the connectives of S).(m+3) <> (the connectives of S).(m+5) &
    (the connectives of S).(m+4) <> (the connectives of S).(m+5) &
    (the connectives of S).(m+6) is_of_type <*I,I*>,the bool-sort of S;
A8: S is (m,k) integer by A6,A7;
    set r = (the connectives of S)/^n;
    set W = rng r;
A9: n+i+3 = n+(i+3) & n <= n+(i+3) by NAT_1:12;
    then
A10: len the connectives of S >= n by A3,XXREAL_0:2;
    then len r = (len the connectives of S)-n by RFINSEQ:def 1;
    then
A11: len r >= n+(i+3)-n by A3,XREAL_1:9;
    then
    len r >= i+3 & i+1+2 >= 2 by NAT_1:11;
    then len r >= 2 by XXREAL_0:2;
    then r <> {}; then
    reconsider W as non empty set;
    set O = (the carrier' of S)\W;
    m <= m+6 by NAT_1:11;
    then m <= n by A2,XXREAL_0:2;
    then
A12: 4 <= n by A1,XXREAL_0:2;
    then
A13: 1 <= n & 1 <= m by A1,XXREAL_0:2;
    n <= n+(i+3) by NAT_1:11;
    then 1 <= n+i+3 by A13,XXREAL_0:2;
    then 1 <= len the connectives of S by A3,XXREAL_0:2;
    then
A14: 1 in dom the connectives of S by FINSEQ_3:25;
    then
A15: (the connectives of S).1 in the carrier' of S by FUNCT_1:102;
    now assume (the connectives of S).1 in W;
      then consider x being object such that
A16:   x in dom r & (the connectives of S).1 = r.x by FUNCT_1:def 3;
      reconsider x as Nat by A16;
      r.x = (the connectives of S).(x+n) & n+x in dom the connectives of S
      by A10,A16,RFINSEQ:def 1,FINSEQ_5:26;
      then 1 = n+x & n = n+0 by A14,A16,FUNCT_1:def 4;
      then x = 0 by A13,XREAL_1:6,NAT_1:3;
      hence contradiction by A16,FINSEQ_3:24;
    end;
    then reconsider O as non empty set by A15,XBOOLE_0:def 5;
A17: W c= the carrier' of S by FINSEQ_1:def 4;
    reconsider A = (the Arity of S)|O as Function of O, (the carrier of S)*
    by FUNCT_2:32;
    reconsider Ac = (the Arity of S)|W as Function of W, (the carrier of S)*
    by A17,FUNCT_2:32;
    reconsider R = (the ResultSort of S)|O as Function of O, the carrier of S
    by FUNCT_2:32;
    reconsider Rc = (the ResultSort of S)|W as Function of W, the carrier of S
    by A17,FUNCT_2:32;
    set s = the bool-sort of S;
    set p = (the connectives of S)|n;
    rng p c= O
    proof let x be object; assume x in rng p;
      then consider y being object such that
A18:   y in dom p & x = p.y by FUNCT_1:def 3;
A19:   x in the carrier' of S by A18,FUNCT_1:102;
      assume x nin O;
      then x in W by A19,XBOOLE_0:def 5;
      then consider z being object such that
A20:   z in dom r & x = r.z by FUNCT_1:def 3;
      reconsider y as Nat by A18;
      reconsider z as Nat by A20;
A21:   y in dom the connectives of S & x = (the connectives of S).y
      by A18,RELAT_1:57,FUNCT_1:47;
      y <= len p & len p <= n by A18,FINSEQ_3:25,FINSEQ_5:17;
      then
A22:   y <= n by XXREAL_0:2;
      r.z = (the connectives of S).(z+n) & n+z in dom the connectives of S
      by A10,A20,RFINSEQ:def 1,FINSEQ_5:26;
      then y = n+z & n = n+0 by A21,A20,FUNCT_1:def 4;
      then z = 0 by A22,XREAL_1:6,NAT_1:3;
      hence contradiction by A20,FINSEQ_3:24;
    end;
    then reconsider c = p as FinSequence of O by FINSEQ_1:def 4;
    reconsider cc = r as FinSequence of W by FINSEQ_1:def 4;
    set B = BoolSignature(#the carrier of S,O,A,R,s,c#);
    set C = ConnectivesSignature(#the carrier of S,W,Ac,Rc,cc#);
    now
      5 <= m+1+5 by NAT_1:11;
      then 3 <= m+6 by XXREAL_0:2;
      hence len the connectives of S >= 3 by A6,XXREAL_0:2;
      n <= n+(i+3) by NAT_1:11;
      then len the connectives of B = n by FINSEQ_1:59,A3,XXREAL_0:2;
      hence
A23:   len the connectives of B >= 3 by A12,XXREAL_0:2;
      let z be Nat; assume
A24:   z >= 1 & z <= 3;
      then z <= len the connectives of B by A23,XXREAL_0:2;
      then z in dom the connectives of B by A24,FINSEQ_3:25;
      then
A25:   (the connectives of B).z in O &
      (the connectives of B).z = (the connectives of S).z by FUNCT_1:47,102;
      thus (the Arity of S).((the connectives of S).z)
      = (the Arity of B).((the connectives of B).z) by A25,FUNCT_1:49;
      thus (the ResultSort of S).((the connectives of S).z)
      = (the ResultSort of B).((the connectives of B).z) by A25,FUNCT_1:49;
    end;
    then reconsider B as bool-correct non empty non void BoolSignature
    by Th60;
    reconsider C as non empty non void ConnectivesSignature;
    take B, C;
A26: the carrier of S = (the carrier of B)\/the carrier of C;
A27: the carrier' of S = (the carrier' of B)\/the carrier' of C
    by FINSEQ_1:def 4,XBOOLE_1:45;
    dom the Arity of S = the carrier' of S by FUNCT_2:def 1;
    then
A28: the Arity of S = (the Arity of B)+*the Arity of C by A27,FUNCT_4:70;
    dom the ResultSort of S = the carrier' of S by FUNCT_2:def 1;
    then the ResultSort of S = (the ResultSort of B)+*the ResultSort of C
    by A27,FUNCT_4:70;
    then
A29: the ManySortedSign of S = (B qua non empty ManySortedSign)+*C
    by A26,A27,A28,CIRCCOMB:def 2;
    the connectives of S = c^cc by RFINSEQ:8;
    hence the BoolSignature of S = B+*C by A29,Def52;
    thus
A30: len the connectives of B = n by A9,A3,XXREAL_0:2,FINSEQ_1:59;
    now
      thus 1 <= m & the bool-sort of B = the bool-sort of S by A1,XXREAL_0:2;
      thus len the connectives of B >= m+6 by A2,A9,A3,XXREAL_0:2,FINSEQ_1:59;
      m <= m+6 & m+1 <= m+1+5 by NAT_1:11;
      then m >= 1 & m <= len the connectives of B &
      m+1 >= 1 & m+1 <= len the connectives of B
      by A1,A2,A30,XXREAL_0:2,NAT_1:11;
      then m in dom the connectives of B & m+1 in dom the connectives of B
      by FINSEQ_3:25;
      then (the connectives of B).m = (the connectives of S).m &
      (the connectives of B).(m+1) = (the connectives of S).(m+1)
      by FUNCT_1:47;
      hence (the connectives of B).m <> (the connectives of B).(m+1) by A7;
      m+3 <= m+3+3 & m+4 <= m+4+2 & m+5 <= m+5+1 by NAT_1:11;
      then m+2+1 >= 1 & m+3 <= len the connectives of B &
      m+3+1 >= 1 & m+4 <= len the connectives of B &
      m+4+1 >= 1 & m+5 <= len the connectives of B
      by A2,A30,XXREAL_0:2,NAT_1:11;
      then m+3 in dom the connectives of B & m+4 in dom the connectives of B &
      m+5 in dom the connectives of B by FINSEQ_3:25;
      then (the connectives of B).(m+3) = (the connectives of S).(m+3) &
      (the connectives of B).(m+4) = (the connectives of S).(m+4) &
      (the connectives of B).(m+5) = (the connectives of S).(m+5)
      by FUNCT_1:47;
      hence (the connectives of B).(m+3) <> (the connectives of B).(m+4) &
      (the connectives of B).(m+3) <> (the connectives of B).(m+5) &
      (the connectives of B).(m+4) <> (the connectives of B).(m+5) by A7;
      let z be Nat; assume z >= m & z <= m+6;
      then 1 <= z & z <= len the connectives of B by A2,A30,A13,XXREAL_0:2;
      then z in dom the connectives of B by FINSEQ_3:25;
      then
A31:   (the connectives of B).z in O &
      (the connectives of B).z = (the connectives of S).z by FUNCT_1:47,102;
      thus (the Arity of S).((the connectives of S).z)
      = (the Arity of B).((the connectives of B).z) by A31,FUNCT_1:49;
      thus (the ResultSort of S).((the connectives of S).z)
      = (the ResultSort of B).((the connectives of B).z) by A31,FUNCT_1:49;
    end;
    hence B is (m,k) integer by A8,Th61;
    now
      thus len the connectives of C >= i+3 by A11;
      thus 1 <= i by A2;
      let z be Nat; assume z >= i & z <= i+3;
      then 1 <= z & z <= len r by A11,A2,XXREAL_0:2;
      then z in dom r by FINSEQ_3:25;
      then
A32:   (the connectives of C).z in W &
      (the connectives of C).z = (the connectives of S).(z+n)
      by A10,FUNCT_1:102,RFINSEQ:def 1;
      thus (the Arity of C).((the connectives of C).z)
      = (the Arity of S).((the connectives of S).(z+n)) by A32,FUNCT_1:49;
      thus (the ResultSort of C).((the connectives of C).z)
      = (the ResultSort of S).((the connectives of S).(z+n)) by A32,FUNCT_1:49;
    end;
    hence C is (i,j,k)-array by A5,Th62;
    thus thesis;
  end;

theorem Th64:
  for s,I being set
  for S being bool-correct non empty non void BoolSignature
  st S is (4,I) integer
  for X being non empty set
  st s in the carrier of S & s <> I & s <> the bool-sort of S
  ex A being bool-correct non-empty MSAlgebra over S st A is (4,I) integer &
  (the Sorts of A).s = X
  proof
    let s,I be set;
    let S be bool-correct non empty non void BoolSignature;
    assume A1: S is (4,I) integer;
    then consider J being Element of S such that
A2: J = I & J <> the bool-sort of S &
    (the connectives of S).4 is_of_type {},J &
    (the connectives of S).(4+1) is_of_type {},J &
    (the connectives of S).4 <> (the connectives of S).(4+1) &
    (the connectives of S).(4+2) is_of_type <*J*>,J &
    (the connectives of S).(4+3) is_of_type <*J,J*>,J &
    (the connectives of S).(4+4) is_of_type <*J,J*>,J &
    (the connectives of S).(4+5) is_of_type <*J,J*>,J &
    (the connectives of S).(4+3) <> (the connectives of S).(4+4) &
    (the connectives of S).(4+3) <> (the connectives of S).(4+5) &
    (the connectives of S).(4+4) <> (the connectives of S).(4+5) &
    (the connectives of S).(4+6) is_of_type <*J,J*>,the bool-sort of S;
A3: len the connectives of S >= 3 &
    (the connectives of S).1 is_of_type {}, the bool-sort of S &
    (the connectives of S).2 is_of_type <*the bool-sort of S*>,
    the bool-sort of S &
    (the connectives of S).3 is_of_type
    <*the bool-sort of S, the bool-sort of S*>, the bool-sort of S
    by Def30;
    let X be non empty set;
    assume A4: s in the carrier of S;
    assume A5: s <> I;
    assume A6: s <> the bool-sort of S;
    consider A being bool-correct non-empty strict MSAlgebra over S such that
A7: A is (4,I) integer by A1,Th49;
A8: (the Sorts of A).the bool-sort of S = BOOLEAN &
    Den(In((the connectives of S).1, the carrier' of S), A).{} = TRUE &
    for x,y be boolean object holds
    Den(In((the connectives of S).2, the carrier' of S), A).<*x*> = 'not' x &
    Den(In((the connectives of S).3, the carrier' of S), A).<*x,y*> = x '&' y
    by Def31;
    consider K being SortSymbol of S such that
A9: K = I & (the connectives of S).4 is_of_type {},K &
    (the Sorts of A).K = INT &
    Den(In((the connectives of S).4, the carrier' of S), A).{} = 0 &
    Den(In((the connectives of S).(4+1), the carrier' of S), A).{} = 1 &
    for i,j being Integer holds
    Den(In((the connectives of S).(4+2), the carrier' of S), A).<*i*> = -i &
    Den(In((the connectives of S).(4+3), the carrier' of S), A).<*i,j*> = i+j &
    Den(In((the connectives of S).(4+4), the carrier' of S), A).<*i,j*> = i*j &
    (j <> 0 implies
    Den(In((the connectives of S).(4+5), the carrier' of S), A).<*i,j*>
    = i div j) &
    Den(In((the connectives of S).(4+6), the carrier' of S), A).<*i,j*>
    = IFGT(i,j,FALSE,TRUE) by A7;
    set Q = (the Sorts of A)+*(s,X);
    set F = the ManySortedFunction of Q#*the Arity of S, Q*the ResultSort of S;
    set Ch = F+*((the Charact of A)|((the connectives of S).:Seg 10));
    dom the Charact of A = the carrier' of S by PARTFUN1:def 2;
    then
A10: dom ((the Charact of A)|((the connectives of S).:Seg 10))
    = (the connectives of S).:Seg 10 by Th1,RELAT_1:62;
    reconsider Ch as ManySortedFunction of the carrier' of S;
    Ch is ManySortedFunction of Q#*the Arity of S, Q*the ResultSort of S
    proof
      let x be object; assume
      x in the carrier' of S;
      then reconsider o = x as OperSymbol of S;
      per cases;
      suppose
A11:     x in (the connectives of S).:Seg 10;
        then
A12:     Ch.x = ((the Charact of A)|((the connectives of S).:Seg 10)).x
        by A10,FUNCT_4:13
        .= (the Charact of A).x by A11,FUNCT_1:49;
A13:     ((the Sorts of A)#*the Arity of S).o
        = (the Sorts of A)#.((the Arity of S).o) &
        ((the Sorts of A)*the ResultSort of S).o
        = (the Sorts of A).((the ResultSort of S).o) &
        (Q#*the Arity of S).o = Q#.((the Arity of S).x) &
        (Q*the ResultSort of S).o = Q.((the ResultSort of S).x) by FUNCT_2:15;
        consider y being object such that
A14:     y in dom the connectives of S & y in Seg 10 &
        o = (the connectives of S).y
        by A11,FUNCT_1:def 6;
        per cases by A14,Th23,ENUMSET1:def 8;
        suppose y = 1;
          then (the Arity of S).o = {} &
          (the ResultSort of S).o = the bool-sort of S &
          <*>the carrier of S in (the carrier of S)*
          by A3,A14,FINSEQ_1:def 11;
          then (the Sorts of A)#.((the Arity of S).o)
          = product ((the Sorts of A)*<*>the carrier of S) &
          Q#.((the Arity of S).o) = product (Q*<*>the carrier of S) &
          (the Sorts of A).((the ResultSort of S).o) = BOOLEAN &
          Q.((the ResultSort of S).o) = BOOLEAN
          by A6,A8,FINSEQ_2:def 5,FUNCT_7:32;
          hence Ch.x is Function of (Q#*the Arity of S).x,
          (Q*the ResultSort of S).x by A12,A13;
        end;
        suppose y = 2;
          then (the Arity of S).o = <*the bool-sort of S*> &
          (the ResultSort of S).o = the bool-sort of S &
          <*the bool-sort of S*> in (the carrier of S)*
          by A3,A14,FINSEQ_1:def 11;
          then
A15:       (the Sorts of A)#.((the Arity of S).o) = product ((the Sorts of A)*
          <*the bool-sort of S*>) &
          Q#.((the Arity of S).o) = product (Q*<*the bool-sort of S*>) &
          (the Sorts of A).((the ResultSort of S).o) = BOOLEAN &
          Q.((the ResultSort of S).o) = BOOLEAN
          by A6,A8,FINSEQ_2:def 5,FUNCT_7:32;
          dom the Sorts of A = the carrier of S &
          dom Q = the carrier of S by PARTFUN1:def 2;
          then (the Sorts of A)*<*the bool-sort of S*>
          = <*(the Sorts of A).the bool-sort of S*> &
          Q*<*the bool-sort of S*> = <*Q.the bool-sort of S*> &
          (the Sorts of A).the bool-sort of S = Q.the bool-sort of S
          by A6,FUNCT_7:32,FINSEQ_2:34;
          hence Ch.x is Function of (Q#*the Arity of S).x,
          (Q*the ResultSort of S).x by A12,A13,A15;
        end;
        suppose y = 3;
          then (the Arity of S).o = <*the bool-sort of S,the bool-sort of S*> &
          (the ResultSort of S).o = the bool-sort of S &
          <*the bool-sort of S,the bool-sort of S*> in (the carrier of S)*
          by A3,A14,FINSEQ_1:def 11;
          then
A16:       (the Sorts of A)#.((the Arity of S).o) = product ((the Sorts of A)*
          <*the bool-sort of S,the bool-sort of S*>) &
          Q#.((the Arity of S).o)
          = product (Q*<*the bool-sort of S,the bool-sort of S*>) &
          (the Sorts of A).((the ResultSort of S).o) = BOOLEAN &
          Q.((the ResultSort of S).o) = BOOLEAN
          by A6,A8,FINSEQ_2:def 5,FUNCT_7:32;
          dom the Sorts of A = the carrier of S &
          dom Q = the carrier of S by PARTFUN1:def 2;
          then (the Sorts of A)*<*the bool-sort of S,the bool-sort of S*>
          = <*(the Sorts of A).the bool-sort of S,
          (the Sorts of A).the bool-sort of S*> &
          Q*<*the bool-sort of S,the bool-sort of S*>
          = <*Q.the bool-sort of S,Q.the bool-sort of S*> &
          (the Sorts of A).the bool-sort of S = Q.the bool-sort of S
          by A6,FUNCT_7:32,FINSEQ_2:125;
          hence Ch.x is Function of (Q#*the Arity of S).x,
          (Q*the ResultSort of S).x by A12,A13,A16;
        end;
        suppose y = 4 or y = 5;
          then (the Arity of S).o = {} &
          (the ResultSort of S).o = J &
          <*>the carrier of S in (the carrier of S)*
          by A2,A14,FINSEQ_1:def 11;
          then (the Sorts of A)#.((the Arity of S).o)
          = product ((the Sorts of A)*<*>the carrier of S) &
          Q#.((the Arity of S).o) = product (Q*<*>the carrier of S) &
          (the Sorts of A).((the ResultSort of S).o) = INT &
          Q.((the ResultSort of S).o) = INT
          by A5,A2,A9,FINSEQ_2:def 5,FUNCT_7:32;
          hence Ch.x is Function of (Q#*the Arity of S).x,
          (Q*the ResultSort of S).x by A12,A13;
        end;
        suppose y = 6;
          then (the Arity of S).o = <*J*> &
          (the ResultSort of S).o = J &
          <*J*> in (the carrier of S)* by A2,A14,FINSEQ_1:def 11;
          then
A17:       (the Sorts of A)#.((the Arity of S).o) = product ((the Sorts of A)*
          <*J*>) &
          Q#.((the Arity of S).o) = product (Q*<*J*>) &
          (the Sorts of A).((the ResultSort of S).o) = INT &
          Q.((the ResultSort of S).o) = INT
          by A5,A2,A9,FINSEQ_2:def 5,FUNCT_7:32;
          dom the Sorts of A = the carrier of S &
          dom Q = the carrier of S by PARTFUN1:def 2;
          then (the Sorts of A)*<*J*> = <*(the Sorts of A).J*> &
          Q*<*J*> = <*Q.J*> &
          (the Sorts of A).J = Q.J
          by A2,A5,FUNCT_7:32,FINSEQ_2:34;
          hence Ch.x is Function of (Q#*the Arity of S).x,
          (Q*the ResultSort of S).x by A12,A13,A17;
        end;
        suppose y = 7 or y = 8 or y = 9;
          then (the Arity of S).o = <*J,J*> &
          (the ResultSort of S).o = J &
          <*J,J*> in (the carrier of S)* by A2,A14,FINSEQ_1:def 11;
          then
A18:       (the Sorts of A)#.((the Arity of S).o) = product ((the Sorts of A)*
          <*J,J*>) &
          Q#.((the Arity of S).o) = product (Q*<*J,J*>) &
          (the Sorts of A).((the ResultSort of S).o) = INT &
          Q.((the ResultSort of S).o) = INT
          by A5,A2,A9,FINSEQ_2:def 5,FUNCT_7:32;
          dom the Sorts of A = the carrier of S &
          dom Q = the carrier of S by PARTFUN1:def 2;
          then (the Sorts of A)*<*J,J*>
          = <*(the Sorts of A).J,(the Sorts of A).J*> &
          Q*<*J,J*> = <*Q.J,Q.J*> &
          (the Sorts of A).J = Q.J
          by A5,A2,FUNCT_7:32,FINSEQ_2:125;
          hence Ch.x is Function of (Q#*the Arity of S).x,
          (Q*the ResultSort of S).x by A12,A13,A18;
        end;
        suppose y = 10;
          then (the Arity of S).o = <*J,J*> &
          (the ResultSort of S).o = the bool-sort of S &
          <*J,J*> in (the carrier of S)* by A2,A14,FINSEQ_1:def 11;
          then
A19:       (the Sorts of A)#.((the Arity of S).o) = product ((the Sorts of A)*
          <*J,J*>) &
          Q#.((the Arity of S).o) = product (Q*<*J,J*>) &
          (the Sorts of A).((the ResultSort of S).o) = BOOLEAN &
          Q.((the ResultSort of S).o) = BOOLEAN
          by A6,A8,FINSEQ_2:def 5,FUNCT_7:32;
          dom the Sorts of A = the carrier of S &
          dom Q = the carrier of S by PARTFUN1:def 2;
          then (the Sorts of A)*<*J,J*>
          = <*(the Sorts of A).J,(the Sorts of A).J*> &
          Q*<*J,J*> = <*Q.J,Q.J*> &
          (the Sorts of A).J = Q.J
          by A5,A2,FUNCT_7:32,FINSEQ_2:125;
          hence Ch.x is Function of (Q#*the Arity of S).x,
          (Q*the ResultSort of S).x by A12,A13,A19;
        end;
      end;
      suppose
        x nin (the connectives of S).:Seg 10;
        then Ch.x = F.x by A10,FUNCT_4:11;
        hence Ch.x is Function of (Q#*the Arity of S).x,
        (Q*the ResultSort of S).x;
      end;
    end;
    then reconsider Ch as ManySortedFunction of Q#*the Arity of S,
    Q*the ResultSort of S;
    set A0 = MSAlgebra(#Q,Ch#);
A20: A0 is bool-correct
    proof
      thus (the Sorts of A0).the bool-sort of S
      = (the Sorts of A).the bool-sort of S
      by A6,FUNCT_7:32
      .= BOOLEAN by Def31;
      4+6 <= len the connectives of S by A1;
      then 1 <= len the connectives of S by XXREAL_0:2;
      then
A21:   1 in dom the connectives of S by FINSEQ_3:25;
      then
A22:   In((the connectives of S).1, the carrier' of S)
      = (the connectives of S).1 by SUBSET_1:def 8,FUNCT_1:102;
      1 in Seg 10;
      then
A23:   (the connectives of S).1 in (the connectives of S).:Seg 10
      by A21,FUNCT_1:def 6;
      then Den(In((the connectives of S).1, the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).1) by A22,A10,FUNCT_4:13
      .= Den(In((the connectives of S).1, the carrier' of S), A)
      by A22,A23,FUNCT_1:49;
      hence Den(In((the connectives of S).1, the carrier' of S), A0).{}
      = TRUE by Def31;
      let x,y be boolean object;
      4+6 <= len the connectives of S by A1;
      then 2 <= len the connectives of S by XXREAL_0:2;
      then
A24:   2 in dom the connectives of S by FINSEQ_3:25;
      then
A25:   In((the connectives of S).2, the carrier' of S)
      = (the connectives of S).2 by SUBSET_1:def 8,FUNCT_1:102;
      2 in Seg 10;
      then
A26:   In((the connectives of S).2, the carrier' of S)
      in (the connectives of S).:Seg 10 by A24,A25,FUNCT_1:def 6;
      then Den(In((the connectives of S).2, the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).2) by A25,A10,FUNCT_4:13
      .= Den(In((the connectives of S).2, the carrier' of S), A)
      by A25,A26,FUNCT_1:49;
      hence Den(In((the connectives of S).2, the carrier' of S), A0).<*x*>
      = 'not' x by Def31;
      4+6 <= len the connectives of S by A1;
      then 3 <= len the connectives of S by XXREAL_0:2;
      then
A27:   3 in dom the connectives of S by FINSEQ_3:25;
      then
A28:   In((the connectives of S).3, the carrier' of S)
      = (the connectives of S).3 by SUBSET_1:def 8,FUNCT_1:102;
      3 in Seg 10;
      then
A29:   (the connectives of S).3 in (the connectives of S).:Seg 10
      by A27,FUNCT_1:def 6;
      then Den(In((the connectives of S).3, the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).3) by A28,A10,FUNCT_4:13
      .= Den(In((the connectives of S).3, the carrier' of S), A)
      by A28,A29,FUNCT_1:49;
      hence Den(In((the connectives of S).3, the carrier' of S), A0).<*x,y*>
      = x '&' y by Def31;
    end;
    A0 is non-empty;
    then reconsider A0 as bool-correct non-empty MSAlgebra over S by A20;
    take A0;
    thus A0 is (4,I) integer
    proof
      take K;
      thus K = I & (the connectives of S).4 is_of_type {},K by A9;
      thus (the Sorts of A0).K = INT by A9,A5,FUNCT_7:32;
      4+6 <= len the connectives of S by A1;
      then 4 <= len the connectives of S by XXREAL_0:2;
      then
A30:   4 in dom the connectives of S by FINSEQ_3:25;
      then
A31:   In((the connectives of S).4, the carrier' of S)
      = (the connectives of S).4 by FUNCT_1:102,SUBSET_1:def 8;
      4 in Seg 10;
      then
A32:   (the connectives of S).4 in (the connectives of S).:Seg 10
      by A30,FUNCT_1:def 6;
      then Den(In((the connectives of S).4,the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).4) by A31,A10,FUNCT_4:13
      .= Den(In((the connectives of S).4,the carrier' of S), A)
      by A31,A32,FUNCT_1:49;
      hence Den(In((the connectives of S).4, the carrier' of S), A0).{} = 0
      by A9;
      4+6 <= len the connectives of S by A1;
      then 5 <= len the connectives of S by XXREAL_0:2;
      then
A33:   5 in dom the connectives of S by FINSEQ_3:25;
      then
A34:   In((the connectives of S).5, the carrier' of S)
      = (the connectives of S).5 by FUNCT_1:102,SUBSET_1:def 8;
      5 in Seg 10;
      then
A35:   (the connectives of S).5 in (the connectives of S).:Seg 10
      by A33,FUNCT_1:def 6;
      then Den(In((the connectives of S).5,the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).5) by A34,A10,FUNCT_4:13
      .= Den(In((the connectives of S).5,the carrier' of S), A)
      by A34,A35,FUNCT_1:49;
      hence Den(In((the connectives of S).(4+1),
      the carrier' of S), A0).{} = 1 by A9;
      let i,j be Integer;
      4+6 <= len the connectives of S by A1;
      then 6 <= len the connectives of S by XXREAL_0:2;
      then
A36:   6 in dom the connectives of S by FINSEQ_3:25;
      then
A37:   In((the connectives of S).6, the carrier' of S)
      = (the connectives of S).6 by FUNCT_1:102,SUBSET_1:def 8;
      6 in Seg 10;
      then
A38:   (the connectives of S).6 in (the connectives of S).:Seg 10
      by A36,FUNCT_1:def 6;
      then Den(In((the connectives of S).6,the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).6) by A37,A10,FUNCT_4:13
      .= Den(In((the connectives of S).6,the carrier' of S), A)
      by A37,A38,FUNCT_1:49;
      hence Den(In((the connectives of S).(4+2),
      the carrier' of S), A0).<*i*> = -i by A9;
      4+6 <= len the connectives of S by A1;
      then 7 <= len the connectives of S by XXREAL_0:2;
      then
A39:   7 in dom the connectives of S by FINSEQ_3:25;
      then
A40:   In((the connectives of S).7, the carrier' of S)
      = (the connectives of S).7 by FUNCT_1:102,SUBSET_1:def 8;
      7 in Seg 10;
      then
A41:   (the connectives of S).7 in (the connectives of S).:Seg 10
      by A39,FUNCT_1:def 6;
      then Den(In((the connectives of S).7,the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).7) by A40,A10,FUNCT_4:13
      .= Den(In((the connectives of S).7,the carrier' of S), A)
      by A40,A41,FUNCT_1:49;
      hence Den(In((the connectives of S).(4+3),
      the carrier' of S), A0).<*i,j*> = i+j by A9;
      4+6 <= len the connectives of S by A1;
      then 8 <= len the connectives of S by XXREAL_0:2;
      then
A42:   8 in dom the connectives of S by FINSEQ_3:25;
      then
A43:   In((the connectives of S).8, the carrier' of S)
      = (the connectives of S).8 by FUNCT_1:102,SUBSET_1:def 8;
      8 in Seg 10;
      then
A44:   (the connectives of S).8 in (the connectives of S).:Seg 10
      by A42,FUNCT_1:def 6;
      then Den(In((the connectives of S).8,the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).8) by A43,A10,FUNCT_4:13
      .= Den(In((the connectives of S).8,the carrier' of S), A)
      by A43,A44,FUNCT_1:49;
      hence Den(In((the connectives of S).(4+4),
      the carrier' of S), A0).<*i,j*> = i*j by A9;
      hereby assume
A45:     j <> 0;
        4+6 <= len the connectives of S by A1;
        then 9 <= len the connectives of S by XXREAL_0:2;
        then
A46:     9 in dom the connectives of S by FINSEQ_3:25;
        then
A47:     In((the connectives of S).9, the carrier' of S)
        = (the connectives of S).9 by FUNCT_1:102,SUBSET_1:def 8;
        9 in Seg 10;
        then
A48:     (the connectives of S).9 in (the connectives of S).:Seg 10
        by A46,FUNCT_1:def 6;
        then Den(In((the connectives of S).9,the carrier' of S), A0)
        = ((the Charact of A)|((the connectives of S).:Seg 10))
        .((the connectives of S).9) by A47,A10,FUNCT_4:13
        .= Den(In((the connectives of S).9,the carrier' of S), A)
        by A47,A48,FUNCT_1:49;
        hence Den(In((the connectives of S).(4+5),
        the carrier' of S), A0).<*i,j*> = i div j by A45,A9;
      end;
      4+6 <= len the connectives of S by A1;
      then
A49:   10 in dom the connectives of S by FINSEQ_3:25;
      then
A50:   In((the connectives of S).10, the carrier' of S)
      = (the connectives of S).10 by FUNCT_1:102,SUBSET_1:def 8;
      10 in Seg 10;
      then
A51:   (the connectives of S).10 in (the connectives of S).:Seg 10
      by A49,FUNCT_1:def 6;
      then Den(In((the connectives of S).10,the carrier' of S), A0)
      = ((the Charact of A)|((the connectives of S).:Seg 10))
      .((the connectives of S).10) by A50,A10,FUNCT_4:13
      .= Den(In((the connectives of S).10,the carrier' of S), A)
      by A50,A51,FUNCT_1:49;
      hence Den(In((the connectives of S).(4+6), the carrier' of S), A0)
      .<*i,j*> = IFGT(i,j,FALSE,TRUE) by A9;
    end;
    dom the Sorts of A = the carrier of S by PARTFUN1:def 2;
    hence (the Sorts of A0).s = X by A4,FUNCT_7:31;
  end;

registration
  let S be 1-1-connectives (11,1,1)-array 11 array-correct (4,1) integer
  bool-correct non empty non void BoolSignature;
  cluster (11,1,1)-array (4,1) integer for bool-correct
  non-empty strict MSAlgebra over S;
  existence
  proof
    11=10+1 & 4+6<=10; then
    consider B being bool-correct non empty non void BoolSignature,
    C being non empty non void ConnectivesSignature such that
A1: the BoolSignature of S = B+*C &
    B is 10-connectives (4,1) integer & C is (1,1,1)-array &
    the carrier of B = the carrier of C &
    the carrier' of B = (the carrier' of S)\rng the connectives of C &
    the carrier' of C = rng the connectives of C &
    the connectives of B = (the connectives of S)|10 &
    the connectives of C = (the connectives of S)/^10 by Th63;
    reconsider B as (4,1) integer bool-correct non empty non void
    BoolSignature by A1;
    reconsider C as (1,1,1)-array non empty non void ConnectivesSignature
    by A1;
    set s = ((the ResultSort of C).((the connectives of C).2));
    1+3 <= len the connectives of C by Def50;
    then 2 <= len the connectives of C by XXREAL_0:2;
    then
A2: 2 in dom the connectives of C by FINSEQ_3:25;
    then
A3: s in the carrier of B by A1,FUNCT_1:102,FUNCT_2:5;
    consider J,K,L being Element of C such that
A4: L = 1 & K = 1 & J <> L & J <> K &
    (the connectives of C).1 is_of_type <*J,K*>, L &
    (the connectives of C).(1+1) is_of_type <*J,K,L*>, J &
    (the connectives of C).(1+2) is_of_type <*J*>, K &
    (the connectives of C).(1+3) is_of_type <*K,L*>, J by Def50;
A5: s <> 1 by A4;
A6: the connectives of S = (the connectives of B)^the connectives of C
    by A1,Def52;
A7: the ResultSort of S = (the ResultSort of B)+*the ResultSort of C
    by A1,Th51;
A8: (the ResultSort of S).((the connectives of S).(11+1))
    <> the bool-sort of S by Def53;
    len the connectives of B = 10 by A1;
    then (the connectives of C).(1+1) = (the connectives of S).(10+(1+1)) &
    (the connectives of C).(1+1) in the carrier' of C &
    dom the ResultSort of C = the carrier' of C
    by A6,A2,FUNCT_1:102,FINSEQ_1:def 7,FUNCT_2:def 1;
    then (the ResultSort of S).((the connectives of S).(10+(1+1))) = s &
    the bool-sort of B = the bool-sort of S by A1,Def52,A7,FUNCT_4:13;
    then consider A1 being bool-correct non-empty MSAlgebra over B
    such that
A9: A1 is (4,1) integer & (the Sorts of A1).s = INT^omega by A3,A5,A8,Th64;
    consider A2 being non-empty strict MSAlgebra over C such that
A10: A2 is (1,1,1)-array & the Sorts of A2 tolerates the Sorts of A1
    by A9,Th56;
    reconsider A = (B,A1)+*A2 as strict MSAlgebra over S by A1;
A11: A is non-empty;
    (B,A1)+*A2 is bool-correct by A10,Th57,A1,XBOOLE_1:79;
    then (the Sorts of (B,A1)+*A2).the bool-sort of S = BOOLEAN &
    Den(In((the connectives of B+*C).1, the carrier' of B+*C), (B,A1)+*A2).{}
    = TRUE &
    for x,y be boolean object holds
    Den(In((the connectives of B+*C).2, the carrier' of B+*C),
    (B,A1)+*A2).<*x*> = 'not' x &
    Den(In((the connectives of B+*C).3, the carrier' of B+*C),
    (B,A1)+*A2).<*x,y*> = x '&' y by A1;
    then (the Sorts of A).the bool-sort of S = BOOLEAN &
    Den(In((the connectives of S).1, the carrier' of S), A).{} = TRUE &
    for x,y be boolean object holds
    Den(In((the connectives of S).2, the carrier' of S), A).<*x*> = 'not' x &
    Den(In((the connectives of S).3, the carrier' of S), A).<*x,y*> = x '&' y
    by A1;
    then reconsider A = (B,A1)+*A2 as bool-correct non-empty strict
    MSAlgebra over S by A11,Def31;
    take A;
    11=10+1;
    hence A is (11,1,1)-array by A1,A10,Th59;
    thus A is (4,1) integer by A1,A10,A9,Th58,XBOOLE_1:79;
  end;
end;
