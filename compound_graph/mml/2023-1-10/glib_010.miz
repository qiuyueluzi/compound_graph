:: About Graph Mappings
::  by Sebastian Koch
::
:: Received August 29, 2019
:: Copyright (c) 2019-2022 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSEQ_1, SUBSET_1, RELAT_1, FUNCT_1, XXREAL_0, TARSKI,
      ARYTM_3, CARD_1, XBOOLE_0, NAT_1, ARYTM_1, GLIB_000, PBOOLE, PARTFUN1,
      FINSET_1, ZFMISC_1, RELAT_2, GLIB_002, FUNCOP_1, GLIB_001, ABIAN,
      AOFA_I00, FACIRC_1, MCART_1, FUNCT_2, GLIB_003, GLIB_009, MOD_4, INT_1,
      WAYBEL_0, RCOMP_1, MSAFREE2, RING_3, GLIB_006, GLIB_007, FUNCT_4,
      ORDINAL2, CHORD, CARD_2, SCMYCIEL, SGRAPH1, REWRITE1, GLIB_010;
 notations TARSKI, XBOOLE_0, XTUPLE_0, ZFMISC_1, SUBSET_1, SETFAM_1, RELAT_1,
      FUNCT_1, ORDINAL1, RELSET_1, PARTFUN1, FUNCT_2, BINOP_1, DOMAIN_1,
      SETWISEO, EQREL_1, FUNCOP_1, FUNCT_4, PARTFUN2, FINSET_1, CARD_1, PBOOLE,
      CARD_2, CARD_3, NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, NAT_1, INT_1,
      VALUED_0, NAT_D, FINSEQ_1, BSPACE, FINSEQ_4, ABIAN, GLIB_000, STRUCT_0,
      ALGSTR_0, GROUP_1, GROUP_2, GROUP_6, GLIB_001, GLIB_002, GLIB_003,
      AOFA_I00, CHORD, GLIB_006, GLIB_007, GLIB_008, GLIB_009, FUNCT_7;
 constructors DOMAIN_1, FUNCT_4, XXREAL_0, NAT_1, NAT_D, BINOP_2, CARD_2,
      FINSEQ_4, PBOOLE, ORDINAL3, WELLORD2, PARTFUN1, RELSET_1, GLIB_000,
      STRUCT_0, RELAT_1, FUNCT_1, FUNCT_2, ALGSTR_0, GROUP_1, GLIB_001, ABIAN,
      CARD_3, FINSEQ_1, GLIB_002, GLIB_003, SETFAM_1, EQREL_1, GROUP_2,
      GROUP_6, GLIB_006, GLIB_007, PARTFUN2, BSPACE, SETWISEO, CHORD, RAT_1,
      GLIB_008, FUNCT_7, GLIB_009;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1,
      XREAL_0, NAT_1, GLIB_000, GLIB_002, GLIB_003, INT_1, CARD_1, RELSET_1,
      XTUPLE_0, GLIB_001, ABIAN, GLIB_006, GLIB_008, NECKLACE, FUNCT_7,
      GLIB_009;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 theorems TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, XBOOLE_1, CARD_1, CARD_2,
      RELAT_1, RELSET_1, FUNCT_1, FUNCT_2, FUNCOP_1, PARTFUN1, FINSEQ_1,
      FINSEQ_2, FINSEQ_3, INT_1, POLYFORM, XREAL_1, XXREAL_0, ABIAN, GROUP_9,
      GLIB_000, GLIB_001, GLIB_002, GLIB_003, GLIB_006, GLIB_007, WELLORD2,
      XTUPLE_0, FUNCT_4, ORDINAL1, CHORD, GLIB_008, NECKLACE, GLIB_009;
 schemes FUNCT_1;

begin :: Preliminaries

:: into FUNCT_1 ?
theorem Th1:
  for A,B,C,D being Function st D*A = C|dom A
  holds (D|dom B)*A = C|dom(B*A)
proof
  let A,B,C,D be Function;
  assume A1: D*A = C|dom A;
  set f = (D|dom B)*A, g = C|dom(B*A);
  A2: dom f = A"dom(D|dom B) by RELAT_1:147
    .= A"(dom D /\ dom B) by RELAT_1:61
    .= A"dom D /\ A"dom B by FUNCT_1:68
    .= dom(D*A) /\ A"dom B by RELAT_1:147
    .= dom(C|dom A) /\ dom(B*A) by A1, RELAT_1:147
    .= dom C /\ dom A /\ dom(B*A) by RELAT_1:61
    .= dom C /\ (dom A /\ dom(B*A)) by XBOOLE_1:16
    .= dom C /\ dom(B*A) by RELAT_1:25, XBOOLE_1:28
    .= dom g by RELAT_1:61;
  for x being object st x in dom f holds f.x = g.x
  proof
    let x be object;
    assume A3: x in dom f;
    then A4: x in dom A & A.x in dom (D|dom B) by FUNCT_1:11;
    A5: x in dom g by A2, A3;
    thus f.x = (D|dom B).(A.x) by A3, FUNCT_1:12
      .= D.(A.x) by A4, FUNCT_1:47
      .= (D*A).x by A4, FUNCT_1:13
      .= C.x by A4, A1, FUNCT_1:49
      .= g.x by A5, FUNCT_1:47;
  end;
  hence thesis by A2, FUNCT_1:2;
end;

:: into FUNCT_1 ?
theorem Th2:
  for A being one-to-one Function, C,D being Function st D*A = C|dom A
  holds C*(A") = D|dom(A")
proof
  let A be one-to-one Function, C,D be Function;
  assume A1: D*A = C|dom A;
  A2: dom A = rng (A") & rng A = dom (A") by FUNCT_1:33;
  for y being object holds y in dom (C*(A")) iff y in dom (D|dom(A"))
  proof
    let y be object;
    hereby
      assume y in dom (C*(A"));
      then A3: y in dom (A") & A".y in dom C by FUNCT_1:11;
      then A".y in rng (A") by FUNCT_1:3;
      then A".y in dom A by FUNCT_1:33;
      then A".y in dom C /\ dom A by A3, XBOOLE_0:def 4;
      then A".y in dom(C|dom A) by RELAT_1:61;
      then A.(A".y) in dom D by A1, FUNCT_1:11;
      then y in dom D by A2, A3, FUNCT_1:35;
      then y in dom D /\ dom (A") by A3, XBOOLE_0:def 4;
      hence y in dom(D|dom(A")) by RELAT_1:61;
    end;
    assume y in dom (D|dom(A"));
    then y in dom D /\ dom (A") by RELAT_1:61;
    then A4: y in dom D & y in dom (A") by XBOOLE_0:def 4;
    then A5: A".y in rng (A") by FUNCT_1:3;
    A.(A".y) in dom D by A2, A4, FUNCT_1:35;
    then A".y in dom(D*A) by A2, A5, FUNCT_1:11;
    then A".y in dom C /\ dom A by A1, RELAT_1:61;
    then A".y in dom C by XBOOLE_0:def 4;
    hence y in dom(C*(A")) by A4, FUNCT_1:11;
  end;
  then A6: dom (C*(A")) = dom (D|dom(A")) by TARSKI:2;
  for y being object st y in dom (C*(A")) holds (C*(A")).y = (D|dom(A")).y
  proof
    let y be object;
    assume A7: y in dom (C*(A"));
    then A8: y in dom (A") & A".y in dom C by FUNCT_1:11;
    then A9: A".y in rng (A") by FUNCT_1:3;
    thus (C*(A")).y = C.(A".y) by A7, FUNCT_1:12
      .= (C|dom A).(A".y) by A2, A9, FUNCT_1:49
      .= D.(A.(A".y)) by A1, A2, A9, FUNCT_1:13
      .= D.y by A2, A8, FUNCT_1:35
      .= (D|dom (A")).y by A8, FUNCT_1:49;
  end;
  hence thesis by A6, FUNCT_1:2;
end;

:: BEGIN into GLIB_003 ?

registration
  let G be non _finite _Graph, X be set;
  cluster G.set(WeightSelector, X) -> non _finite;
  coherence
  proof
    G == G.set(WeightSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
  cluster G.set(ELabelSelector, X) -> non _finite;
  coherence
  proof
    G == G.set(ELabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
  cluster G.set(VLabelSelector, X) -> non _finite;
  coherence
  proof
    G == G.set(VLabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non loopless _Graph, X be set;
  cluster G.set(WeightSelector, X) -> non loopless;
  coherence
  proof
    G == G.set(WeightSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
  cluster G.set(ELabelSelector, X) -> non loopless;
  coherence
  proof
    G == G.set(ELabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
  cluster G.set(VLabelSelector, X) -> non loopless;
  coherence
  proof
    G == G.set(VLabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non non-multi _Graph, X be set;
  cluster G.set(WeightSelector, X) -> non non-multi;
  coherence
  proof
    G == G.set(WeightSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
  cluster G.set(ELabelSelector, X) -> non non-multi;
  coherence
  proof
    G == G.set(ELabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
  cluster G.set(VLabelSelector, X) -> non non-multi;
  coherence
  proof
    G == G.set(VLabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non non-Dmulti _Graph, X be set;
  cluster G.set(WeightSelector, X) -> non non-Dmulti;
  coherence
  proof
    G == G.set(WeightSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
  cluster G.set(ELabelSelector, X) -> non non-Dmulti;
  coherence
  proof
    G == G.set(ELabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
  cluster G.set(VLabelSelector, X) -> non non-Dmulti;
  coherence
  proof
    G == G.set(VLabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non connected _Graph, X be set;
  cluster G.set(WeightSelector, X) -> non connected;
  coherence
  proof
    G == G.set(WeightSelector, X) by GLIB_003:7;
    hence thesis by GLIB_002:8;
  end;
  cluster G.set(ELabelSelector, X) -> non connected;
  coherence
  proof
    G == G.set(ELabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_002:8;
  end;
  cluster G.set(VLabelSelector, X) -> non connected;
  coherence
  proof
    G == G.set(VLabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_002:8;
  end;
end;

registration
  let G be non acyclic _Graph, X be set;
  cluster G.set(WeightSelector, X) -> non acyclic;
  coherence
  proof
    G == G.set(WeightSelector, X) by GLIB_003:7;
    hence thesis by GLIB_002:44;
  end;
  cluster G.set(ELabelSelector, X) -> non acyclic;
  coherence
  proof
    G == G.set(ELabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_002:44;
  end;
  cluster G.set(VLabelSelector, X) -> non acyclic;
  coherence
  proof
    G == G.set(VLabelSelector, X) by GLIB_003:7;
    hence thesis by GLIB_002:44;
  end;
end;

definition
  let G be _Graph;
  attr G is elabel-full means
  :Def1:
  ELabelSelector in dom G &
  ex f being ManySortedSet of the_Edges_of G st G.ELabelSelector = f;
  attr G is vlabel-full means
  :Def2:
  VLabelSelector in dom G &
  ex f being ManySortedSet of the_Vertices_of G st G.VLabelSelector = f;
end;

registration
  cluster elabel-full -> [ELabeled] for _Graph;
  coherence
  proof
    let G be _Graph;
    assume A1: G is elabel-full;
    then consider f being ManySortedSet of the_Edges_of G such that
      A2: G.ELabelSelector = f;
    dom f = the_Edges_of G by PARTFUN1:def 2;
    hence thesis by A1, A2, GLIB_003:def 5;
  end;
  cluster vlabel-full -> [VLabeled] for _Graph;
  coherence
  proof
    let G be _Graph;
    assume A3: G is vlabel-full;
    then consider f being ManySortedSet of the_Vertices_of G such that
      A4: G.VLabelSelector = f;
    dom f = the_Vertices_of G by PARTFUN1:def 2;
    hence thesis by A3, A4, GLIB_003:def 6;
  end;
end;

definition
  let G be EGraph;
  attr G is elabel-distinct means
  :Def3:
  the_ELabel_of G is one-to-one;
end;

definition
  let G be VGraph;
  attr G is vlabel-distinct means
  :Def4:
  the_VLabel_of G is one-to-one;
end;

registration
  let G be _Graph;
  cluster G.set(ELabelSelector, id the_Edges_of G) -> elabel-full
    elabel-distinct;
  coherence
  proof
    set G0 = G.set(ELabelSelector, id the_Edges_of G);
    ELabelSelector in {ELabelSelector} by TARSKI:def 1;
    then ELabelSelector in dom G \/ {ELabelSelector} by XBOOLE_0:def 3;
    hence ELabelSelector in dom G0 by GLIB_000:7;
    thus ex f being ManySortedSet of the_Edges_of G0 st G0.ELabelSelector = f
    proof
      G == G0 by GLIB_003:7;
      then the_Edges_of G = the_Edges_of G0 by GLIB_000:def 34;
      then reconsider f = id the_Edges_of G
        as ManySortedSet of the_Edges_of G0;
      take f;
      thus G0.ELabelSelector = f by GLIB_000:8;
    end;
    G0.ELabelSelector = id the_Edges_of G by GLIB_000:8;
    hence thesis by GLIB_003:def 8;
  end;
  cluster G.set(VLabelSelector, id the_Vertices_of G) -> vlabel-full
    vlabel-distinct;
  coherence
  proof
    set G0 = G.set(VLabelSelector, id the_Vertices_of G);
    VLabelSelector in {VLabelSelector} by TARSKI:def 1;
    then VLabelSelector in dom G \/ {VLabelSelector} by XBOOLE_0:def 3;
    hence VLabelSelector in dom G0 by GLIB_000:7;
    thus ex f being ManySortedSet of the_Vertices_of G0
      st G0.VLabelSelector = f
    proof
      G == G0 by GLIB_003:7;
      then the_Vertices_of G = the_Vertices_of G0 by GLIB_000:def 34;
      then reconsider f = id the_Vertices_of G
        as ManySortedSet of the_Vertices_of G0;
      take f;
      thus G0.VLabelSelector = f by GLIB_000:8;
    end;
    G0.VLabelSelector = id the_Vertices_of G by GLIB_000:8;
    hence thesis by GLIB_003:def 9;
  end;
end;

registration
  cluster elabel-distinct elabel-full for EGraph;
  existence
  proof
    set G = the _Graph;
    take G.set(ELabelSelector, id the_Edges_of G);
    thus thesis;
  end;
  cluster vlabel-distinct vlabel-full for VGraph;
  existence
  proof
    set G = the _Graph;
    take G.set(VLabelSelector, id the_Vertices_of G);
    thus thesis;
  end;
end;

definition
  let G be elabel-full _Graph;
  redefine func the_ELabel_of G -> ManySortedSet of the_Edges_of G;
  coherence
  proof
    consider f being ManySortedSet of the_Edges_of G such that
      A1: G.ELabelSelector = f by Def1;
    thus thesis by A1, GLIB_003:def 8;
  end;
end;

definition
  let G be vlabel-full _Graph;
  redefine func the_VLabel_of G -> ManySortedSet of the_Vertices_of G;
  coherence
  proof
    consider f being ManySortedSet of the_Vertices_of G such that
      A1: G.VLabelSelector = f by Def2;
    thus thesis by A1, GLIB_003:def 9;
  end;
end;

registration
  let G be elabel-distinct EGraph;
  cluster the_ELabel_of G -> one-to-one;
  coherence by Def3;
end;

registration
  let G be vlabel-distinct VGraph;
  cluster the_VLabel_of G -> one-to-one;
  coherence by Def4;
end;

registration
  let G be elabel-full _Graph, X be set;
  cluster G.set(WeightSelector, X) -> elabel-full;
  coherence
  proof
    set G0 = G.set(WeightSelector, X);
    ELabelSelector in dom G by Def1;
    then ELabelSelector in dom G \/ {WeightSelector} by XBOOLE_0:def 3;
    hence ELabelSelector in dom G0 by GLIB_000:7;
    consider f being ManySortedSet of the_Edges_of G such that
      A1: G.ELabelSelector = f by Def1;
    G == G0 by GLIB_003:7;
    then the_Edges_of G = the_Edges_of G0 by GLIB_000:def 34;
    then reconsider f as ManySortedSet of the_Edges_of G0;
    take f;
    WeightSelector <> ELabelSelector by GLIB_003:def 1, GLIB_003:def 2;
    hence thesis by A1, GLIB_000:9;
  end;
  cluster G.set(VLabelSelector, X) -> elabel-full;
  coherence
  proof
    set G0 = G.set(VLabelSelector, X);
    ELabelSelector in dom G by Def1;
    then ELabelSelector in dom G \/ {VLabelSelector} by XBOOLE_0:def 3;
    hence ELabelSelector in dom G0 by GLIB_000:7;
    consider f being ManySortedSet of the_Edges_of G such that
      A2: G.ELabelSelector = f by Def1;
    G == G0 by GLIB_003:7;
    then the_Edges_of G = the_Edges_of G0 by GLIB_000:def 34;
    then reconsider f as ManySortedSet of the_Edges_of G0;
    take f;
    VLabelSelector <> ELabelSelector by GLIB_003:def 3, GLIB_003:def 2;
    hence thesis by A2, GLIB_000:9;
  end;
end;

registration
  let G be vlabel-full _Graph, X be set;
  cluster G.set(WeightSelector, X) -> vlabel-full;
  coherence
  proof
    set G0 = G.set(WeightSelector, X);
    VLabelSelector in dom G by Def2;
    then VLabelSelector in dom G \/ {WeightSelector} by XBOOLE_0:def 3;
    hence VLabelSelector in dom G0 by GLIB_000:7;
    consider f being ManySortedSet of the_Vertices_of G such that
      A1: G.VLabelSelector = f by Def2;
    G == G0 by GLIB_003:7;
    then the_Vertices_of G = the_Vertices_of G0 by GLIB_000:def 34;
    then reconsider f as ManySortedSet of the_Vertices_of G0;
    take f;
    WeightSelector <> VLabelSelector by GLIB_003:def 1, GLIB_003:def 3;
    hence thesis by A1, GLIB_000:9;
  end;
  cluster G.set(ELabelSelector, X) -> vlabel-full;
  coherence
  proof
    set G0 = G.set(ELabelSelector, X);
    VLabelSelector in dom G by Def2;
    then VLabelSelector in dom G \/ {ELabelSelector} by XBOOLE_0:def 3;
    hence VLabelSelector in dom G0 by GLIB_000:7;
    consider f being ManySortedSet of the_Vertices_of G such that
      A2: G.VLabelSelector = f by Def2;
    G == G0 by GLIB_003:7;
    then the_Vertices_of G = the_Vertices_of G0 by GLIB_000:def 34;
    then reconsider f as ManySortedSet of the_Vertices_of G0;
    take f;
    ELabelSelector <> VLabelSelector by GLIB_003:def 3, GLIB_003:def 2;
    hence thesis by A2, GLIB_000:9;
  end;
end;

registration
  let G be elabel-distinct EGraph, X be set;
  cluster G.set(WeightSelector, X) -> elabel-distinct;
  coherence
  proof
    set G0 = G.set(WeightSelector, X);
    G.ELabelSelector = G0.ELabelSelector by GLIB_000:9, GLIB_003:def 1, def 2;
    then the_ELabel_of G = G0.ELabelSelector by GLIB_003:def 8;
    hence thesis by GLIB_003:def 8;
  end;
  cluster G.set(VLabelSelector, X) -> elabel-distinct;
  coherence
  proof
    set G0 = G.set(VLabelSelector, X);
    G.ELabelSelector = G0.ELabelSelector by GLIB_000:9, GLIB_003:def 2, def 3;
    then the_ELabel_of G = G0.ELabelSelector by GLIB_003:def 8;
    hence thesis by GLIB_003:def 8;
  end;
end;

registration
  let G be vlabel-distinct VGraph, X be set;
  cluster G.set(WeightSelector, X) -> vlabel-distinct;
  coherence
  proof
    set G0 = G.set(WeightSelector, X);
    G.VLabelSelector = G0.VLabelSelector by GLIB_000:9, GLIB_003:def 1, def 3;
    then the_VLabel_of G = G0.VLabelSelector by GLIB_003:def 9;
    hence thesis by GLIB_003:def 9;
  end;
  cluster G.set(ELabelSelector, X) -> vlabel-distinct;
  coherence
  proof
    set G0 = G.set(ELabelSelector, X);
    G.VLabelSelector = G0.VLabelSelector by GLIB_000:9, GLIB_003:def 2, def 3;
    then the_VLabel_of G = G0.VLabelSelector by GLIB_003:def 9;
    hence thesis by GLIB_003:def 9;
  end;
end;

registration
  cluster elabel-full elabel-distinct vlabel-full vlabel-distinct for EVGraph;
  existence
  proof
    set G = the elabel-full elabel-distinct EGraph;
    set G0 = G.set(VLabelSelector, id the_Vertices_of G);
    take G0;
    thus thesis;
  end;
end;

:: END into GLIB_003 ?

registration
  let G1 be WGraph, E be set, G2 be reverseEdgeDirections of G1, E;
  cluster G2.set(WeightSelector, the_Weight_of G1) -> [Weighted];
  coherence
  proof
    the_Edges_of G1 = the_Edges_of G2 by GLIB_007:4;
    hence thesis;
  end;
end;

registration
  let G1 be EGraph, E be set, G2 be reverseEdgeDirections of G1, E;
  cluster G2.set(ELabelSelector, the_ELabel_of G1) -> [ELabeled];
  coherence
  proof
    now
      set G3 = G2.set(ELabelSelector, the_ELabel_of G1);
      ELabelSelector in {ELabelSelector} by TARSKI:def 1;
      then ELabelSelector in dom G2 \/ {ELabelSelector} by XBOOLE_0:def 3;
      hence ELabelSelector in dom G3 by GLIB_000:7;
      consider f being Function such that
        A1: G1.ELabelSelector = f & dom f c= the_Edges_of G1 by GLIB_003:def 5;
      G2 == G3 by GLIB_003:7;
      then the_Edges_of G2 = the_Edges_of G3 by GLIB_000:def 34;
      then A2: the_Edges_of G1 = the_Edges_of G3 by GLIB_007:4;
      take f;
      thus G3.ELabelSelector = the_ELabel_of G1 by GLIB_000:8
        .= f by A1, GLIB_003:def 8;
      thus dom f c= the_Edges_of G3 by A1, A2;
    end;
    hence thesis by GLIB_003:def 5;
  end;
end;

registration
  let G1 be VGraph, V be set, G2 be reverseEdgeDirections of G1, V;
  cluster G2.set(VLabelSelector, the_VLabel_of G1) -> [VLabeled];
  coherence
  proof
    now
      set G3 = G2.set(VLabelSelector, the_VLabel_of G1);
      VLabelSelector in {VLabelSelector} by TARSKI:def 1;
      then VLabelSelector in dom G2 \/ {VLabelSelector} by XBOOLE_0:def 3;
      hence VLabelSelector in dom G3 by GLIB_000:7;
      consider f being Function such that
        A1: G1.VLabelSelector = f & dom f c= the_Vertices_of G1
        by GLIB_003:def 6;
      G2 == G3 by GLIB_003:7;
      then the_Vertices_of G2 = the_Vertices_of G3 by GLIB_000:def 34;
      then A2: the_Vertices_of G1 = the_Vertices_of G3 by GLIB_007:4;
      take f;
      thus G3.VLabelSelector = the_VLabel_of G1 by GLIB_000:8
        .= f by A1, GLIB_003:def 9;
      thus dom f c= the_Vertices_of G3 by A1, A2;
    end;
    hence thesis by GLIB_003:def 6;
  end;
end;

registration
  let G1 be elabel-full _Graph, E be set, G2 be reverseEdgeDirections of G1, E;
  cluster G2.set(ELabelSelector, the_ELabel_of G1) -> elabel-full;
  coherence
  proof
    set G3 = G2.set(ELabelSelector, the_ELabel_of G1);
    ELabelSelector in {ELabelSelector} by TARSKI:def 1;
    then ELabelSelector in dom G2 \/ {ELabelSelector} by XBOOLE_0:def 3;
    hence ELabelSelector in dom G3 by GLIB_000:7;
    consider f being ManySortedSet of the_Edges_of G1 such that
      A1: G1.ELabelSelector = f by Def1;
    G2 == G3 by GLIB_003:7;
    then the_Edges_of G2 = the_Edges_of G3 by GLIB_000:def 34;
    then the_Edges_of G1 = the_Edges_of G3 by GLIB_007:4;
    then reconsider f as ManySortedSet of the_Edges_of G3;
    take f;
    thus G3.ELabelSelector = the_ELabel_of G1 by GLIB_000:8
      .= f by A1, GLIB_003:def 8;
  end;
end;

registration
  let G1 be vlabel-full _Graph, V be set, G2 be reverseEdgeDirections of G1, V;
  cluster G2.set(VLabelSelector, the_VLabel_of G1) -> vlabel-full;
  coherence
  proof
    set G3 = G2.set(VLabelSelector, the_VLabel_of G1);
    VLabelSelector in {VLabelSelector} by TARSKI:def 1;
    then VLabelSelector in dom G2 \/ {VLabelSelector} by XBOOLE_0:def 3;
    hence VLabelSelector in dom G3 by GLIB_000:7;
    consider f being ManySortedSet of the_Vertices_of G1 such that
      A1: G1.VLabelSelector = f by Def2;
    G2 == G3 by GLIB_003:7;
    then the_Vertices_of G2 = the_Vertices_of G3 by GLIB_000:def 34;
    then the_Vertices_of G1 = the_Vertices_of G3 by GLIB_007:4;
    then reconsider f as ManySortedSet of the_Vertices_of G3;
    take f;
    thus G3.VLabelSelector = the_VLabel_of G1 by GLIB_000:8
      .= f by A1, GLIB_003:def 9;
  end;
end;

registration
  let G1 be elabel-distinct EGraph, E be set;
  let G2 be reverseEdgeDirections of G1, E;
  cluster G2.set(ELabelSelector, the_ELabel_of G1) -> elabel-distinct;
  coherence
  proof
    set G3 = G2.set(ELabelSelector, the_ELabel_of G1);
    the_ELabel_of G3 = G3.ELabelSelector by GLIB_003:def 8
      .= the_ELabel_of G1 by GLIB_000:8;
    hence thesis;
  end;
end;

registration
  let G1 be vlabel-distinct VGraph, E be set;
  let G2 be reverseEdgeDirections of G1, E;
  cluster G2.set(VLabelSelector, the_VLabel_of G1) -> vlabel-distinct;
  coherence
  proof
    set G3 = G2.set(VLabelSelector, the_VLabel_of G1);
    the_VLabel_of G3 = G3.VLabelSelector by GLIB_003:def 9
      .= the_VLabel_of G1 by GLIB_000:8;
    hence thesis;
  end;
end;

begin :: Ordering of a Graph

definition
  func OrderingSelector -> Element of NAT equals
  8;
  correctness;
end;

definition
  let G be GraphStruct;
  attr G is [Ordered] means
  :Def6:
  OrderingSelector in dom G & G.OrderingSelector
  is Enumeration of the_Vertices_of G;
end;

Lm1:
  not OrderingSelector in _GraphSelectors
    by GLIB_000:def 5, GLIB_000:1, ENUMSET1:def 2;

registration
  let G be _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> [Graph-like];
  coherence by Lm1, GLIB_000:10;
end;

registration
  let G be _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non plain;
  coherence
  proof
    A1: dom G.set(OrderingSelector,X) = dom G \/ {OrderingSelector}
      by GLIB_000:7;
    OrderingSelector in {OrderingSelector} by TARSKI:def 1;
    then A2: OrderingSelector in dom G.set(OrderingSelector,X)
      by A1, XBOOLE_0:def 3;
    not OrderingSelector in _GraphSelectors
      by GLIB_000:def 5, GLIB_000:1, ENUMSET1:def 2;
    hence thesis by A2, GLIB_009:def 1;
  end;
end;

registration
  let G be WGraph, X be set;
  cluster G.set(OrderingSelector, X) -> [Weighted];
  coherence
  proof
    set G2 = G.set(OrderingSelector, X);
    A1: G2.WeightSelector = G.WeightSelector by GLIB_003:def 1, GLIB_000:9;
    WeightSelector in dom G by GLIB_003:def 4;
    then WeightSelector in dom G \/ {OrderingSelector} by XBOOLE_0:def 3;
    then A2: WeightSelector in dom G2 by GLIB_000:7;
    the_Edges_of G = the_Edges_of G2 by Lm1, GLIB_000:10;
    then G2.WeightSelector is ManySortedSet of the_Edges_of G2
      by A1, GLIB_003:def 4;
    hence thesis by A2, GLIB_003:def 4;
  end;
end;

registration
  let G be EGraph, X be set;
  cluster G.set(OrderingSelector, X) -> [ELabeled];
  coherence
  proof
    set G2 = G.set(OrderingSelector, X);
    A1: G2.ELabelSelector = G.ELabelSelector by GLIB_003:def 2, GLIB_000:9;
    ELabelSelector in dom G by GLIB_003:def 5;
    then ELabelSelector in dom G \/ {OrderingSelector} by XBOOLE_0:def 3;
    then A2: ELabelSelector in dom G2 by GLIB_000:7;
    the_Edges_of G = the_Edges_of G2 by Lm1, GLIB_000:10;
    then ex f being Function st G2.ELabelSelector = f &
      dom f c= the_Edges_of G2 by A1, GLIB_003:def 5;
    hence thesis by A2, GLIB_003:def 5;
  end;
end;

registration
  let G be VGraph, X be set;
  cluster G.set(OrderingSelector, X) -> [VLabeled];
  coherence
  proof
    set G2 = G.set(OrderingSelector, X);
    A1: G2.VLabelSelector = G.VLabelSelector by GLIB_003:def 3, GLIB_000:9;
    VLabelSelector in dom G by GLIB_003:def 6;
    then VLabelSelector in dom G \/ {OrderingSelector} by XBOOLE_0:def 3;
    then A2: VLabelSelector in dom G2 by GLIB_000:7;
    the_Vertices_of G = the_Vertices_of G2 by Lm1, GLIB_000:10;
    then ex f being Function st G2.VLabelSelector = f &
      dom f c= the_Vertices_of G2 by A1, GLIB_003:def 6;
    hence thesis by A2, GLIB_003:def 6;
  end;
end;

registration
  let G be _Graph, X be Enumeration of the_Vertices_of G;
  cluster G.set(OrderingSelector, X) -> [Ordered];
  coherence
  proof
    set G2 = G.set(OrderingSelector, X);
    OrderingSelector in {OrderingSelector} by TARSKI:def 1;
    then OrderingSelector in dom G \/ {OrderingSelector} by XBOOLE_0:def 3;
    hence OrderingSelector in dom G2 by GLIB_000:7;
    not OrderingSelector in _GraphSelectors
      by GLIB_000:1, GLIB_000:def 5, ENUMSET1:def 2;
    then A1: the_Vertices_of G = the_Vertices_of G2 by GLIB_000:10;
    thus G2.OrderingSelector is Enumeration of the_Vertices_of G2
      by A1, GLIB_000:8;
  end;
end;

registration
  cluster [Graph-like] [Weighted] [ELabeled] [VLabeled] [Ordered]
    for GraphStruct;
  existence
  proof
    set G1 = (the [Graph-like] [Weighted] [ELabeled] [VLabeled] GraphStruct);
    set G2 = G1.set(OrderingSelector, the Enumeration of the_Vertices_of G1);
    take G2;
    thus thesis;
  end;
end;

:: the definitions of O,WO,EO,VO,WEO,WVO,EVO and WEVOGraph are omitted
:: as is would simply clutter the already rich graph notation

definition
  let G be [Ordered] _Graph;
  func the_Ordering_of G -> Enumeration of the_Vertices_of G equals
  G.OrderingSelector;
  correctness by Def6;
end;

theorem Th3:
  for G being _Graph, X being set holds G == G.set(OrderingSelector, X)
proof
  let G be _Graph, X be set;
  set G2 = G.set(OrderingSelector, X);
  the_Vertices_of G = the_Vertices_of G2 &
    the_Edges_of G = the_Edges_of G2 &
    the_Source_of G = the_Source_of G2 &
    the_Target_of G = the_Target_of G2 by Lm1, GLIB_000:10;
  hence thesis by GLIB_000:def 34;
end;

registration
  let G be elabel-full _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> elabel-full;
  coherence
  proof
    set G0 = G.set(OrderingSelector, X);
    ELabelSelector in dom G by Def1;
    then ELabelSelector in dom G \/ {OrderingSelector} by XBOOLE_0:def 3;
    hence ELabelSelector in dom G0 by GLIB_000:7;
    consider f being ManySortedSet of the_Edges_of G such that
      A1: G.ELabelSelector = f by Def1;
    G == G0 by Th3;
    then the_Edges_of G = the_Edges_of G0 by GLIB_000:def 34;
    then reconsider f as ManySortedSet of the_Edges_of G0;
    take f;
    OrderingSelector <> ELabelSelector by GLIB_003:def 2;
    hence thesis by A1, GLIB_000:9;
  end;
end;

registration
  let G be vlabel-full _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> vlabel-full;
  coherence
  proof
    set G0 = G.set(OrderingSelector, X);
    VLabelSelector in dom G by Def2;
    then VLabelSelector in dom G \/ {OrderingSelector} by XBOOLE_0:def 3;
    hence VLabelSelector in dom G0 by GLIB_000:7;
    consider f being ManySortedSet of the_Vertices_of G such that
      A1: G.VLabelSelector = f by Def2;
    G == G0 by Th3;
    then the_Vertices_of G = the_Vertices_of G0 by GLIB_000:def 34;
    then reconsider f as ManySortedSet of the_Vertices_of G0;
    take f;
    OrderingSelector <> VLabelSelector by GLIB_003:def 3;
    hence thesis by A1, GLIB_000:9;
  end;
end;

registration
  let G be elabel-distinct EGraph, X be set;
  cluster G.set(OrderingSelector, X) -> elabel-distinct;
  coherence
  proof
    set G0 = G.set(OrderingSelector, X);
    G.ELabelSelector = G0.ELabelSelector by GLIB_000:9, GLIB_003:def 2;
    then the_ELabel_of G = G0.ELabelSelector by GLIB_003:def 8;
    hence thesis by GLIB_003:def 8;
  end;
end;

registration
  let G be vlabel-distinct VGraph, X be set;
  cluster G.set(OrderingSelector, X) -> vlabel-distinct;
  coherence
  proof
    set G0 = G.set(OrderingSelector, X);
    G.VLabelSelector = G0.VLabelSelector by GLIB_000:9, GLIB_003:def 3;
    then the_VLabel_of G = G0.VLabelSelector by GLIB_003:def 9;
    hence thesis by GLIB_003:def 9;
  end;
end;

registration
  let G be _finite _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> _finite;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non _finite _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non _finite;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be loopless _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> loopless;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non loopless _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non loopless;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be _trivial _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> _trivial;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non _trivial _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non _trivial;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non-multi _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non-multi;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non non-multi _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non non-multi;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non-Dmulti _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non-Dmulti;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be non non-Dmulti _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non non-Dmulti;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be connected _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> connected;
  coherence by Th3, GLIB_002:8;
end;

registration
  let G be non connected _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non connected;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_002:8;
  end;
end;

registration
  let G be acyclic _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> acyclic;
  coherence by Th3, GLIB_002:44;
end;

registration
  let G be non acyclic _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non acyclic;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_002:44;
  end;
end;

registration
  let G be edgeless _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> edgeless;
  coherence by Th3, GLIB_008:52;
end;

registration
  let G be non edgeless _Graph, X be set;
  cluster G.set(OrderingSelector, X) -> non edgeless;
  coherence
  proof
    G == G.set(OrderingSelector, X) by Th3;
    hence thesis by GLIB_008:52;
  end;
end;

registration
  let G be [Ordered] _Graph, X be set;
  cluster G.set(WeightSelector, X) -> [Ordered];
  coherence
  proof
    set G1 = G.set(WeightSelector, X);
    OrderingSelector in dom G by Def6;
    then OrderingSelector in dom G \/ {WeightSelector} by XBOOLE_0:def 3;
    hence OrderingSelector in dom G1 by GLIB_000:7;
    G == G1 by GLIB_003:7;
    then A1: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 34;
    G.OrderingSelector = G1.OrderingSelector by GLIB_003:def 1, GLIB_000:9;
    hence thesis by A1, Def6;
  end;
  cluster G.set(ELabelSelector, X) -> [Ordered];
  coherence
  proof
    set G1 = G.set(ELabelSelector, X);
    OrderingSelector in dom G by Def6;
    then OrderingSelector in dom G \/ {ELabelSelector} by XBOOLE_0:def 3;
    hence OrderingSelector in dom G1 by GLIB_000:7;
    G == G1 by GLIB_003:7;
    then A2: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 34;
    G.OrderingSelector = G1.OrderingSelector by GLIB_003:def 2, GLIB_000:9;
    hence thesis by A2, Def6;
  end;
  cluster G.set(VLabelSelector, X) -> [Ordered];
  coherence
  proof
    set G1 = G.set(VLabelSelector, X);
    OrderingSelector in dom G by Def6;
    then OrderingSelector in dom G \/ {VLabelSelector} by XBOOLE_0:def 3;
    hence OrderingSelector in dom G1 by GLIB_000:7;
    G == G1 by GLIB_003:7;
    then A3: the_Vertices_of G = the_Vertices_of G1 by GLIB_000:def 34;
    G.OrderingSelector = G1.OrderingSelector by GLIB_003:def 3, GLIB_000:9;
    hence thesis by A3, Def6;
  end;
end;

:: Subgraph properties for ordered graphs are mostly omitted
:: because removing vertices of the graph creates gaps in the ordering.
:: A theorem describing how to fill these gaps (in such a way that:
:: for v1,v2 in V(G2) holds O(G2).v1 c= O(G2).v2 implies O(G1).v1 c= O(G1).v2)
:: is desirable, but will not be discussed here.

registration
  let G1 be [Ordered] _Graph, G2 be spanning Subgraph of G1;
  cluster G2.set(OrderingSelector, the_Ordering_of G1) -> [Ordered];
  coherence
  proof
    the_Vertices_of G1 = the_Vertices_of G2 by GLIB_000:def 33;
    hence thesis;
  end;
end;

registration
  let G1 be [Ordered] _Graph, E be set, G2 be reverseEdgeDirections of G1, E;
  cluster G2.set(OrderingSelector, the_Ordering_of G1) -> [Ordered];
  coherence
  proof
    the_Vertices_of G1 = the_Vertices_of G2 by GLIB_007:4;
    hence thesis;
  end;
end;

begin :: Graph Mappings

Lm2:
  for G1, G2 being _Graph
  ex f, g being Function st [{},{}] = [f,g] &
    dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
    dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 &
    (for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
    (for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 iff g.e Joins f.v,f.w,G2) &
    for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2
proof
  let G1, G2 be _Graph;
  set f = the empty Function;
  take f,f;
  thus [{},{}] = [f,f];
  thus dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
    dom f c= the_Edges_of G1 & rng f c= the_Edges_of G2 by XBOOLE_1:2;
  thus thesis;
end;

definition
  let G1, G2 be _Graph;
  mode PGraphMapping of G1, G2 means :: P is short for "partial"
  :Def8:
  ex f, g being Function st it = [f,g] &
    dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
    dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 &
    (for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
    for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2;
  existence
  proof
    consider f, g being Function such that
      A1: [{},{}] = [f,g] and
      A2: dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
        dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 and
      A3: (for e being object holds e in dom g implies
        (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) and
      (for e,v,w being object st e in dom g & v in dom f & w in dom f
        holds e Joins v,w,G1 iff g.e Joins f.v,f.w,G2) and
      A4: for e,v,w being object st e in dom g & v in dom f & w in dom f
        holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Lm2;
    take [{},{}];
    thus thesis by A1, A2, A3, A4;
  end;
end;

Lm3:
  for G1, G2 being _Graph holds [{},{}] is PGraphMapping of G1, G2
proof
  let G1, G2 be _Graph;
  consider f, g being Function such that
    A1: [{},{}] = [f,g] and
    A2: dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
      dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 and
    A3: (for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) and
    (for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 iff g.e Joins f.v,f.w,G2) and
    A4: for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Lm2;
  thus thesis by A1, A2, A3, A4, Def8;
end;

registration
  let G1, G2 be _Graph;
  cluster -> pair for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    consider f, g being Function such that
      A1: F = [f,g] and
      dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
      dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 &
      (for e being object holds e in dom g implies
        (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
      for e,v,w being object st e in dom g & v in dom f & w in dom f
        holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Def8;
    thus thesis by A1;
  end;
end;

notation
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  synonym F_V for F`1;
  synonym F_E for F`2;
end;

registration
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  reduce [ F_V , F_E ] to F;
  reducibility;
end;

registration
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  cluster F_V -> Function-like Relation-like for set;
  coherence
  proof
    let X be set;
    assume A1: X = F_V;
    consider f,g being Function such that
      A2: F = [f,g] and
      dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
      dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 &
      (for e being object holds e in dom g implies
        (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
      for e,v,w being object st e in dom g & v in dom f & w in dom f
        holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Def8;
    thus thesis by A1, A2;
  end;
  cluster F_E -> Function-like Relation-like for set;
  coherence
  proof
    let X be set;
    assume A3: X = F_E;
    consider f,g being Function such that
      A4: F = [f,g] and
      dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
      dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 &
      (for e being object holds e in dom g implies
        (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
      for e,v,w being object st e in dom g & v in dom f & w in dom f
        holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Def8;
    thus thesis by A3, A4;
  end;
end;

registration
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  cluster F_V -> the_Vertices_of G1-defined the_Vertices_of G2-valued
    for Function;
  coherence
  proof
    let X be Function;
    assume A1: X = F_V;
    consider f,g being Function such that
      A2: F = [f,g] and
      A3: dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 and
      dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 &
      (for e being object holds e in dom g implies
        (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
      for e,v,w being object st e in dom g & v in dom f & w in dom f
        holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Def8;
    thus thesis by A1, A2, A3, RELAT_1:def 18, RELAT_1:def 19;
  end;
  cluster F_E -> the_Edges_of G1-defined the_Edges_of G2-valued
    for Function;
  coherence
  proof
    let X be Function;
    assume A4: X = F_E;
    consider f,g being Function such that
      A5: F = [f,g] and
      dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 and
      A6: dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 and
      (for e being object holds e in dom g implies
        (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
      for e,v,w being object st e in dom g & v in dom f & w in dom f
        holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Def8;
    thus thesis by A4, A5, A6, RELAT_1:def 18, RELAT_1:def 19;
  end;
end;

definition
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  redefine func F_V -> PartFunc of the_Vertices_of G1, the_Vertices_of G2;
  coherence
  proof
    reconsider f = F_V as the_Vertices_of G1-defined the_Vertices_of G2-valued
      Function by TARSKI:1;
    dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2;
    hence thesis by RELSET_1:4;
  end;
  redefine func F_E -> PartFunc of the_Edges_of G1, the_Edges_of G2;
  coherence
  proof
    reconsider f = F_E as the_Edges_of G1-defined the_Edges_of G2-valued
      Function by TARSKI:1;
    dom f c= the_Edges_of G1 & rng f c= the_Edges_of G2;
    hence thesis by RELSET_1:4;
  end;
end;

theorem Th4:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
  holds e Joins v,w,G1 implies F_E.e Joins F_V.v, F_V.w, G2
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  let e,v,w be object;
  assume A1: e in dom F_E & v in dom F_V & w in dom F_V;
  consider f,g being Function such that
    A2: F = [f,g] and
    dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
    dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 &
    (for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) and
    A3: for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Def8;
  thus thesis by A1, A2, A3;
end;

theorem Th5:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  for e being object st e in dom F_E
  holds (the_Source_of G1).e in dom F_V & (the_Target_of G1).e in dom F_V
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  let e be object;
  assume A1: e in dom F_E;
  consider f,g being Function such that
    A2: F = [f,g] and
    dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2 &
    dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 and
    A3: for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f and
    for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Def8;
  thus thesis by A1, A2, A3;
end;

theorem Th6:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  for e being object st e in rng F_E
  holds (the_Source_of G2).e in rng F_V & (the_Target_of G2).e in rng F_V
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  let e be object;
  assume e in rng F_E;
  then consider e0 being object such that
    A1: e0 in dom F_E & F_E.e0 = e by FUNCT_1:def 3;
  A2: (the_Source_of G1).e0 in dom F_V & (the_Target_of G1).e0 in dom F_V
    by A1, Th5;
  e0 Joins (the_Source_of G1).e0, (the_Target_of G1).e0, G1
    by A1, GLIB_000:def 13;
  then F_E.e0 Joins F_V.((the_Source_of G1).e0), F_V.((the_Target_of G1).e0),
    G2 by A1, A2, Th4;
  then per cases by A1, GLIB_000:def 13;
  suppose (the_Source_of G2).e = F_V.((the_Source_of G1).e0) &
      (the_Target_of G2).e = F_V.((the_Target_of G1).e0);
    hence thesis by A2, FUNCT_1:def 3;
  end;
  suppose (the_Target_of G2).e = F_V.((the_Source_of G1).e0) &
      (the_Source_of G2).e = F_V.((the_Target_of G1).e0);
    hence thesis by A2, FUNCT_1:def 3;
  end;
end;

theorem Th7:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  holds dom F_E c= G1.edgesBetween(dom F_V) &
    rng F_E c= G2.edgesBetween(rng F_V)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  for e being object holds e in dom F_E implies e in G1.edgesBetween(dom F_V)
  proof
    let e be object;
    assume A1: e in dom F_E;
    then (the_Source_of G1).e in dom F_V & (the_Target_of G1).e in dom F_V
      by Th5;
    hence thesis by A1, GLIB_000:31;
  end;
  hence dom F_E c= G1.edgesBetween(dom F_V) by TARSKI:def 3;
  for e being object holds e in rng F_E implies e in G2.edgesBetween(rng F_V)
  proof
    let e be object;
    assume A2: e in rng F_E;
    then (the_Source_of G2).e in rng F_V & (the_Target_of G2).e in rng F_V
      by Th6;
    hence thesis by A2, GLIB_000:31;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th8:
  for G1, G2 being _Graph
  for f being PartFunc of the_Vertices_of G1, the_Vertices_of G2
  for g being PartFunc of the_Edges_of G1, the_Edges_of G2
  st ((for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
    for e,v,w being object st e in dom g & v in dom f & w in dom f
    holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2)
  holds [f,g] is PGraphMapping of G1, G2
proof
  let G1, G2 be _Graph;
  let f be PartFunc of the_Vertices_of G1, the_Vertices_of G2;
  let g be PartFunc of the_Edges_of G1, the_Edges_of G2;
  assume that
    A1: for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f and
    A2: for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2;
  A3: dom f c= the_Vertices_of G1 & rng f c= the_Vertices_of G2;
  A4: dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2;
  take f,g;
  thus thesis by A1, A2, A3, A4;
end;

theorem Th9:
  for G1, G2, G3, G4 being _Graph, F being PGraphMapping of G1, G2
  st G1 == G3 & G2 == G4 holds F is PGraphMapping of G3, G4
proof
  let G1, G2, G3, G4 being _Graph, F be PGraphMapping of G1, G2;
  assume A1: G1 == G3 & G2 == G4;
  then A2: the_Vertices_of G1 = the_Vertices_of G3 &
    the_Edges_of G1 = the_Edges_of G3 &
    the_Vertices_of G2 = the_Vertices_of G4 &
    the_Edges_of G2 = the_Edges_of G4 by GLIB_000:def 34;
  then reconsider
    f = F_V as PartFunc of the_Vertices_of G3, the_Vertices_of G4;
  reconsider
    g = F_E as PartFunc of the_Edges_of G3, the_Edges_of G4 by A2;
  now
    hereby
      let e be object;
      assume e in dom g;
      then (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f
        by Th5;
      hence (the_Source_of G3).e in dom f & (the_Target_of G3).e in dom f
        by A1, GLIB_000:def 34;
    end;
    let e,v,w be object;
    assume e in dom g & v in dom f & w in dom f;
    then e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Th4;
    hence e Joins v,w,G3 implies g.e Joins f.v,f.w,G4 by A1, GLIB_000:88;
  end;
  then [f,g] is PGraphMapping of G3, G4 by Th8;
  hence thesis;
end;

theorem Th10:
  for G1, G2, G3, G4 being _Graph, F being PGraphMapping of G1, G2
  st (ex E1, E2 being set st G3 is reverseEdgeDirections of G1, E1 &
    G4 is reverseEdgeDirections of G2, E2)
  holds F is PGraphMapping of G3, G4
proof
  let G1, G2, G3, G4 being _Graph, F be PGraphMapping of G1, G2;
  given E1, E2 being set such that
    A1: G3 is reverseEdgeDirections of G1, E1 &
      G4 is reverseEdgeDirections of G2, E2;
  A2: the_Vertices_of G1 = the_Vertices_of G3 &
    the_Edges_of G1 = the_Edges_of G3 &
    the_Vertices_of G2 = the_Vertices_of G4 &
    the_Edges_of G2 = the_Edges_of G4 by A1, GLIB_007:4;
  then reconsider
    f = F_V as PartFunc of the_Vertices_of G3, the_Vertices_of G4;
  reconsider
    g = F_E as PartFunc of the_Edges_of G3, the_Edges_of G4 by A2;
  now
    hereby
      let e be object;
      assume A3: e in dom g;
      then A4: (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f
        by Th5;
      e in the_Edges_of G1 by A2, A3;
      then A5: e DJoins (the_Source_of G1).e, (the_Target_of G1).e, G1
        by GLIB_000:def 14;
      per cases;
      suppose A6: E1 c= the_Edges_of G1;
        per cases;
        suppose e in E1;
          then e DJoins (the_Target_of G1).e, (the_Source_of G1).e, G3
            by A1, A5, A6, GLIB_007:7;
          hence (the_Source_of G3).e in dom f & (the_Target_of G3).e in dom f
            by A4, GLIB_000:def 14;
        end;
        suppose not e in E1;
          then e DJoins (the_Source_of G1).e, (the_Target_of G1).e, G3
            by A1, A5, A6, GLIB_007:8;
          hence (the_Source_of G3).e in dom f & (the_Target_of G3).e in dom f
            by A4, GLIB_000:def 14;
        end;
      end;
      suppose not E1 c= the_Edges_of G1;
        then G1 == G3 by A1, GLIB_007:def 1;
        hence (the_Source_of G3).e in dom f & (the_Target_of G3).e in dom f
          by A4, GLIB_000:def 34;
      end;
    end;
    let e,v,w be object;
    assume e in dom g & v in dom f & w in dom f;
    then e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by Th4;
    hence e Joins v,w,G3 implies g.e Joins f.v,f.w,G4 by A1, GLIB_007:9;
  end;
  then [f,g] is PGraphMapping of G3, G4 by Th8;
  hence thesis;
end;

definition
  let G be _Graph;
  func id G -> PGraphMapping of G, G equals
  [id the_Vertices_of G, id the_Edges_of G];
  coherence
  proof
    set IT = [id the_Vertices_of G, id the_Edges_of G];
    A1: for e being object st e in dom id the_Edges_of G holds
      (the_Source_of G).e in dom id the_Vertices_of G &
      (the_Target_of G).e in dom id the_Vertices_of G by FUNCT_2:5;
    now
      let e,v,w be object;
      assume A2: e in dom id the_Edges_of G & v in dom id the_Vertices_of G &
        w in dom id the_Vertices_of G;
      assume e Joins v,w,G;
      then (id the_Edges_of G).e Joins v,w,G by A2, FUNCT_1:18;
      then (id the_Edges_of G).e Joins (id the_Vertices_of G).v,w,G
        by A2, FUNCT_1:18;
      hence (id the_Edges_of G).e Joins (id the_Vertices_of G).v,
        (id the_Vertices_of G).w, G by A2, FUNCT_1:18;
    end;
    hence thesis by A1, Th8;
  end;
end;

theorem
  for G1, G2 being _Graph st G1 == G2
  holds id G1 = id G2 & id G1 is PGraphMapping of G1, G2
proof
  let G1, G2 be _Graph;
  assume A1: G1 == G2;
  thus id G1
     = [id the_Vertices_of G2, id the_Edges_of G1] by A1, GLIB_000:def 34
    .= id G2 by A1, GLIB_000:def 34;
  thus thesis by A1, Th9;
end;

theorem
  for G1 being _Graph, E being set, G2 being reverseEdgeDirections of G1, E
  holds id G1 = id G2 & id G1 is PGraphMapping of G1, G2
proof
  let G1 be _Graph, E be set;
  let G2 be reverseEdgeDirections of G1, E;
  thus id G1 = [id the_Vertices_of G2, id the_Edges_of G1] by GLIB_007:4
    .= id G2 by GLIB_007:4;
  ex E1, E2 being set st G1 is reverseEdgeDirections of G1, E1
    & G2 is reverseEdgeDirections of G1, E2
  proof
    take {},E;
    thus thesis by GLIB_009:43;
  end;
  hence thesis by Th10;
end;

definition
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  attr F is empty means
  :Def10:
  dom F_V is empty;
  attr F is total means :: this is the basic homomorphism definition
  :Def11:
  dom F_V = the_Vertices_of G1 & dom F_E = the_Edges_of G1;
  attr F is onto means
  :Def12:
  rng F_V = the_Vertices_of G2 & rng F_E = the_Edges_of G2;
  attr F is one-to-one means
  :Def13:
  F_V is one-to-one & F_E is one-to-one;
  attr F is directed means
  :Def14:
  for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
  holds e DJoins v,w,G1 implies F_E.e DJoins F_V.v, F_V.w, G2;
  attr F is semi-continuous means
  :Def15:
  for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
  holds F_E.e Joins F_V.v, F_V.w, G2 implies e Joins v,w,G1;
  attr F is continuous means
  :Def16:
  for e9,v,w being object st v in dom F_V & w in dom F_V &
    e9 Joins F_V.v,F_V.w,G2
  ex e being object st e Joins v,w,G1 & e in dom F_E & F_E.e = e9;
  attr F is semi-Dcontinuous means
  :Def17:
  for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
  holds F_E.e DJoins F_V.v, F_V.w, G2 implies e DJoins v,w,G1;
  attr F is Dcontinuous means
  :Def18:
  for e9,v,w being object st v in dom F_V & w in dom F_V &
    e9 DJoins F_V.v,F_V.w,G2
  ex e being object st e DJoins v,w,G1 & e in dom F_E & F_E.e = e9;
end;

:: at first properties of these attributes for the PGM are studied
:: regardless of the kinds of graph involved

theorem Th13:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  holds F is directed iff
    for e being object st e in dom F_E
    holds (the_Source_of G2).(F_E.e) = F_V.((the_Source_of G1).e) &
      (the_Target_of G2).(F_E.e) = F_V.((the_Target_of G1).e)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  thus F is directed implies
    for e being object st e in dom F_E
    holds (the_Source_of G2).(F_E.e) = F_V.((the_Source_of G1).e) &
      (the_Target_of G2).(F_E.e) = F_V.((the_Target_of G1).e)
  proof
    assume A1: F is directed;
    let e be object;
    assume A2: e in dom F_E;
    then A3: (the_Source_of G1).e in dom F_V & (the_Target_of G1).e in dom F_V
      by Th5;
    e DJoins (the_Source_of G1).e, (the_Target_of G1).e, G1
      by A2, GLIB_000:def 14;
    then F_E.e DJoins F_V.((the_Source_of G1).e), F_V.((the_Target_of G1).e),
      G2 by A1, A2, A3;
    hence thesis by GLIB_000:def 14;
  end;
  assume A4: for e being object st e in dom F_E
    holds (the_Source_of G2).(F_E.e) = F_V.((the_Source_of G1).e) &
      (the_Target_of G2).(F_E.e) = F_V.((the_Target_of G1).e);
  let e,v,w be object;
  assume A5: e in dom F_E & v in dom F_V & w in dom F_V;
  assume e DJoins v,w,G1;
  then A6: (the_Source_of G1).e = v & (the_Target_of G1).e = w
    by GLIB_000:def 14;
  (the_Source_of G2).(F_E.e) = F_V.v & (the_Target_of G2).(F_E.e) = F_V.w
    by A4, A5, A6;
  hence thesis by A5, PARTFUN1:4, GLIB_000:def 14;
end;

:: |dom F_E is probably not required, as the PGM property
:: enforces such a relationship between F_V and F_E
theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  holds F is directed iff
    the_Source_of G2 * F_E = F_V * ((the_Source_of G1)|dom F_E) &
      the_Target_of G2 * F_E = F_V * ((the_Target_of G1)|dom F_E)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  hereby
    assume F is directed;
    then A1: for e being object st e in dom F_E
      holds (the_Source_of G2).(F_E.e) = F_V.((the_Source_of G1).e) &
        (the_Target_of G2).(F_E.e) = F_V.((the_Target_of G1).e) by Th13;
    for x being object holds x in dom (the_Source_of G2 * F_E)
      iff x in dom (F_V * ((the_Source_of G1)|dom F_E))
    proof
      let x be object;
      hereby
        assume x in dom (the_Source_of G2 * F_E);
        then A2: x in dom F_E by FUNCT_1:11;
        then x in the_Edges_of G1;
        then x in dom the_Source_of G1 by FUNCT_2:def 1;
        then A3: x in dom ((the_Source_of G1)|dom F_E) by A2, RELAT_1:57;
        (the_Source_of G1).x in dom F_V by A2, Th5;
        then ((the_Source_of G1)|dom F_E).x in dom F_V by A2, FUNCT_1:49;
        hence x in dom (F_V * ((the_Source_of G1)|dom F_E)) by A3, FUNCT_1:11;
      end;
      assume x in dom (F_V * ((the_Source_of G1)|dom F_E));
      then x in dom ((the_Source_of G1)|dom F_E) by FUNCT_1:11;
      then A4: x in dom (the_Source_of G1) & x in dom F_E by RELAT_1:57;
      then F_E.x in the_Edges_of G2 by PARTFUN1:4;
      then F_E.x in dom (the_Source_of G2) by FUNCT_2:def 1;
      hence thesis by A4, FUNCT_1:11;
    end;
    then A5: dom (the_Source_of G2 * F_E)
      = dom (F_V * ((the_Source_of G1)|dom F_E)) by TARSKI:2;
    for x being object st x in dom (the_Source_of G2 * F_E) holds
      (the_Source_of G2 * F_E).x = (F_V * ((the_Source_of G1)|dom F_E)).x
    proof
      let x be object;
      assume A6: x in dom (the_Source_of G2 * F_E);
      then A7: x in dom F_E by FUNCT_1:11;
      A8: x in dom ((the_Source_of G1)|dom F_E) by A5, A6, FUNCT_1:11;
      thus (the_Source_of G2 * F_E).x
         = (the_Source_of G2).(F_E.x) by A6, FUNCT_1:12
        .= F_V.((the_Source_of G1).x) by A1, A7
        .= F_V.(((the_Source_of G1)|dom F_E).x) by A8, FUNCT_1:47
        .= (F_V * ((the_Source_of G1)|dom F_E)).x by A8, FUNCT_1:13;
    end;
    hence the_Source_of G2 * F_E = F_V * ((the_Source_of G1)|dom F_E)
      by A5, FUNCT_1:2;
    for x being object holds x in dom (the_Target_of G2 * F_E)
      iff x in dom (F_V * ((the_Target_of G1)|dom F_E))
    proof
      let x be object;
      hereby
        assume x in dom (the_Target_of G2 * F_E);
        then A9: x in dom F_E by FUNCT_1:11;
        then x in the_Edges_of G1;
        then x in dom the_Target_of G1 by FUNCT_2:def 1;
        then A10: x in dom ((the_Target_of G1)|dom F_E) by A9, RELAT_1:57;
        (the_Target_of G1).x in dom F_V by A9, Th5;
        then ((the_Target_of G1)|dom F_E).x in dom F_V by A9, FUNCT_1:49;
        hence x in dom (F_V * ((the_Target_of G1)|dom F_E)) by A10, FUNCT_1:11;
      end;
      assume x in dom (F_V * ((the_Target_of G1)|dom F_E));
      then x in dom ((the_Target_of G1)|dom F_E) by FUNCT_1:11;
      then A11: x in dom (the_Target_of G1) & x in dom F_E by RELAT_1:57;
      then F_E.x in the_Edges_of G2 by PARTFUN1:4;
      then F_E.x in dom (the_Target_of G2) by FUNCT_2:def 1;
      hence thesis by A11, FUNCT_1:11;
    end;
    then A12: dom (the_Target_of G2 * F_E)
      = dom (F_V * ((the_Target_of G1)|dom F_E)) by TARSKI:2;
    for x being object st x in dom (the_Target_of G2 * F_E) holds
      (the_Target_of G2 * F_E).x = (F_V * ((the_Target_of G1)|dom F_E)).x
    proof
      let x be object;
      assume A13: x in dom (the_Target_of G2 * F_E);
      then A14: x in dom F_E by FUNCT_1:11;
      x in dom (F_V * ((the_Target_of G1)|dom F_E)) by A12, A13;
      then A15: x in dom ((the_Target_of G1)|dom F_E) by FUNCT_1:11;
      thus (the_Target_of G2 * F_E).x
         = (the_Target_of G2).(F_E.x) by A13, FUNCT_1:12
        .= F_V.((the_Target_of G1).x) by A1, A14
        .= F_V.(((the_Target_of G1)|dom F_E).x) by A15, FUNCT_1:47
        .= (F_V * ((the_Target_of G1)|dom F_E)).x by A15, FUNCT_1:13;
    end;
    hence the_Target_of G2 * F_E = F_V * ((the_Target_of G1)|dom F_E)
      by A12, FUNCT_1:2;
  end;
  assume A16: the_Source_of G2 * F_E = F_V * ((the_Source_of G1)|dom F_E) &
    the_Target_of G2 * F_E = F_V * ((the_Target_of G1)|dom F_E);
  now
    let x be object;
    assume A17: x in dom F_E;
    then x in the_Edges_of G1;
    then x in dom the_Source_of G1 & x in dom the_Target_of G1
      by FUNCT_2:def 1;
    then A18: x in dom ((the_Source_of G1)|dom F_E) &
      x in dom ((the_Target_of G1)|dom F_E) by A17, RELAT_1:57;
    thus (the_Source_of G2).(F_E.x)
       = (the_Source_of G2 * F_E).x by A17, FUNCT_1:13
      .= F_V.(((the_Source_of G1)|dom F_E).x) by A16, A18, FUNCT_1:13
      .= F_V.((the_Source_of G1).x) by A17, FUNCT_1:49;
    thus (the_Target_of G2).(F_E.x)
       = (the_Target_of G2 * F_E).x by A17, FUNCT_1:13
      .= F_V.(((the_Target_of G1)|dom F_E).x) by A16, A18, FUNCT_1:13
      .= F_V.((the_Target_of G1).x) by A17, FUNCT_1:49;
  end;
  hence thesis by Th13;
end;

theorem Th15:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  holds F is semi-continuous iff
    for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
    holds e Joins v,w,G1 iff F_E.e Joins F_V.v, F_V.w, G2 by Th4;

theorem Th16:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  holds F is semi-Dcontinuous iff
    for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
    holds e DJoins v,w,G1 iff F_E.e DJoins F_V.v, F_V.w, G2
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  thus F is semi-Dcontinuous implies
    for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
      holds e DJoins v,w,G1 iff F_E.e DJoins F_V.v, F_V.w, G2
  proof
    assume A1: F is semi-Dcontinuous;
    let e,v,w be object;
    assume A2: e in dom F_E & v in dom F_V & w in dom F_V;
    thus e DJoins v,w,G1 implies F_E.e DJoins F_V.v, F_V.w, G2
    proof
      assume A3: e DJoins v,w,G1;
      then e Joins v,w,G1 by GLIB_000:16;
      then A4: F_E.e Joins F_V.v, F_V.w, G2 by A2, Th4;
      assume A5: not F_E.e DJoins F_V.v, F_V.w, G2;
      then A6: F_E.e DJoins F_V.w, F_V.v, G2 by A4, GLIB_000:16;
      then e DJoins w,v,G1 by A1, A2;
      then (the_Source_of G1).e = w & (the_Target_of G1).e = v
        by GLIB_000:def 14;
      then v = w by A3, GLIB_000:def 14;
      hence contradiction by A5, A6;
    end;
    thus thesis by A1, A2;
  end;
  thus thesis;
end;

registration
  let G1, G2 be _Graph;
  cluster empty one-to-one Dcontinuous directed continuous
    semi-Dcontinuous semi-continuous for PGraphMapping of G1, G2;
  existence
  proof
    reconsider F = [{},{}] as PGraphMapping of G1, G2 by Lm3;
    take F;
    thus thesis;
  end;
  cluster non empty one-to-one directed semi-Dcontinuous semi-continuous
    for PGraphMapping of G1, G2;
  existence
  proof
    set v1 = the Vertex of G1, v2 = the Vertex of G2;
    set h = v1 .--> v2;
    A1: h = {v1} --> v2 by FUNCOP_1:def 9;
    set F = [h,{}];
    :: show that F is a graph mapping by showing the definition properties
    now
      reconsider f = h as Function;
      reconsider g = {} as Function;
      take f,g;
      thus F = [f,g];
      dom f = {v1} by A1;
      hence dom f c= the_Vertices_of G1;
      A2: rng f c= {v2} by A1, FUNCOP_1:13;
      thus rng f c= the_Vertices_of G2 by A2, XBOOLE_1:1;
      dom g = {} & rng g = {};
      hence dom g c= the_Edges_of G1 & rng g c= the_Edges_of G2 by XBOOLE_1:2;
      thus for e being object st e in dom g
        holds (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f;
      let e,v,w be object;
      assume e in dom g & v in dom f & w in dom f; :: leads to contradiction
      hence e Joins v,w,G1 implies g.e Joins f.v,f.w,G2;
    end;
    then reconsider F as PGraphMapping of G1, G2 by Def8;
    take F;
    thus F is non empty;
    thus thesis;
  end;
end;

registration
  let G1, G2 be _Graph, F be empty PGraphMapping of G1, G2;
  cluster F_V -> empty for set;
  coherence
  proof
    let X be set;
    assume A1: X = F_V;
    dom F_V is empty by Def10;
    hence thesis by A1;
  end;
  cluster F_E -> empty for set;
  coherence
  proof
    let X be set;
    assume A2: X = F_E;
    F_E is empty
    proof
      assume A3: F_E is non empty;
      set e = the Element of dom F_E;
      (the_Source_of G1).e in dom F_V by A3, Th5;
      hence contradiction;
    end;
    hence thesis by A2;
  end;
end;

registration
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  cluster F_V -> non empty for set;
  coherence
  proof
    let X be set;
    assume A1: X = F_V;
    dom F_V is non empty by Def10;
    hence thesis by A1;
  end;
end;

registration
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  cluster F_V -> one-to-one for Function;
  coherence by Def13;
  cluster F_E -> one-to-one for Function;
  coherence by Def13;
end;

theorem Th17:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F_V is one-to-one holds F is semi-continuous
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F_V is one-to-one;
  let e,v,w be object;
  assume that
    A2: e in dom F_E & v in dom F_V & w in dom F_V and
    A3: F_E.e Joins F_V.v, F_V.w, G2;
  set v1 = (the_Source_of G1).e, v2 = (the_Target_of G1).e;
  A4: e Joins v1,v2,G1 by A2, GLIB_000:def 13;
  A5: v1 in dom F_V & v2 in dom F_V by A2, Th5;
  then F_E.e Joins F_V.v1,F_V.v2,G2 by A2, A4, Th4;
  then per cases by A3, GLIB_000:15;
  suppose F_V.v1 = F_V.v & F_V.v2 = F_V.w;
    then v1 = v & v2 = w by A1, A2, A5, FUNCT_1:def 4;
    hence e Joins v,w,G1 by A4;
  end;
  suppose F_V.v1 = F_V.w & F_V.v2 = F_V.v;
    then v1 = w & v2 = v by A1, A2, A5, FUNCT_1:def 4;
    hence e Joins v,w,G1 by A4, GLIB_000:14;
  end;
end;

theorem Th18:
  for G1, G2 being _Graph, F being directed PGraphMapping of G1, G2
  st F_V is one-to-one holds F is semi-Dcontinuous
proof
  let G1, G2 be _Graph, F be directed PGraphMapping of G1, G2;
  assume A1: F_V is one-to-one;
  let e,v,w be object;
  assume that
    A2: e in dom F_E & v in dom F_V & w in dom F_V and
    A3: F_E.e DJoins F_V.v, F_V.w, G2;
  set v1 = (the_Source_of G1).e, v2 = (the_Target_of G1).e;
  A4: e DJoins v1,v2,G1 by A2, GLIB_000:def 14;
  A5: v1 in dom F_V & v2 in dom F_V by A2, Th5;
  then F_E.e DJoins F_V.v1,F_V.v2,G2 by A2, A4, Def14;
  then F_V.v1 = F_V.v & F_V.v2 = F_V.w by A3, GLIB_009:6;
  then v1 = v & v2 = w by A1, A2, A5, FUNCT_1:def 4;
  hence e DJoins v,w,G1 by A4;
end;

theorem Th19:
  for G1, G2 being _Graph, F being semi-continuous PGraphMapping of G1, G2
  st rng F_E = the_Edges_of G2 holds F is continuous
proof
  let G1, G2 be _Graph;
  let F be semi-continuous PGraphMapping of G1, G2;
  assume A1: rng F_E = the_Edges_of G2;
  let e9,v,w be object;
  assume A2: v in dom F_V & w in dom F_V & e9 Joins F_V.v,F_V.w,G2;
  then e9 in the_Edges_of G2 by GLIB_000:def 13;
  then consider e being object such that
    A3: e in dom F_E & F_E.e = e9 by A1, FUNCT_1:def 3;
  take e;
  thus thesis by A2, A3, Def15;
end;

theorem Th20:
  for G1, G2 being _Graph, F being semi-Dcontinuous PGraphMapping of G1, G2
  st rng F_E = the_Edges_of G2 holds F is Dcontinuous
proof
  let G1, G2 be _Graph;
  let F be semi-Dcontinuous PGraphMapping of G1, G2;
  assume A1: rng F_E = the_Edges_of G2;
  let e9,v,w be object;
  assume A2: v in dom F_V & w in dom F_V & e9 DJoins F_V.v,F_V.w,G2;
  then e9 in the_Edges_of G2 by GLIB_000:def 14;
  then consider e being object such that
    A3: e in dom F_E & F_E.e = e9 by A1, FUNCT_1:def 3;
  take e;
  thus thesis by A2, A3, Def17;
end;

theorem Th21:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F_V is one-to-one & rng F_E = the_Edges_of G2 holds F is continuous
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F_V is one-to-one & rng F_E = the_Edges_of G2;
  then F is semi-continuous by Th17;
  hence thesis by A1, Th19;
end;

theorem Th22:
  for G1, G2 being _Graph, F being directed PGraphMapping of G1, G2
  st F_V is one-to-one & rng F_E = the_Edges_of G2 holds F is Dcontinuous
proof
  let G1, G2 be _Graph, F be directed PGraphMapping of G1, G2;
  assume A1: F_V is one-to-one & rng F_E = the_Edges_of G2;
  then F is semi-Dcontinuous by Th18;
  hence thesis by A1, Th20;
end;

theorem
  for G1, G2 being _Graph, F being continuous PGraphMapping of G1, G2
  st F_E is one-to-one holds F is semi-continuous
proof
  let G1, G2 be _Graph;
  let F be continuous PGraphMapping of G1, G2;
  assume A1: F_E is one-to-one;
  let e,v,w be object;
  assume that
    A2: e in dom F_E & v in dom F_V & w in dom F_V and
    A3: F_E.e Joins F_V.v, F_V.w, G2;
  consider e0 being object such that
    A4: e0 Joins v,w,G1 & e0 in dom F_E & F_E.e0 = F_E.e by A2, A3, Def16;
  thus e Joins v,w,G1 by A1, A2, A4, FUNCT_1:def 4;
end;

theorem Th24:
  for G1, G2 being _Graph, F being Dcontinuous PGraphMapping of G1, G2
  st F_E is one-to-one holds F is semi-Dcontinuous
proof
  let G1, G2 be _Graph;
  let F be Dcontinuous PGraphMapping of G1, G2;
  assume A1: F_E is one-to-one;
  let e,v,w be object;
  assume that
    A2: e in dom F_E & v in dom F_V & w in dom F_V and
    A3: F_E.e DJoins F_V.v, F_V.w, G2;
  consider e0 being object such that
    A4: e0 DJoins v,w,G1 & e0 in dom F_E & F_E.e0 = F_E.e by A2, A3, Def18;
  thus e DJoins v,w,G1 by A1, A2, A4, FUNCT_1:def 4;
end;

theorem Th25:
  for G1, G2 being _Graph, F being Dcontinuous PGraphMapping of G1, G2
  st F_E is one-to-one holds F is directed
proof
  let G1, G2 be _Graph;
  let F be Dcontinuous PGraphMapping of G1, G2;
  assume A1: F_E is one-to-one;
  now
    let e,v,w be object;
    assume A2: e in dom F_E & v in dom F_V & w in dom F_V;
    assume A3: e DJoins v,w,G1;
    then e Joins v,w,G1 by GLIB_000:16;
    then per cases by A2, Th4, GLIB_000:16;
    suppose F_E.e DJoins F_V.v,F_V.w,G2;
      hence F_E.e DJoins F_V.v,F_V.w,G2;
    end;
    suppose A4: F_E.e DJoins F_V.w,F_V.v,G2;
      then consider e0 being object such that
        A5: e0 DJoins w,v,G1 & e0 in dom F_E & F_E.e0 = F_E.e by A2, Def18;
      e0 = e by A1, A2, A5, FUNCT_1:def 4;
      then v = w by A3, A5, GLIB_009:6;
      hence F_E.e DJoins F_V.v,F_V.w,G2 by A4;
    end;
  end;
  hence F is directed;
  thus thesis;
end;

theorem Th26:
  for G1, G2 being _Graph
  for F being semi-continuous PGraphMapping of G1, G2, v1, v2 being object
  st v1 in dom F_V & v2 in dom F_V & F_V.v1 = F_V.v2 &
    ex e, w being object
    st e in dom F_E & w in dom F_V & F_E.e Joins F_V.v1, F_V.w, G2
  holds v1 = v2
proof
  let G1, G2 be _Graph, F be semi-continuous PGraphMapping of G1, G2;
  let v1, v2 be object;
  assume that
    A1: v1 in dom F_V & v2 in dom F_V & F_V.v1 = F_V.v2 and
    A2: ex e, w being object st e in dom F_E & w in dom F_V &
      F_E.e Joins F_V.v1, F_V.w, G2;
  consider e, w being object such that
    A3: e in dom F_E & w in dom F_V & F_E.e Joins F_V.v1, F_V.w, G2 by A2;
  A4: e Joins v1,w,G1 by A1, A3, Def15;
  e Joins v2,w,G1 by A1, A3, Def15;
  then per cases by A4, GLIB_000:15;
  suppose v1 = v2 & w = w;
    hence v1 = v2;
  end;
  suppose v1 = w & w = v2;
    hence v1 = v2;
  end;
end;

:: a special case of the following theorem is when G2 is without isolated
:: vertices and F is onto
theorem
  for G1, G2 being _Graph
  for F being semi-continuous PGraphMapping of G1, G2
  st for v being object st v in dom F_V holds ex e, w being object
    st e in dom F_E & w in dom F_V & F_E.e Joins F_V.v, F_V.w, G2
  holds F_V is one-to-one
proof
  let G1, G2 be _Graph, F be semi-continuous PGraphMapping of G1, G2;
  assume A1: for v being object st v in dom F_V holds ex e, w being object
    st e in dom F_E & w in dom F_V & F_E.e Joins F_V.v, F_V.w, G2;
  now
    let v1, v2 be object;
    assume A2: v1 in dom F_V & v2 in dom F_V & F_V.v1 = F_V.v2;
    then consider e, w being object such that
      A3: e in dom F_E & w in dom F_V & F_E.e Joins F_V.v1, F_V.w, G2 by A1;
    thus v1 = v2 by A2, A3, Th26;
  end;
  hence thesis by FUNCT_1:def 4;
end;

theorem Th28:
  for G1, G2 being _Graph
  for F being semi-Dcontinuous PGraphMapping of G1, G2, v1, v2 being object
  st v1 in dom F_V & v2 in dom F_V & F_V.v1 = F_V.v2 &
    ex e, w being object
    st e in dom F_E & w in dom F_V & F_E.e DJoins F_V.v1, F_V.w, G2
  holds v1 = v2
proof
  let G1, G2 be _Graph, F be semi-Dcontinuous PGraphMapping of G1, G2;
  let v1, v2 be object;
  assume that
    A1: v1 in dom F_V & v2 in dom F_V & F_V.v1 = F_V.v2 and
    A2: ex e, w being object st e in dom F_E & w in dom F_V &
      F_E.e DJoins F_V.v1, F_V.w, G2;
  consider e, w being object such that
    A3: e in dom F_E & w in dom F_V & F_E.e DJoins F_V.v1, F_V.w, G2 by A2;
  A4: e DJoins v1,w,G1 by A1, A3, Def17;
  e DJoins v2,w,G1 by A1, A3, Def17;
  hence v1 = v2 by A4, GLIB_009:6;
end;

:: again, a special case of the following theorem is when G2 is without
:: isolated vertices and F is onto
theorem
  for G1, G2 being _Graph
  for F being semi-Dcontinuous PGraphMapping of G1, G2
  st for v being object st v in dom F_V holds ex e, w being object
    st e in dom F_E & w in dom F_V & F_E.e DJoins F_V.v, F_V.w, G2
  holds F_V is one-to-one
proof
  let G1, G2 be _Graph, F be semi-Dcontinuous PGraphMapping of G1, G2;
  assume A1: for v being object st v in dom F_V holds ex e, w being object
    st e in dom F_E & w in dom F_V & F_E.e DJoins F_V.v, F_V.w, G2;
  now
    let v1, v2 be object;
    assume A2: v1 in dom F_V & v2 in dom F_V & F_V.v1 = F_V.v2;
    then consider e, w being object such that
      A3: e in dom F_E & w in dom F_V & F_E.e DJoins F_V.v1, F_V.w, G2 by A1;
    thus v1 = v2 by A2, A3, Th28;
  end;
  hence thesis by FUNCT_1:def 4;
end;

registration
  let G1, G2 be _Graph;
  cluster one-to-one -> semi-continuous for PGraphMapping of G1, G2;
  coherence by Th17;
  cluster one-to-one directed -> semi-Dcontinuous for PGraphMapping of G1, G2;
  coherence by Th18;
  cluster one-to-one onto -> continuous for PGraphMapping of G1, G2;
  coherence by Th21;
  cluster directed one-to-one onto -> Dcontinuous for PGraphMapping of G1, G2;
  coherence by Th22;
  cluster semi-continuous onto -> continuous for PGraphMapping of G1, G2;
  coherence by Th19;
  cluster semi-Dcontinuous -> directed semi-continuous
    for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    assume A1: F is semi-Dcontinuous;
    hence F is directed by Th16;
    let e,v,w be object;
    assume A2: e in dom F_E & v in dom F_V & w in dom F_V;
    assume F_E.e Joins F_V.v, F_V.w, G2;
    then per cases by GLIB_000:16;
    suppose F_E.e DJoins F_V.v, F_V.w, G2;
      then e DJoins v,w,G1 by A1, A2;
      hence e Joins v,w,G1 by GLIB_000:16;
    end;
    suppose F_E.e DJoins F_V.w, F_V.v, G2;
      then e DJoins w,v,G1 by A1, A2;
      hence e Joins v,w,G1 by GLIB_000:16;
    end;
  end;
  cluster semi-Dcontinuous onto -> Dcontinuous for PGraphMapping of G1, G2;
  coherence by Th20;
  cluster Dcontinuous -> continuous for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    assume A3: F is Dcontinuous;
    let e9,v,w be object;
    assume A4: v in dom F_V & w in dom F_V & e9 Joins F_V.v,F_V.w,G2;
    then per cases by GLIB_000:16;
    suppose e9 DJoins F_V.v, F_V.w, G2;
      then consider e being object such that
        A5: e DJoins v,w,G1 & e in dom F_E & F_E.e = e9 by A3, A4;
      take e;
      thus thesis by A5, GLIB_000:16;
    end;
    suppose e9 DJoins F_V.w, F_V.v, G2;
      then consider e being object such that
        A6: e DJoins w,v,G1 & e in dom F_E & F_E.e = e9 by A3, A4;
      take e;
      thus thesis by A6, GLIB_000:16;
    end;
  end;
  cluster Dcontinuous one-to-one -> directed semi-Dcontinuous
    for PGraphMapping of G1, G2;
  coherence by Th25, Th24;
  cluster empty -> one-to-one Dcontinuous directed continuous
    for PGraphMapping of G1, G2;
  coherence;
  cluster total -> non empty for PGraphMapping of G1, G2;
  coherence;
  cluster onto -> non empty for PGraphMapping of G1, G2;
  coherence;
end;

registration
  let G be _Graph;
  cluster id G -> total non empty onto one-to-one Dcontinuous;
  coherence
  proof
    thus id G is total non empty onto one-to-one;
    let e9,v,w be object;
    assume that
      A1: v in dom (id G)_V & w in dom (id G)_V and
      A2: e9 DJoins (id G)_V.v,(id G)_V.w,G;
    take e9;
    e9 DJoins (id G)_V.v,w,G by A1, A2, FUNCT_1:18;
    hence e9 DJoins v,w,G by A1, FUNCT_1:18;
    A3: e9 in the_Edges_of G by A2, GLIB_000:def 14;
    hence e9 in dom((id G)_E);
    thus (id G)_E.e9 = e9 by A3, FUNCT_1:18;
  end;
end;

theorem Th30:
  for G1, G2 being _Graph
  for f being PartFunc of the_Vertices_of G1, the_Vertices_of G2
  for g being PartFunc of the_Edges_of G1, the_Edges_of G2
  st ((for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
    for e,v,w being object st e in dom g & v in dom f & w in dom f
    holds e DJoins v,w,G1 implies g.e DJoins f.v,f.w,G2)
  holds [f,g] is directed PGraphMapping of G1, G2
proof
  let G1, G2 be _Graph;
  let f be PartFunc of the_Vertices_of G1, the_Vertices_of G2;
  let g be PartFunc of the_Edges_of G1, the_Edges_of G2;
  assume that
    A1: for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f and
    A2: for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e DJoins v,w,G1 implies g.e DJoins f.v,f.w,G2;
  A3: now
    let e,v,w be object;
    assume A4: e in dom g & v in dom f & w in dom f;
    assume e Joins v,w,G1;
    then per cases by GLIB_000:16;
    suppose e DJoins v,w,G1;
      then g.e DJoins f.v,f.w,G2 by A2, A4;
      hence g.e Joins f.v,f.w,G2 by GLIB_000:16;
    end;
    suppose e DJoins w,v,G1;
      then g.e DJoins f.w,f.v,G2 by A2, A4;
      hence g.e Joins f.v,f.w,G2 by GLIB_000:16;
    end;
  end;
  reconsider F = [f,g] as PGraphMapping of G1, G2 by A1, A3, Th8;
  F is directed by A2;
  hence thesis;
end;

theorem Th31:
  for G1, G2 being _Graph
  for f being PartFunc of the_Vertices_of G1, the_Vertices_of G2
  for g being PartFunc of the_Edges_of G1, the_Edges_of G2
  st ((for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
    for e,v,w being object st e in dom g & v in dom f & w in dom f
    holds e Joins v,w,G1 iff g.e Joins f.v,f.w,G2)
  holds [f,g] is semi-continuous PGraphMapping of G1, G2
proof
  let G1, G2 be _Graph;
  let f be PartFunc of the_Vertices_of G1, the_Vertices_of G2;
  let g be PartFunc of the_Edges_of G1, the_Edges_of G2;
  assume that
    A1: for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f and
    A2: for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e Joins v,w,G1 iff g.e Joins f.v,f.w,G2;
  A3: for e,v,w being object st e in dom g & v in dom f & w in dom f
    holds e Joins v,w,G1 implies g.e Joins f.v,f.w,G2 by A2;
  reconsider F = [f,g] as PGraphMapping of G1, G2 by A1, A3, Th8;
  F is semi-continuous by A2;
  hence thesis;
end;

theorem
  for G1, G2 being _Graph
  for f being PartFunc of the_Vertices_of G1, the_Vertices_of G2
  for g being PartFunc of the_Edges_of G1, the_Edges_of G2
  st ((for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f) &
    for e,v,w being object st e in dom g & v in dom f & w in dom f
    holds e DJoins v,w,G1 iff g.e DJoins f.v,f.w,G2)
  holds [f,g] is semi-Dcontinuous PGraphMapping of G1, G2
proof
  let G1, G2 be _Graph;
  let f be PartFunc of the_Vertices_of G1, the_Vertices_of G2;
  let g be PartFunc of the_Edges_of G1, the_Edges_of G2;
  assume that
    A1: for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f and
    A2: for e,v,w being object st e in dom g & v in dom f & w in dom f
      holds e DJoins v,w,G1 iff g.e DJoins f.v,f.w,G2;
  A3: now
    let e,v,w be object;
    assume A4: e in dom g & v in dom f & w in dom f;
    assume e Joins v,w,G1;
    then per cases by GLIB_000:16;
    suppose e DJoins v,w,G1;
      then g.e DJoins f.v,f.w,G2 by A2, A4;
      hence g.e Joins f.v,f.w,G2 by GLIB_000:16;
    end;
    suppose e DJoins w,v,G1;
      then g.e DJoins f.w,f.v,G2 by A2, A4;
      hence g.e Joins f.v,f.w,G2 by GLIB_000:16;
    end;
  end;
  reconsider F = [f,g] as PGraphMapping of G1, G2 by A1, A3, Th8;
  F is semi-Dcontinuous by A2;
  hence thesis;
end;

theorem
  for G1, G2 being _Graph
  holds [{},{}] is empty one-to-one Dcontinuous PGraphMapping of G1, G2
proof
  let G1, G2 be _Graph;
  reconsider F = [{},{}] as PGraphMapping of G1, G2 by Lm3;
  A1: F is empty;
  thus thesis by A1;
end;

theorem Th34:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2 st F is total
  for v being Vertex of G1 holds F_V.v is Vertex of G2
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is total;
  let v be Vertex of G1;
  F_V.v in rng F_V by A1, FUNCT_1:3;
  hence thesis;
end;

theorem Th35:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is total holds
    (G2 is loopless implies G1 is loopless) &
    (G2 is edgeless implies G1 is edgeless)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is total;
  hereby
    assume A2: G2 is loopless;
    not ex e being object st e in the_Edges_of G1 &
      (the_Source_of G1).e = (the_Target_of G1).e
    proof
      given e being object such that
        A3: e in the_Edges_of G1 and
        A4: (the_Source_of G1).e = (the_Target_of G1).e;
      set v = (the_Source_of G1).e;
      A5: e Joins v,v,G1 by A3, A4, GLIB_000:def 13;
      then v in dom F_V by A1, GLIB_000:13;
      then F_E.e Joins F_V.v,F_V.v,G2 by A1, A3, A5, Th4;
      hence contradiction by A2, GLIB_000:18;
    end;
    hence G1 is loopless by GLIB_000:def 18;
  end;
  thus G2 is edgeless implies G1 is edgeless by A1;
end;

theorem Th36:
  for G1, G2 being _Graph, F being continuous PGraphMapping of G1, G2
  st rng F_V = the_Vertices_of G2 holds G1 is loopless implies G2 is loopless
proof
  let G1, G2 be _Graph, F be continuous PGraphMapping of G1, G2;
  assume A1: rng F_V = the_Vertices_of G2;
  assume A2: G1 is loopless;
  for v being object holds not ex e being object st e Joins v,v,G2
  proof
    let v be object;
    given e9 being object such that
      A3: e9 Joins v,v,G2;
    v in rng F_V by A1, A3, GLIB_000:13;
    then consider v0 being object such that
      A4: v0 in dom F_V & F_V.v0 = v by FUNCT_1:def 3;
    consider e being object such that
      A5: e Joins v0,v0,G1 & e in dom F_E & F_E.e = e9 by A3, A4, Def16;
    thus contradiction by A2, A5, GLIB_000:18;
  end;
  hence G2 is loopless by GLIB_000:18;
end;

theorem
  for G1, G2 being _Graph, F being semi-continuous PGraphMapping of G1, G2
  st F is onto holds G1 is loopless implies G2 is loopless
  by Th36;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st rng F_E = the_Edges_of G2 holds G1 is edgeless implies G2 is edgeless;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is onto holds G1 is edgeless implies G2 is edgeless;

:: next properties of these attributes for the PGM are studied
:: when G1 or G2 has a certain property

theorem
  for G1 being _Graph, G2 being non-multi _Graph
  for F1, F2 being PGraphMapping of G1, G2
  st F1_V = F2_V & dom F1_E = dom F2_E holds F1 = F2
proof
  let G1 be _Graph, G2 be non-multi _Graph;
  let F1, F2 be PGraphMapping of G1, G2;
  assume that
    A1: F1_V = F2_V and
    A2: dom F1_E = dom F2_E;
  for e being object st e in dom F1_E holds F1_E.e = F2_E.e
  proof
    let e be object;
    set v = (the_Source_of G1).e, w = (the_Target_of G1).e;
    assume A3: e in dom F1_E;
    then A4: v in dom F1_V & w in dom F1_V by Th5;
    A5: e Joins v,w,G1 by A3, GLIB_000:def 13;
    then A6: F1_E.e Joins F1_V.v,F1_V.w,G2 by A3, A4, Th4;
    A7: e in dom F2_E by A2, A3;
    then v in dom F2_V & w in dom F2_V by Th5;
    then F2_E.e Joins F1_V.v,F2_V.w,G2 by A1, A5, A7, Th4;
    hence F1_E.e = F2_E.e by A1, A6, GLIB_000:def 20;
  end;
  then F1_E = F2_E by A2, FUNCT_1:2;
  hence thesis by A1, XTUPLE_0:2;
end;

theorem
  for G1 being _Graph, G2 being non-Dmulti _Graph
  for F1, F2 being directed PGraphMapping of G1, G2
  st F1_V = F2_V & dom F1_E = dom F2_E holds F1 = F2
proof
  let G1 be _Graph, G2 be non-Dmulti _Graph;
  let F1, F2 be directed PGraphMapping of G1, G2;
  assume that
    A1: F1_V = F2_V and
    A2: dom F1_E = dom F2_E;
  for e being object st e in dom F1_E holds F1_E.e = F2_E.e
  proof
    let e be object;
    set v = (the_Source_of G1).e, w = (the_Target_of G1).e;
    assume A3: e in dom F1_E;
    then A4: v in dom F1_V & w in dom F1_V by Th5;
    A5: e DJoins v,w,G1 by A3, GLIB_000:def 14;
    then A6: F1_E.e DJoins F1_V.v,F1_V.w,G2 by A3, A4, Def14;
    A7: e in dom F2_E by A2, A3;
    then v in dom F2_V & w in dom F2_V by Th5;
    then F2_E.e DJoins F1_V.v,F2_V.w,G2 by A1, A5, A7, Def14;
    hence F1_E.e = F2_E.e by A1, A6, GLIB_000:def 21;
  end;
  then F1_E = F2_E by A2, FUNCT_1:2;
  hence thesis by A1, XTUPLE_0:2;
end;

theorem
  for G1 being non-multi _Graph, G2 being _Graph
  for F being semi-continuous PGraphMapping of G1, G2
  holds F_E is one-to-one
proof
  let G1 be non-multi _Graph, G2 be _Graph;
  let F be semi-continuous PGraphMapping of G1, G2;
  now
    let e1, e2 be object;
    assume A1: e1 in dom F_E & e2 in dom F_E & F_E.e1 = F_E.e2;
    then A2: (the_Source_of G1).e1 in dom F_V &
      (the_Target_of G1).e1 in dom F_V by Th5;
    A3: e1 Joins (the_Source_of G1).e1, (the_Target_of G1).e1, G1
      by A1, GLIB_000:def 13;
    then F_E.e2 Joins F_V.((the_Source_of G1).e1),
      F_V.((the_Target_of G1).e1), G2 by A1, A2, Th4;
    then e2 Joins (the_Source_of G1).e1, (the_Target_of G1).e1, G1
      by A1, A2, Def15;
    hence e1 = e2 by A3, GLIB_000:def 20;
  end;
  hence thesis by FUNCT_1:def 4;
end;

theorem
  for G1 being non-multi _Graph, G2 being _Graph
  for F being PGraphMapping of G1, G2
  st F_V is one-to-one holds F_E is one-to-one
proof
  let G1 be non-multi _Graph, G2 be _Graph;
  let F be PGraphMapping of G1, G2;
  assume A1: F_V is one-to-one;
  now
    let e1, e2 be object;
    set v1 = (the_Source_of G1).e1, w1 = (the_Target_of G1).e1,
      v2 = (the_Source_of G1).e2, w2 = (the_Target_of G1).e2;
    assume A2: e1 in dom F_E & e2 in dom F_E & F_E.e1 = F_E.e2;
    then A3: v1 in dom F_V & w1 in dom F_V & v2 in dom F_V & w2 in dom F_V
      by Th5;
    A4: e1 Joins v1,w1,G1 & e2 Joins v2,w2,G1 by A2, GLIB_000:def 13;
    then F_E.e1 Joins F_V.v1,F_V.w1,G2 & F_E.e2 Joins F_V.v2,F_V.w2,G2
      by A2, A3, Th4;
    then per cases by A2, GLIB_000:15;
    suppose F_V.v1 = F_V.v2 & F_V.w1 = F_V.w2;
      then v1 = v2 & w1 = w2 by A1, A3, FUNCT_1:def 4;
      hence e1 = e2 by A4, GLIB_000:def 20;
    end;
    suppose F_V.v1 = F_V.w2 & F_V.w1 = F_V.v2;
      then v1 = w2 & w1 = v2 by A1, A3, FUNCT_1:def 4;
      then e2 Joins v1,w1,G1 by A4, GLIB_000:14;
      hence e1 = e2 by A4, GLIB_000:def 20;
    end;
  end;
  hence thesis by FUNCT_1:def 4;
end;

theorem
  for G1 being non-Dmulti _Graph, G2 be _Graph
  for F being directed PGraphMapping of G1, G2
  st F_V is one-to-one holds F_E is one-to-one
proof
  let G1 be non-Dmulti _Graph, G2 be _Graph;
  let F be directed PGraphMapping of G1, G2;
  assume A1: F_V is one-to-one;
  now
    let e1, e2 be object;
    set v1 = (the_Source_of G1).e1, w1 = (the_Target_of G1).e1,
      v2 = (the_Source_of G1).e2, w2 = (the_Target_of G1).e2;
    assume A2: e1 in dom F_E & e2 in dom F_E & F_E.e1 = F_E.e2;
    then A3: v1 in dom F_V & w1 in dom F_V & v2 in dom F_V & w2 in dom F_V
      by Th5;
    A4: e1 DJoins v1,w1,G1 & e2 DJoins v2,w2,G1 by A2, GLIB_000:def 14;
    then F_E.e1 DJoins F_V.v1,F_V.w1,G2 & F_E.e2 DJoins F_V.v2,F_V.w2,G2
      by A2, A3, Def14;
    then F_V.v1 = F_V.v2 & F_V.w1 = F_V.w2 by A2, GLIB_009:6;
    then v1 = v2 & w1 = w2 by A1, A3, FUNCT_1:def 4;
    hence e1 = e2 by A4, GLIB_000:def 21;
  end;
  hence thesis by FUNCT_1:def 4;
end;

registration
  let G1 be _Graph, G2 be loopless _Graph;
  cluster directed semi-continuous -> semi-Dcontinuous
    for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    assume A1: F is directed semi-continuous;
    let e,v,w be object;
    assume A2: e in dom F_E & v in dom F_V & w in dom F_V;
    assume A3: F_E.e DJoins F_V.v,F_V.w,G2;
    then F_E.e Joins F_V.v,F_V.w,G2 by GLIB_000:16;
    then A4: e Joins v,w,G1 by A1, A2;
    assume not e DJoins v,w,G1;
    then e DJoins w,v,G1 by A4, GLIB_000:16;
    then F_E.e DJoins F_V.w,F_V.v,G2 by A1, A2;
    then (the_Source_of G2).(F_E.e) = F_V.w by GLIB_000:def 14;
    then F_V.v = F_V.w by A3, GLIB_000:def 14;
    then F_E.e Joins F_V.v,F_V.v,G2 by A3, GLIB_000:16;
    hence contradiction by GLIB_000:18;
  end;
  cluster directed continuous -> Dcontinuous for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    assume A5: F is directed continuous;
    let e9,v,w be object;
    assume A6: v in dom F_V & w in dom F_V & e9 DJoins F_V.v,F_V.w,G2;
    then A7: e9 Joins F_V.v,F_V.w,G2 by GLIB_000:16;
    then consider e being object such that
      A8: e Joins v,w,G1 & e in dom F_E & F_E.e = e9 by A5, A6;
    take e;
    not e DJoins w,v,G1
    proof
      assume e DJoins w,v,G1;
      then e9 DJoins F_V.w,F_V.v,G2 by A5, A6, A8;
      then F_V.v = F_V.w by A6, GLIB_009:6;
      hence contradiction by A7, GLIB_000:18;
    end;
    hence thesis by A8, GLIB_000:16;
  end;
end;

registration
  let G1 be _trivial _Graph, G2 be _Graph;
  cluster -> directed for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    consider u being Vertex of G1 such that
      A1: the_Vertices_of G1 = {u} by GLIB_000:22;
    for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
      holds e DJoins v,w,G1 implies F_E.e DJoins F_V.v, F_V.w, G2
    proof
      let e,v,w be object;
      assume A2: e in dom F_E & v in dom F_V & w in dom F_V;
      then A3: v = u & w = u by A1, TARSKI:def 1;
      assume e DJoins v,w,G1;
      then e Joins u,u,G1 by A3, GLIB_000:16;
      hence F_E.e DJoins F_V.v,F_V.w,G2 by A2, A3, Th4, GLIB_000:16;
    end;
    hence F is directed;
  end;
  cluster semi-continuous -> semi-Dcontinuous for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    assume A4: F is semi-continuous;
    consider u being Vertex of G1 such that
      A5: the_Vertices_of G1 = {u} by GLIB_000:22;
    for e,v,w being object st e in dom F_E & v in dom F_V & w in dom F_V
      holds e DJoins v,w,G1 iff F_E.e DJoins F_V.v, F_V.w, G2
    proof
      let e,v,w be object;
      assume A6: e in dom F_E & v in dom F_V & w in dom F_V;
      then A7: v = u & w = u by A5, TARSKI:def 1;
      hereby
        assume e DJoins v,w,G1;
        then e Joins u,u,G1 by A7, GLIB_000:16;
        hence F_E.e DJoins F_V.v,F_V.w,G2 by A6, A7, Th4, GLIB_000:16;
      end;
      assume F_E.e DJoins F_V.v,F_V.w,G2;
      then F_E.e Joins F_V.u,F_V.u,G2 by A7, GLIB_000:16;
      then e Joins u,u,G1 by A4, A6, A7;
      hence e DJoins v,w,G1 by A7, GLIB_000:16;
    end;
    hence F is semi-Dcontinuous;
  end;
  cluster continuous -> Dcontinuous for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    assume A8: F is continuous;
    consider u being Vertex of G1 such that
      A9: the_Vertices_of G1 = {u} by GLIB_000:22;
    now
      let e9,v,w be object;
      assume A10: v in dom F_V & w in dom F_V & e9 DJoins F_V.v,F_V.w,G2;
      then A11: v = u & w = u by A9, TARSKI:def 1;
      e9 Joins F_V.v,F_V.w,G2 by A10, GLIB_000:16;
      then consider e being object such that
        A12: e Joins v,w,G1 & e in dom F_E & F_E.e = e9 by A8, A10;
      take e;
      e DJoins v,w,G1 or e DJoins w,v,G1 by A12, GLIB_000:16;
      hence e DJoins v,w,G1 & e in dom F_E & F_E.e = e9 by A11, A12;
    end;
    hence F is Dcontinuous;
  end;
end;

registration
  let G1 be _trivial non-Dmulti _Graph, G2 be _Graph;
  cluster -> one-to-one for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    dom F_V is trivial & dom F_E is trivial by ZFMISC_1:130;
    then F_V is trivial & F_E is trivial;
    hence thesis;
  end;
end;

registration
  let G1 be _trivial edgeless _Graph, G2 be _Graph;
  cluster non empty -> total for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    consider v being Vertex of G1 such that
      A1: the_Vertices_of G1 = {v} by GLIB_000:22;
    assume F is non empty;
    then dom F_V is non empty;
    hence dom F_V = the_Vertices_of G1 by A1, ZFMISC_1:33;
    thus dom F_E = the_Edges_of G1;
  end;
end;

registration
  let G1 be _Graph, G2 be _trivial edgeless _Graph;
  cluster non empty -> onto for PGraphMapping of G1, G2;
  coherence
  proof
    let F be PGraphMapping of G1, G2;
    consider v being Vertex of G2 such that
      A1: the_Vertices_of G2 = {v} by GLIB_000:22;
    assume F is non empty;
    then rng F_V is non empty;
    hence rng F_V = the_Vertices_of G2 by A1, ZFMISC_1:33;
    thus rng F_E = the_Edges_of G2;
  end;
  cluster -> semi-continuous continuous for PGraphMapping of G1, G2;
  coherence by GLIB_000:def 13;
end;

:: define the concept of subgraph embedding and isomorphism

definition
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  attr F is weak_SG-embedding means :: SG is short for subgraph
  F is total one-to-one;
  attr F is strong_SG-embedding means
  F is total one-to-one continuous;
  attr F is isomorphism means
  F is total one-to-one onto;
  :: the next one is not really important (since directed isomorphism works
  :: just as well), but the term will be used with PVertexMappings later
  :: anyway, so it is introduced here shortly as well.
  attr F is Disomorphism means
  F is directed total one-to-one onto;
end;

registration
  let G1, G2 be _Graph;
  cluster weak_SG-embedding -> total non empty one-to-one semi-continuous
    for PGraphMapping of G1, G2;
  coherence;
  cluster total one-to-one -> weak_SG-embedding for PGraphMapping of G1, G2;
  coherence;
  cluster strong_SG-embedding -> total non empty one-to-one continuous
    weak_SG-embedding for PGraphMapping of G1, G2;
  coherence;
  cluster total one-to-one continuous -> strong_SG-embedding
    for PGraphMapping of G1, G2;
  coherence;
  cluster weak_SG-embedding continuous -> strong_SG-embedding
    for PGraphMapping of G1, G2;
  coherence;
  cluster isomorphism -> onto semi-continuous continuous total non empty
    one-to-one weak_SG-embedding strong_SG-embedding
    for PGraphMapping of G1, G2;
  coherence;
  cluster total one-to-one onto continuous -> isomorphism
    for PGraphMapping of G1, G2;
  coherence;
  cluster strong_SG-embedding onto -> isomorphism for PGraphMapping of G1, G2;
  coherence;
  cluster weak_SG-embedding continuous onto -> isomorphism
    for PGraphMapping of G1, G2;
  coherence;
  cluster Disomorphism -> directed isomorphism continuous total non empty
    semi-Dcontinuous semi-continuous one-to-one weak_SG-embedding
    strong_SG-embedding for PGraphMapping of G1, G2;
  coherence;
  cluster directed isomorphism -> Dcontinuous Disomorphism
    for PGraphMapping of G1, G2;
  coherence;
end;

registration
  let G be _Graph;
  cluster id G
    -> weak_SG-embedding strong_SG-embedding isomorphism Disomorphism;
  coherence;
end;

registration
  let G be _Graph;
  cluster weak_SG-embedding strong_SG-embedding isomorphism Disomorphism
    for PGraphMapping of G, G;
  existence
  proof
    take id G;
    thus thesis;
  end;
end;

theorem Th45:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is weak_SG-embedding
  holds G1.order() c= G2.order() & G1.size() c= G2.size()
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume F is weak_SG-embedding;
  then A1: dom F_V = the_Vertices_of G1 & dom F_E = the_Edges_of G1 &
    F_V is one-to-one & F_E is one-to-one by Def11;
  rng F_V c= the_Vertices_of G2 & rng F_E c= the_Edges_of G2;
  then A2: card the_Vertices_of G1 c= card the_Vertices_of G2 &
    card the_Edges_of G1 c= card the_Edges_of G2 by A1, CARD_1:10;
  then G1.order() c= card the_Vertices_of G2 by GLIB_000:def 24;
  hence G1.order() c= G2.order() by GLIB_000:def 24;
  G1.size() c= card the_Edges_of G2 by A2, GLIB_000:def 25;
  hence G1.size() c= G2.size() by GLIB_000:def 25;
end;

theorem Th46:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  for X,Y being Subset of the_Vertices_of G1 st F is weak_SG-embedding
  holds card G1.edgesBetween(X,Y) c= card G2.edgesBetween(F_V.:X,F_V.:Y)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  let X,Y be Subset of the_Vertices_of G1;
  assume A1: F is weak_SG-embedding;
  set f = F_E | G1.edgesBetween(X,Y);
  A2: dom f = dom F_E /\ G1.edgesBetween(X,Y) by RELAT_1:61
    .= the_Edges_of G1 /\ G1.edgesBetween(X,Y) by A1, Def11
    .= G1.edgesBetween(X,Y) by XBOOLE_1:28;
  for y being object holds y in rng f implies
    y in G2.edgesBetween(F_V.:X,F_V.:Y)
  proof
    let y be object;
    assume y in rng f;
    then consider x being object such that
      A3: x in dom f & f.x = y by FUNCT_1:def 3;
    set v = (the_Source_of G1).x, w = (the_Target_of G1).x;
    A4: x SJoins X,Y,G1 by A2, A3, GLIB_000:def 30;
    then per cases by GLIB_000:def 15;
    suppose A5: v in X & w in Y;
      then v in the_Vertices_of G1 & w in the_Vertices_of G1;
      then A6: v in dom F_V & w in dom F_V by A1, Def11;
      A7: x in the_Edges_of G1 by A4, GLIB_000:def 15;
      then A8: x in dom F_E by A1, Def11;
      x Joins v,w,G1 by A7, GLIB_000:def 13;
      then F_E.x Joins F_V.v,F_V.w,G2 by A6, A8, Th4;
      then A9: y Joins F_V.v,F_V.w,G2 by A3, FUNCT_1:47;
      F_V.v in F_V.:X & F_V.w in F_V.:Y by A5, A6, FUNCT_1:def 6;
      then y SJoins F_V.:X,F_V.:Y,G2 by A9, GLIB_000:17;
      hence thesis by GLIB_000:def 30;
    end;
    suppose A10: v in Y & w in X;
      then v in the_Vertices_of G1 & w in the_Vertices_of G1;
      then A11: v in dom F_V & w in dom F_V by A1, Def11;
      A12: x in the_Edges_of G1 by A4, GLIB_000:def 15;
      then A13: x in dom F_E by A1, Def11;
      x Joins v,w,G1 by A12, GLIB_000:def 13;
      then F_E.x Joins F_V.v,F_V.w,G2 by A11, A13, Th4;
      then A14: y Joins F_V.v,F_V.w,G2 by A3, FUNCT_1:47;
      F_V.v in F_V.:Y & F_V.w in F_V.:X by A10, A11, FUNCT_1:def 6;
      then y SJoins F_V.:X,F_V.:Y,G2 by A14, GLIB_000:17;
      hence thesis by GLIB_000:def 30;
    end;
  end;
  then A15: rng f c= G2.edgesBetween(F_V.:X,F_V.:Y) by TARSKI:def 3;
  f is one-to-one by A1, FUNCT_1:52;
  hence thesis by A2, A15, CARD_1:10;
end;

theorem Th47:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  for X being Subset of the_Vertices_of G1 st F is weak_SG-embedding
  holds card G1.edgesBetween(X) c= card G2.edgesBetween(F_V.:X)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  let X be Subset of the_Vertices_of G1;
  assume A1: F is weak_SG-embedding;
  set f = F_E | G1.edgesBetween(X);
  A2: dom f = dom F_E /\ G1.edgesBetween(X) by RELAT_1:61
    .= the_Edges_of G1 /\ G1.edgesBetween(X) by A1, Def11
    .= G1.edgesBetween(X) by XBOOLE_1:28;
  for y being object holds y in rng f implies
    y in G2.edgesBetween(F_V.:X)
  proof
    let y be object;
    assume y in rng f;
    then consider x being object such that
      A3: x in dom f & f.x = y by FUNCT_1:def 3;
    set v = (the_Source_of G1).x, w = (the_Target_of G1).x;
    A4: x in the_Edges_of G1 & v in X & w in X by A2, A3, GLIB_000:31;
    then v in the_Vertices_of G1 & w in the_Vertices_of G1;
    then A5: v in dom F_V & w in dom F_V by A1, Def11;
    A6: x in dom F_E by A1, A4, Def11;
    x Joins v,w,G1 by A4, GLIB_000:def 13;
    then F_E.x Joins F_V.v,F_V.w,G2 by A5, A6, Th4;
    then A7: y Joins F_V.v,F_V.w,G2 by A3, FUNCT_1:47;
    F_V.v in F_V.:X & F_V.w in F_V.:X by A4, A5, FUNCT_1:def 6;
    hence thesis by A7, GLIB_000:32;
  end;
  then A8: rng f c= G2.edgesBetween(F_V.:X) by TARSKI:def 3;
  f is one-to-one by A1, FUNCT_1:52;
  hence thesis by A2, A8, CARD_1:10;
end;

theorem Th48:
  for G1, G2 being _Graph, F being directed PGraphMapping of G1, G2
  for X,Y being Subset of the_Vertices_of G1 st F is weak_SG-embedding
  holds card G1.edgesDBetween(X,Y) c= card G2.edgesDBetween(F_V.:X,F_V.:Y)
proof
  let G1, G2 be _Graph, F be directed PGraphMapping of G1, G2;
  let X,Y be Subset of the_Vertices_of G1;
  assume A1: F is weak_SG-embedding;
  set f = F_E | G1.edgesDBetween(X,Y);
  A2: dom f = dom F_E /\ G1.edgesDBetween(X,Y) by RELAT_1:61
    .= the_Edges_of G1 /\ G1.edgesDBetween(X,Y) by A1, Def11
    .= G1.edgesDBetween(X,Y) by XBOOLE_1:28;
  for y being object holds y in rng f implies
    y in G2.edgesDBetween(F_V.:X,F_V.:Y)
  proof
    let y be object;
    assume y in rng f;
    then consider x being object such that
      A3: x in dom f & f.x = y by FUNCT_1:def 3;
    set v = (the_Source_of G1).x, w = (the_Target_of G1).x;
    A4: x DSJoins X,Y,G1 by A2, A3, GLIB_000:def 31;
    then A5: v in X & w in Y by GLIB_000:def 16;
    then v in the_Vertices_of G1 & w in the_Vertices_of G1;
    then A6: v in dom F_V & w in dom F_V by A1, Def11;
    A7: x in the_Edges_of G1 by A4, GLIB_000:def 16;
    then A8: x in dom F_E by A1, Def11;
    x DJoins v,w,G1 by A7, GLIB_000:def 14;
    then F_E.x DJoins F_V.v,F_V.w,G2 by A6, A8, Def14;
    then A9: y DJoins F_V.v,F_V.w,G2 by A3, FUNCT_1:47;
    F_V.v in F_V.:X & F_V.w in F_V.:Y by A5, A6, FUNCT_1:def 6;
    then y DSJoins F_V.:X,F_V.:Y,G2 by A9, GLIB_009:7;
    hence thesis by GLIB_000:def 31;
  end;
  then A10: rng f c= G2.edgesDBetween(F_V.:X,F_V.:Y) by TARSKI:def 3;
  f is one-to-one by A1, FUNCT_1:52;
  hence thesis by A2, A10, CARD_1:10;
end;

theorem Th49:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is weak_SG-embedding
  holds (G2 is _trivial implies G1 is _trivial) &
    (G2 is non-multi implies G1 is non-multi) &
    (G2 is simple implies G1 is simple) &
    (G2 is _finite implies G1 is _finite)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is weak_SG-embedding;
  hereby
    assume G2 is _trivial;
    then card the_Vertices_of G2 = 1 by GLIB_000:def 19;
    then A2: G2.order() = 1 by GLIB_000:def 24;
    G1.order() = 1
    proof
      assume G1.order() <> 1;
      then G1.order() in 1 by A1, A2, Th45, CARD_1:3;
      then G1.order() = 0 by CARD_1:49, TARSKI:def 1;
      then card the_Vertices_of G1 = 0 by GLIB_000:def 24;
      hence thesis; :: by contradiction
    end;
    then card the_Vertices_of G1 = 1 by GLIB_000:def 24;
    hence G1 is _trivial by GLIB_000:def 19;
  end;
  thus A3: G2 is non-multi implies G1 is non-multi
  proof
    assume A4: G2 is non-multi;
    for e1,e2,v1,v2 being object
      holds e1 Joins v1,v2,G1 & e2 Joins v1,v2,G1 implies e1 = e2
    proof
      let e1,e2,v1,v2 be object;
      assume A5: e1 Joins v1,v2,G1 & e2 Joins v1,v2,G1;
      then e1 in the_Edges_of G1 & e2 in the_Edges_of G1 by GLIB_000:def 13;
      then A6: e1 in dom F_E & e2 in dom F_E by A1, Def11;
      v1 in the_Vertices_of G1 & v2 in the_Vertices_of G1 by A5, GLIB_000:13;
      then v1 in dom F_V & v2 in dom F_V by A1, Def11;
      then F_E.e1 Joins F_V.v1,F_V.v2,G2 & F_E.e2 Joins F_V.v1,F_V.v2,G2
        by A5, A6, Th4;
      hence e1 = e2 by A1, A4, A6, GLIB_000:def 20, FUNCT_1:def 4;
    end;
    hence G1 is non-multi by GLIB_000:def 20;
  end;
  hereby
    assume G2 is simple;
    then G1 is loopless non-multi by A3, A1, Th35;
    hence G1 is simple;
  end;
  assume G2 is _finite;
  then card the_Vertices_of G2 is finite & card the_Edges_of G2 is finite;
  then A7: G2.order() is finite & G2.size() is finite
    by GLIB_000:def 24, GLIB_000:def 25;
  G1.order() c= G2.order() & G1.size() c= G2.size() by A1, Th45;
  then card the_Vertices_of G1 is finite & card the_Edges_of G1 is finite
    by A7, GLIB_000:def 24, GLIB_000:def 25;
  then the_Vertices_of G1 is finite & the_Edges_of G1 is finite;
  hence thesis by GLIB_000:def 17;
end;

theorem Th50:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is directed weak_SG-embedding holds
    (G2 is non-Dmulti implies G1 is non-Dmulti) &
    (G2 is Dsimple implies G1 is Dsimple)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is directed weak_SG-embedding;
  thus A2: G2 is non-Dmulti implies G1 is non-Dmulti
  proof
    assume A3: G2 is non-Dmulti;
    for e1,e2,v1,v2 being object
      holds e1 DJoins v1,v2,G1 & e2 DJoins v1,v2,G1 implies e1 = e2
    proof
      let e1,e2,v1,v2 be object;
      assume A4: e1 DJoins v1,v2,G1 & e2 DJoins v1,v2,G1;
      then e1 in the_Edges_of G1 & e2 in the_Edges_of G1 by GLIB_000:def 14;
      then A5: e1 in dom F_E & e2 in dom F_E by A1, Def11;
      e1 Joins v1,v2,G1 & e2 Joins v1,v2,G1 by A4, GLIB_000:16;
      then v1 in the_Vertices_of G1 & v2 in the_Vertices_of G1
        by GLIB_000:13;
      then A6: v1 in dom F_V & v2 in dom F_V by A1, Def11;
      then A7: F_E.e1 DJoins F_V.v1,F_V.v2,G2 by A1, A4, A5;
      F_E.e2 DJoins F_V.v1,F_V.v2,G2 by A1, A4, A5, A6;
      hence e1 = e2 by A1, A3, A5, A7, FUNCT_1:def 4, GLIB_000:def 21;
    end;
    hence G1 is non-Dmulti by GLIB_000:def 21;
  end;
  assume G2 is Dsimple;
  then G1 is loopless non-Dmulti by A2, A1, Th35;
  hence G1 is Dsimple;
end;

theorem Th51:
  for G1, G2 being _finite _Graph, F being PGraphMapping of G1, G2
  st F is strong_SG-embedding & G1.order() = G2.order() & G1.size() = G2.size()
  holds F is isomorphism
proof
  let G1, G2 be _finite _Graph, F be PGraphMapping of G1, G2;
  assume that
    A1: F is strong_SG-embedding and
    A2: G1.order() = G2.order() & G1.size() = G2.size();
  A3: card rng F_V = card dom F_V by A1, CARD_1:70
    .= card the_Vertices_of G1 by A1, Def11
    .= G2.order() by A2, GLIB_000:def 24
    .= card the_Vertices_of G2 by GLIB_000:def 24;
  card rng F_E = card dom F_E by A1, CARD_1:70
    .= card the_Edges_of G1 by A1, Def11
    .= G2.size() by A2, GLIB_000:def 25
    .= card the_Edges_of G2 by GLIB_000:def 25;
  then F is onto by A3, CARD_2:102;
  hence thesis by A1;
end;

theorem Th52:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is strong_SG-embedding holds G2 is complete implies G1 is complete
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is strong_SG-embedding;
  assume A2: G2 is complete;
  now
    let v,w be Vertex of G1;
    assume A3: v <> w;
    v in the_Vertices_of G1 & w in the_Vertices_of G1;
    then A4: v in dom F_V & w in dom F_V by A1, Def11;
    then F_V.v in rng F_V & F_V.w in rng F_V by FUNCT_1:3;
    then reconsider v2 = F_V.v, w2 = F_V.w as Vertex of G2;
    v2 <> w2 by A1, A3, A4, FUNCT_1:def 4;
    then consider e2 being object such that
      A5: e2 Joins v2,w2,G2 by A2, CHORD:def 6, CHORD:def 3;
    consider e1 being object such that
      A6: e1 Joins v,w,G1 & e1 in dom F_E & F_E.e1 = e2 by A1, A4, A5, Def16;
    thus v,w are_adjacent by A6, CHORD:def 3;
  end;
  hence thesis by CHORD:def 6;
end;

:: isomorphism as an attribute

definition
  let G1, G2 be _Graph;
  attr G2 is G1-isomorphic means
  :Def23:
  ex F being PGraphMapping of G1, G2 st F is isomorphism;
  attr G2 is G1-Disomorphic means
  :Def24:
  ex F being PGraphMapping of G1, G2 st F is Disomorphism;
end;

registration
  let G be _Graph;
  cluster G-Disomorphic -> G-isomorphic for _Graph;
  coherence;
end;

registration
  let G be _Graph;
  cluster G-Disomorphic G-isomorphic for _Graph;
  existence
  proof
    take G;
    id G is directed isomorphism;
    hence thesis;
  end;
end;

theorem Th53:
  for G being _Graph
  holds G is G-Disomorphic G-isomorphic
proof
  let G be _Graph;
  id G is directed strong_SG-embedding isomorphism;
  hence thesis;
end;

registration
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  cluster isomorphism strong_SG-embedding weak_SG-embedding
    total non empty one-to-one onto semi-continuous continuous
    for PGraphMapping of G1, G2;
  existence
  proof
    consider F being PGraphMapping of G1, G2 such that
      A1: F is isomorphism by Def23;
    take F;
    thus thesis by A1;
  end;
end;

:: this is the main reason for using an attribute instead of predicate
:: for isomorphism
definition
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  mode Isomorphism of G1, G2 is isomorphism PGraphMapping of G1, G2;
end;

registration
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  cluster isomorphism strong_SG-embedding weak_SG-embedding
    total non empty one-to-one onto directed semi-Dcontinuous Dcontinuous
    for PGraphMapping of G1, G2;
  existence
  proof
    consider F being PGraphMapping of G1, G2 such that
      A1: F is Disomorphism by Def24;
    take F;
    thus thesis by A1;
  end;
end;

definition
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  mode DIsomorphism of G1, G2 is Disomorphism PGraphMapping of G1, G2;
end;

:: define weight-/label-/ordering-preserving mappings

definition
  let G1, G2 be WGraph, F be PGraphMapping of G1, G2;
  attr F is weight-preserving means
  the_Weight_of G2 * F_E = (the_Weight_of G1) | dom F_E;
end;

definition
  let G1, G2 be EGraph, F be PGraphMapping of G1, G2;
  attr F is elabel-preserving means
  the_ELabel_of G2 * F_E = (the_ELabel_of G1) | dom F_E;
end;

definition
  let G1, G2 be VGraph, F be PGraphMapping of G1, G2;
  attr F is vlabel-preserving means
  the_VLabel_of G2 * F_V = (the_VLabel_of G1) | dom F_V;
end;

definition
  let G1, G2 be [Ordered] _Graph, F be PGraphMapping of G1, G2;
  attr F is ordering-preserving means
  the_Ordering_of G2 * F_V = (the_Ordering_of G1) | dom F_V;
end;

registration
  let G be WGraph;
  cluster id G -> weight-preserving;
  coherence by RELAT_1:65;
end;

registration
  let G be EGraph;
  cluster id G -> elabel-preserving;
  coherence by RELAT_1:65;
end;

registration
  let G be VGraph;
  cluster id G -> vlabel-preserving;
  coherence by RELAT_1:65;
end;

registration
  let G be [Ordered] _Graph;
  cluster id G -> ordering-preserving;
  coherence by RELAT_1:65;
end;

:: define domain and range of graph mappings

definition
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  func dom F -> inducedSubgraph of G1, dom F_V, dom F_E equals
  the plain inducedSubgraph of G1, dom F_V, dom F_E;
  coherence;
  func rng F -> inducedSubgraph of G2, rng F_V, rng F_E equals
  the plain inducedSubgraph of G2, rng F_V, rng F_E;
  coherence;
end;

registration
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  cluster dom F -> plain;
  coherence;
  cluster rng F -> plain;
  coherence;
end;

theorem Th54:
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2
  holds the_Vertices_of dom F = dom F_V & the_Edges_of dom F = dom F_E &
    the_Vertices_of rng F = rng F_V & the_Edges_of rng F = rng F_E
proof
  let G1, G2 be _Graph;
  let F be non empty PGraphMapping of G1, G2;
  dom F_E c= G1.edgesBetween(dom F_V) by Th7;
  hence the_Vertices_of dom F = dom F_V & the_Edges_of dom F = dom F_E
    by GLIB_000:def 37;
  rng F_E c= G2.edgesBetween(rng F_V) by Th7;
  hence the_Vertices_of rng F = rng F_V & the_Edges_of rng F = rng F_E
    by GLIB_000:def 37;
end;

theorem Th55:
  for G1, G2 be _Graph, F being non empty PGraphMapping of G1, G2
  holds F is total iff dom F == G1
proof
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  hereby
    A1: G1 is Subgraph of G1 by GLIB_000:40;
    assume A2: F is total;
    A3: the_Vertices_of dom F = the_Vertices_of G1 by A2, Th54;
    the_Edges_of dom F = the_Edges_of G1 by A2, Th54;
    hence dom F == G1 by A1, A3, GLIB_000:86;
  end;
  assume A4: dom F == G1;
  A5: dom F_V = the_Vertices_of dom F by Th54
    .= the_Vertices_of G1 by A4, GLIB_000:def 34;
  dom F_E = the_Edges_of dom F by Th54
    .= the_Edges_of G1 by A4, GLIB_000:def 34;
  hence thesis by A5;
end;

theorem
  for G1, G2 be _Graph, F being non empty PGraphMapping of G1, G2
  holds F is onto iff rng F == G2
proof
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  hereby
    A1: G2 is Subgraph of G2 by GLIB_000:40;
    assume A2: F is onto;
    A3: the_Vertices_of rng F = the_Vertices_of G2 by A2, Th54;
    the_Edges_of rng F = the_Edges_of G2 by A2, Th54;
    hence rng F == G2 by A1, A3, GLIB_000:86;
  end;
  assume A4: rng F == G2;
  A5: rng F_V = the_Vertices_of rng F by Th54
    .= the_Vertices_of G2 by A4, GLIB_000:def 34;
  rng F_E = the_Edges_of rng F by Th54
    .= the_Edges_of G2 by A4, GLIB_000:def 34;
  hence thesis by A5;
end;

:: define restrictions of graph mappings

definition
  let G1, G2 be _Graph, H be Subgraph of G1, F be PGraphMapping of G1, G2;
  func F | H -> PGraphMapping of H, G2 equals
  [ F_V | the_Vertices_of H, F_E | the_Edges_of H ];
  coherence
  proof
    reconsider f = F_V | the_Vertices_of H
      as PartFunc of the_Vertices_of H, the_Vertices_of G2 by PARTFUN1:10;
    reconsider g = F_E | the_Edges_of H
      as PartFunc of the_Edges_of H, the_Edges_of G2 by PARTFUN1:10;
    now
      hereby
        let e be object;
        assume e in dom g;
        then A1: e in dom F_E & e in the_Edges_of H by RELAT_1:57;
        then (the_Source_of G1).e in dom F_V &
          (the_Target_of G1).e in dom F_V by Th5;
        then A2: (the_Source_of H).e in dom F_V &
          (the_Target_of H).e in dom F_V by A1, GLIB_000:def 32;
        (the_Source_of H).e in the_Vertices_of H &
          (the_Target_of H).e in the_Vertices_of H by A1, FUNCT_2:5;
        hence (the_Source_of H).e in dom f & (the_Target_of H).e in dom f
          by A2, RELAT_1:57;
      end;
      let e,v,w be object;
      assume e in dom g & v in dom f & w in dom f;
      then A3: e in dom F_E & e in the_Edges_of H &
        v in dom F_V & v in the_Vertices_of H &
        w in dom F_V & w in the_Vertices_of H by RELAT_1:57;
      then A4: g.e = F_E.e & f.v = F_V.v & f.w = F_V.w by FUNCT_1:49;
      assume A5: e Joins v,w,H;
      v is set & w is set by TARSKI:1;
      then e Joins v,w,G1 by A5, GLIB_000:72;
      hence g.e Joins f.v,f.w,G2 by A3, A4, Th4;
    end;
    hence thesis by Th8;
  end;
end;

theorem Th57:
  for G1, G2 being _Graph, H being Subgraph of G1
  for F being PGraphMapping of G1, G2
  holds (F is empty implies F | H is empty) &
    (F is total implies F | H is total) &
    (F is one-to-one implies F | H is one-to-one) &
    (F is weak_SG-embedding implies F | H is weak_SG-embedding) &
    (F is semi-continuous implies F | H is semi-continuous) &
    (F is non onto implies F | H is non onto) &
    (F is directed implies F | H is directed) &
    (F is semi-Dcontinuous implies F | H is semi-Dcontinuous)
proof
  let G1, G2 be _Graph, H be Subgraph of G1, F be PGraphMapping of G1, G2;
  thus F is empty implies F|H is empty;
  thus A1: F is total implies F|H is total
  proof
    assume A2: F is total;
    A3: dom (F|H)_V = dom F_V /\ the_Vertices_of H by RELAT_1:61
      .= the_Vertices_of H by A2, XBOOLE_1:28;
    dom (F|H)_E = dom F_E /\ the_Edges_of H by RELAT_1:61
      .= the_Edges_of H by A2, XBOOLE_1:28;
    hence F|H is total by A3;
  end;
  thus F is one-to-one implies F|H is one-to-one by FUNCT_1:52;
  hence F is weak_SG-embedding implies F|H is weak_SG-embedding by A1;
  thus F is semi-continuous implies F|H is semi-continuous
  proof
    assume A4: F is semi-continuous;
    reconsider f = F_V | the_Vertices_of H
      as PartFunc of the_Vertices_of H, the_Vertices_of G2 by PARTFUN1:10;
    reconsider g = F_E | the_Edges_of H
      as PartFunc of the_Edges_of H, the_Edges_of G2 by PARTFUN1:10;
    now
      let e,v,w be object;
      assume e in dom g & v in dom f & w in dom f;
      then A5: e in dom F_E & e in the_Edges_of H &
        v in dom F_V & v in the_Vertices_of H &
        w in dom F_V & w in the_Vertices_of H by RELAT_1:57;
      then A6: g.e = F_E.e & f.v = F_V.v & f.w = F_V.w by FUNCT_1:49;
      assume g.e Joins f.v,f.w,G2;
      then e Joins v,w,G1 by A4, A5, A6;
      hence e Joins v,w,H by A5, GLIB_000:73;
    end;
    hence thesis;
  end;
  F|H is onto implies F is onto
  proof
    assume F|H is onto;
    then the_Vertices_of G2 c= rng F_V & the_Edges_of G2 c= rng F_E
      by RELAT_1:70;
    hence F is onto by XBOOLE_0:def 10;
  end;
  hence F is non onto implies F|H is non onto;
  thus F is directed implies F|H is directed
  proof
    assume A7: F is directed;
    let e,v,w be object;
    assume e in dom (F|H)_E & v in dom (F|H)_V & w in dom (F|H)_V;
    then A8: e in dom F_E & e in the_Edges_of H &
      v in dom F_V & v in the_Vertices_of H &
      w in dom F_V & w in the_Vertices_of H by RELAT_1:57;
    then A9: (F|H)_E.e = F_E.e & (F|H)_V.v = F_V.v & (F|H)_V.w = F_V.w
      by FUNCT_1:49;
    assume A10: e DJoins v,w,H;
    v is set & w is set by TARSKI:1;
    then e DJoins v,w,G1 by A10, GLIB_000:72;
    hence (F|H)_E.e DJoins (F|H)_V.v,(F|H)_V.w,G2 by A7, A8, A9;
  end;
  thus F is semi-Dcontinuous implies F|H is semi-Dcontinuous
  proof
    assume A11: F is semi-Dcontinuous;
    let e,v,w be object;
    assume e in dom (F|H)_E & v in dom (F|H)_V & w in dom (F|H)_V;
    then A12: e in dom F_E & e in the_Edges_of H &
      v in dom F_V & v in the_Vertices_of H &
      w in dom F_V & w in the_Vertices_of H by RELAT_1:57;
    then A13: (F|H)_E.e = F_E.e & (F|H)_V.v = F_V.v & (F|H)_V.w = F_V.w
      by FUNCT_1:49;
    assume (F|H)_E.e DJoins (F|H)_V.v,(F|H)_V.w,G2;
    then e DJoins v,w,G1 by A11, A12, A13;
    hence e DJoins v,w,H by A12, GLIB_000:73;
  end;
end;

theorem Th58:
  for G1, G2 being _Graph, V being set, H being inducedSubgraph of G1, V
  for F being PGraphMapping of G1, G2
  holds (F is continuous implies F | H is continuous) &
    (F is strong_SG-embedding implies F | H is strong_SG-embedding) &
    (F is Dcontinuous implies F | H is Dcontinuous)
proof
  let G1, G2 be _Graph, V be set, H be inducedSubgraph of G1, V;
  let F be PGraphMapping of G1, G2;
  reconsider f = F_V | the_Vertices_of H
    as PartFunc of the_Vertices_of H, the_Vertices_of G2 by PARTFUN1:10;
  reconsider g = F_E | the_Edges_of H
    as PartFunc of the_Edges_of H, the_Edges_of G2 by PARTFUN1:10;
  per cases;
  suppose V is non empty Subset of the_Vertices_of G1;
    then A1: the_Vertices_of H = V & the_Edges_of H = G1.edgesBetween(V)
      by GLIB_000:def 37;
    hereby
      assume A2: F is continuous;
      now
        let e9,v,w be object;
        assume A3: v in dom f & w in dom f & e9 Joins f.v,f.w,G2;
        then A4: v in dom F_V & v in the_Vertices_of H &
          w in dom F_V & w in the_Vertices_of H &
          v is set & w is set by RELAT_1:57;
        then f.v = F_V.v & f.w = F_V.w by FUNCT_1:49;
        then consider e being object such that
          A5: e Joins v,w,G1 & e in dom F_E & F_E.e = e9 by A2, A3, A4;
        take e;
        e in G1.edgesBetween(V) by A1, A4, A5, GLIB_000:32;
        then A6: e in the_Edges_of H by A1;
        hence e Joins v,w,H by A4, A5, GLIB_000:73;
        thus e in dom g & g.e = e9 by A5, A6, RELAT_1:57, FUNCT_1:49;
      end;
      hence F|H is continuous;
    end;
    hence F is strong_SG-embedding implies F|H is strong_SG-embedding by Th57;
    hereby
      assume A7: F is Dcontinuous;
      now
        let e9,v,w be object;
        assume A8: v in dom f & w in dom f & e9 DJoins f.v,f.w,G2;
        then A9: v in dom F_V & v in the_Vertices_of H &
          w in dom F_V & w in the_Vertices_of H &
          v is set & w is set by RELAT_1:57;
        then f.v = F_V.v & f.w = F_V.w by FUNCT_1:49;
        then consider e being object such that
          A10: e DJoins v,w,G1 & e in dom F_E & F_E.e = e9 by A7, A8, A9;
        take e;
        e Joins v,w,G1 by A10, GLIB_000:16;
        then e in G1.edgesBetween(V) by A1, A9, GLIB_000:32;
        then A11: e in the_Edges_of H by A1;
        hence e DJoins v,w,H by A9, A10, GLIB_000:73;
        thus e in dom g & g.e = e9 by A10, A11, RELAT_1:57, FUNCT_1:49;
      end;
      hence F|H is Dcontinuous;
    end;
  end;
  suppose not V is non empty Subset of the_Vertices_of G1;
    then A12: G1 == H by GLIB_000:def 37;
    then the_Vertices_of G1 = the_Vertices_of H &
      the_Edges_of G1 = the_Edges_of H by GLIB_000:def 34;
    then A13: f = F_V & g = F_E;
    hereby
      assume A14: F is continuous;
      now
        let e9,v,w be object;
        assume v in dom f & w in dom f & e9 Joins f.v,f.w,G2;
        then consider e being object such that
          A15: e Joins v,w,G1 & e in dom F_E & F_E.e = e9 by A13, A14;
        take e;
        thus e Joins v,w,H by A12, A15, GLIB_000:88;
        thus e in dom g & g.e = e9 by A13, A15;
      end;
      hence F|H is continuous;
    end;
    hence F is strong_SG-embedding implies F|H is strong_SG-embedding by Th57;
    hereby
      assume A16: F is Dcontinuous;
      now
        let e9,v,w be object;
        assume v in dom f & w in dom f & e9 DJoins f.v,f.w,G2;
        then consider e being object such that
          A17: e DJoins v,w,G1 & e in dom F_E & F_E.e = e9 by A13, A16;
        take e;
        thus e DJoins v,w,H by A12, A17, GLIB_000:88;
        thus e in dom g & g.e = e9 by A13, A17;
      end;
      hence F|H is Dcontinuous;
    end;
  end;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G1;
  let F be empty PGraphMapping of G1, G2;
  cluster F | H -> empty;
  coherence;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G1;
  let F be one-to-one PGraphMapping of G1, G2;
  cluster F | H -> one-to-one;
  coherence by Th57;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G1;
  let F be semi-continuous PGraphMapping of G1, G2;
  cluster F | H -> semi-continuous;
  coherence by Th57;
end;

registration
  let G1, G2 be _Graph, V be set, H be inducedSubgraph of G1, V;
  let F be continuous PGraphMapping of G1, G2;
  cluster F | H -> continuous;
  coherence by Th58;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G1;
  let F be directed PGraphMapping of G1, G2;
  cluster F | H -> directed;
  coherence by Th57;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G1;
  let F be semi-Dcontinuous PGraphMapping of G1, G2;
  cluster F | H -> semi-Dcontinuous;
  coherence by Th57;
end;

registration
  let G1, G2 be _Graph, V be set, H be inducedSubgraph of G1, V;
  let F be Dcontinuous PGraphMapping of G1, G2;
  cluster F | H -> Dcontinuous;
  coherence by Th58;
end;

registration
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  cluster F | dom F -> total;
  coherence
  proof
    thus dom (F | dom F)_V = dom (F_V | dom F_V) by Th54
      .= the_Vertices_of dom F by Th54;
    thus dom (F | dom F)_E = dom (F_E | dom F_E) by Th54
      .= the_Edges_of dom F by Th54;
  end;
end;

theorem Th59:
  for G1, G2 being _Graph, H being Subgraph of G1,
    F being PGraphMapping of G1, G2
  holds dom (F|H)_V = dom F_V /\ the_Vertices_of H &
    dom (F|H)_E = dom F_E /\ the_Edges_of H by RELAT_1:61;

theorem
  for G1, G2 being WGraph, H being WSubgraph of G1,
    F being PGraphMapping of G1, G2
  st F is weight-preserving holds F | H is weight-preserving
proof
  let G1, G2 be WGraph, H being WSubgraph of G1;
  let F be PGraphMapping of G1, G2;
  assume A1: F is weight-preserving;
  the_Weight_of G2 * (F|H)_E
     = (the_Weight_of G2 * F_E) | the_Edges_of H by RELAT_1:83
    .= (the_Weight_of G1) | (dom F_E /\ (the_Edges_of H /\ the_Edges_of H))
      by A1, RELAT_1:71
    .= (the_Weight_of G1) | (the_Edges_of H /\ (dom F_E /\ the_Edges_of H))
      by XBOOLE_1:16
    .= (the_Weight_of G1) | (the_Edges_of H /\ dom (F|H)_E) by Th59
    .= ((the_Weight_of G1) | the_Edges_of H) | dom (F|H)_E by RELAT_1:71
    .= (the_Weight_of H) | dom (F|H)_E by GLIB_003:def 10;
  hence thesis;
end;

theorem
  for G1, G2 being EGraph, H being ESubgraph of G1,
    F being PGraphMapping of G1, G2
  st F is elabel-preserving holds F | H is elabel-preserving
proof
  let G1, G2 be EGraph, H being ESubgraph of G1;
  let F be PGraphMapping of G1, G2;
  assume A1: F is elabel-preserving;
  the_ELabel_of G2 * (F|H)_E
     = (the_ELabel_of G2 * F_E) | the_Edges_of H by RELAT_1:83
    .= (the_ELabel_of G1) | (dom F_E /\ (the_Edges_of H /\ the_Edges_of H))
      by A1, RELAT_1:71
    .= (the_ELabel_of G1) | (the_Edges_of H /\ (dom F_E /\ the_Edges_of H))
      by XBOOLE_1:16
    .= (the_ELabel_of G1) | (the_Edges_of H /\ dom (F|H)_E) by Th59
    .= ((the_ELabel_of G1) | the_Edges_of H) | dom (F|H)_E by RELAT_1:71
    .= (the_ELabel_of H) | dom (F|H)_E by GLIB_003:def 11;
  hence thesis;
end;

theorem
  for G1, G2 being VGraph, H being VSubgraph of G1,
    F being PGraphMapping of G1, G2
  st F is vlabel-preserving holds F | H is vlabel-preserving
proof
  let G1, G2 be VGraph, H being VSubgraph of G1;
  let F be PGraphMapping of G1, G2;
  assume A1: F is vlabel-preserving;
  the_VLabel_of G2 * (F|H)_V
     = (the_VLabel_of G2 * F_V) | the_Vertices_of H by RELAT_1:83
    .= (the_VLabel_of G1) | (
      dom F_V /\ (the_Vertices_of H /\ the_Vertices_of H))  by A1, RELAT_1:71
    .= (the_VLabel_of G1) | (
      the_Vertices_of H /\ (dom F_V /\ the_Vertices_of H)) by XBOOLE_1:16
    .= (the_VLabel_of G1) | (the_Vertices_of H /\ dom (F|H)_V) by Th59
    .= ((the_VLabel_of G1) | the_Vertices_of H) | dom (F|H)_V by RELAT_1:71
    .= (the_VLabel_of H) | dom (F|H)_V by GLIB_003:def 12;
  hence thesis;
end;

definition
  let G1, G2 be _Graph, H be Subgraph of G2, F be PGraphMapping of G1, G2;
  func H |` F -> PGraphMapping of G1, H equals
  [ (the_Vertices_of H) |` F_V, (the_Edges_of H) |` F_E ];
  coherence
  proof
    reconsider f = (the_Vertices_of H) |` F_V
      as PartFunc of the_Vertices_of G1, the_Vertices_of H by PARTFUN1:12;
    reconsider g = (the_Edges_of H) |` F_E
      as PartFunc of the_Edges_of G1, the_Edges_of H by PARTFUN1:12;
    now
      hereby
        let e be object;
        assume e in dom g;
        then A1: e in dom F_E & F_E.e in the_Edges_of H by FUNCT_1:54;
        A2: F_E.e Joins (the_Source_of H).(F_E.e),(the_Target_of H).(F_E.e),H
          by A1, GLIB_000:def 13;
        then A3: F_E.e Joins (the_Source_of H).(F_E.e),
          (the_Target_of H).(F_E.e),G2 by GLIB_000:72;
        A4: (the_Source_of H).(F_E.e) in the_Vertices_of H &
          (the_Target_of H).(F_E.e) in the_Vertices_of H by A2, GLIB_000:13;
        A5: e Joins (the_Source_of G1).e, (the_Target_of G1).e, G1
          by A1, GLIB_000:def 13;
        A6: (the_Source_of G1).e in dom F_V & (the_Target_of G1).e in dom F_V
          by A1, Th5;
        then A7: F_E.e Joins F_V.((the_Source_of G1).e),
          F_V.((the_Target_of G1).e),G2 by A1, A5, Th4;
        F_V.((the_Source_of G1).e) in the_Vertices_of H &
          F_V.((the_Target_of G1).e) in the_Vertices_of H
        proof
          per cases by A3, A7, GLIB_000:15;
          suppose F_V.((the_Source_of G1).e) = (the_Source_of H).(F_E.e) &
              F_V.((the_Target_of G1).e) = (the_Target_of H).(F_E.e);
            hence thesis by A4;
          end;
          suppose F_V.((the_Source_of G1).e) = (the_Target_of H).(F_E.e) &
              F_V.((the_Target_of G1).e) = (the_Source_of H).(F_E.e);
            hence thesis by A4;
          end;
        end;
        hence (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f
          by A6, FUNCT_1:54;
      end;
      let e,v,w be object;
      assume A8: e in dom g & v in dom f & w in dom f;
      then A9: e in dom F_E & F_E.e in the_Edges_of H &
        v in dom F_V & F_V.v in the_Vertices_of H &
        w in dom F_V & F_V.w in the_Vertices_of H by FUNCT_1:54;
      then e Joins v,w,G1 implies F_E.e Joins F_V.v,F_V.w,G2 by Th4;
      then A10: e Joins v,w,G1 implies F_E.e Joins F_V.v,F_V.w,H
        by A9, GLIB_000:73;
      g.e = F_E.e & f.v = F_V.v & f.w = F_V.w by A8, FUNCT_1:53;
      hence e Joins v,w,G1 implies g.e Joins f.v,f.w,H by A10;
    end;
    hence thesis by Th8;
  end;
end;

theorem Th63:
  for G1, G2 being _Graph, H being Subgraph of G2
  for F being PGraphMapping of G1, G2
  holds (F is empty implies H |` F is empty) &
    (F is one-to-one implies H |` F is one-to-one) &
    (F is onto implies H |` F is onto) &
    (F is non total implies H |` F is non total) &
    (F is directed implies H |` F is directed) &
    (F is semi-continuous implies H |` F is semi-continuous) &
    (F is continuous implies H |` F is continuous) &
    (F is semi-Dcontinuous implies H |` F is semi-Dcontinuous) &
    (F is Dcontinuous implies H |` F is Dcontinuous)
proof
  let G1, G2 be _Graph, H be Subgraph of G2;
  let F be PGraphMapping of G1, G2;
  reconsider f = (the_Vertices_of H) |` F_V
    as PartFunc of the_Vertices_of G1, the_Vertices_of H by PARTFUN1:12;
  reconsider g = (the_Edges_of H) |` F_E
    as PartFunc of the_Edges_of G1, the_Edges_of H by PARTFUN1:12;
  hereby
    assume F is empty;
    then F_V is empty;
    hence H |` F is empty by RELAT_1:86, XBOOLE_1:3;
  end;
  thus F is one-to-one implies H |` F is one-to-one by FUNCT_1:58;
  thus F is onto implies H |` F is onto
  proof
    assume A1: F is onto;
    thus rng (H|`F)_V =rng F_V /\ the_Vertices_of H by RELAT_1:88
      .= the_Vertices_of H by A1, XBOOLE_1:28;
    thus rng (H|`F)_E = rng F_E /\ the_Edges_of H by RELAT_1:88
      .= the_Edges_of H by A1, XBOOLE_1:28;
  end;
  now
    assume A2: H |` F is total;
    dom (H|`F)_V c= dom F_V by RELAT_1:186;
    hence dom F_V = the_Vertices_of G1 by A2, XBOOLE_0:def 10;
    dom (H|`F)_E c= dom F_E by RELAT_1:186;
    hence dom F_E = the_Edges_of G1 by A2, XBOOLE_0:def 10;
  end;
  hence F is non total implies H |` F is non total;
  thus F is directed implies H |` F is directed
  proof
    assume A3: F is directed;
    let e,v,w be object;
    assume A4: e in dom (H|`F)_E & v in dom (H|`F)_V & w in dom (H|`F)_V;
    then A5: e in dom F_E & F_E.e in the_Edges_of H &
      v in dom F_V & F_V.v in the_Vertices_of H &
      w in dom F_V & F_V.w in the_Vertices_of H by FUNCT_1:54;
    then e DJoins v,w,G1 implies F_E.e DJoins F_V.v,F_V.w,G2 by A3;
    then A6: e DJoins v,w,G1 implies F_E.e DJoins F_V.v,F_V.w,H
      by A5, GLIB_000:73;
    (H|`F)_E.e = F_E.e & (H|`F)_V.v = F_V.v & (H|`F)_V.w = F_V.w
      by A4, FUNCT_1:53;
    hence e DJoins v,w,G1 implies
      (H|`F)_E.e DJoins (H|`F)_V.v,(H|`F)_V.w,H by A6;
  end;
  thus F is semi-continuous implies H |` F is semi-continuous
  proof
    assume A7: F is semi-continuous;
    reconsider f = (the_Vertices_of H) |` F_V
      as PartFunc of the_Vertices_of G1, the_Vertices_of H by PARTFUN1:12;
    reconsider g = (the_Edges_of H) |` F_E
      as PartFunc of the_Edges_of G1, the_Edges_of H by PARTFUN1:12;
    let e,v,w be object;
    assume A8: e in dom (H |` F)_E & v in dom (H |` F)_V & w in dom (H |` F)_V;
    then e in dom F_E & F_E.e in the_Edges_of H &
      v in dom F_V & F_V.v in the_Vertices_of H &
      w in dom F_V & F_V.w in the_Vertices_of H by FUNCT_1:54;
    then F_E.e Joins F_V.v,F_V.w,G2 implies e Joins v,w,G1 by A7;
    then A9: F_E.e Joins F_V.v,F_V.w,H implies e Joins v,w,G1 by GLIB_000:72;
    g.e = F_E.e & f.v = F_V.v & f.w = F_V.w by A8, FUNCT_1:53;
    hence thesis by A9;
  end;
  thus F is continuous implies H |` F is continuous
  proof
    assume A10: F is continuous;
    now
      let e9,v,w be object;
      set f = (the_Vertices_of H) |` (F_V);
      assume A11: v in dom (H |` F)_V & w in dom (H |` F)_V &
        e9 Joins (H |` F)_V.v,(H |` F)_V.w,H;
      then A12: v in dom f & w in dom f & e9 Joins f.v,f.w,H;
      then A13: f.v = F_V.v & f.w = F_V.w by FUNCT_1:55;
      A14: v in dom F_V & F_V.v in the_Vertices_of H &
        w in dom F_V & F_V.w in the_Vertices_of H &
        v is set & w is set by A11, FUNCT_1:54;
      e9 Joins F_V.v,F_V.w,G2 by A12, A13, GLIB_000:72;
      then consider e being object such that
        A15: e Joins v,w,G1 & e in dom F_E & F_E.e = e9 by A10, A14;
      take e;
      thus e Joins v,w,G1 by A15;
      e9 in the_Edges_of H by A11, GLIB_000:def 13;
      then e in dom ((the_Edges_of H) |` (F_E)) by A15, FUNCT_1:54;
      hence e in dom (H |` F)_E & (H |` F)_E.e = e9 by A15, FUNCT_1:55;
    end;
    hence thesis;
  end;
  thus F is semi-Dcontinuous implies H |` F is semi-Dcontinuous
  proof
    assume A16: F is semi-Dcontinuous;
    let e,v,w be object;
    assume A17: e in dom (H|`F)_E & v in dom (H|`F)_V & w in dom (H|`F)_V;
    then e in dom F_E & F_E.e in the_Edges_of H &
      v in dom F_V & F_V.v in the_Vertices_of H &
      w in dom F_V & F_V.w in the_Vertices_of H by FUNCT_1:54;
    then A18: F_E.e DJoins F_V.v,F_V.w,H implies e DJoins v,w,G1
      by A16, GLIB_000:72;
    (H|`F)_E.e = F_E.e & (H|`F)_V.v = F_V.v & (H|`F)_V.w = F_V.w
      by A17, FUNCT_1:53;
    hence (H|`F)_E.e DJoins (H|`F)_V.v,(H|`F)_V.w,H implies e DJoins v,w,G1
      by A18;
  end;
  thus F is Dcontinuous implies H |` F is Dcontinuous
  proof
    assume A19: F is Dcontinuous;
    now
      let e9,v,w be object;
      set f = (the_Vertices_of H) |` (F_V);
      assume A20: v in dom (H |` F)_V & w in dom (H |` F)_V &
        e9 DJoins (H |` F)_V.v,(H |` F)_V.w,H;
      then A21: v in dom f & w in dom f & e9 DJoins f.v,f.w,H;
      then A22: f.v = F_V.v & f.w = F_V.w by FUNCT_1:55;
      A23: v in dom F_V & F_V.v in the_Vertices_of H &
        w in dom F_V & F_V.w in the_Vertices_of H &
        v is set & w is set by A20, FUNCT_1:54;
      e9 DJoins F_V.v,F_V.w,G2 by A21, A22, GLIB_000:72;
      then consider e being object such that
        A24: e DJoins v,w,G1 & e in dom F_E & F_E.e = e9 by A19, A23;
      take e;
      thus e DJoins v,w,G1 by A24;
      e9 in the_Edges_of H by A20, GLIB_000:def 14;
      then e in dom ((the_Edges_of H) |` (F_E)) by A24, FUNCT_1:54;
      hence e in dom (H |` F)_E & (H |` F)_E.e = e9 by A24, FUNCT_1:55;
    end;
    hence thesis;
  end;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G2;
  let F be empty PGraphMapping of G1, G2;
  cluster H |` F -> empty;
  coherence by Th63;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G2;
  let F be one-to-one PGraphMapping of G1, G2;
  cluster H |` F -> one-to-one;
  coherence by Th63;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G2;
  let F be semi-continuous PGraphMapping of G1, G2;
  cluster H |` F -> semi-continuous;
  coherence by Th63;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G2;
  let F be continuous PGraphMapping of G1, G2;
  cluster H |` F -> continuous;
  coherence by Th63;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G2;
  let F be directed PGraphMapping of G1, G2;
  cluster H |` F -> directed;
  coherence by Th63;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G2;
  let F be semi-Dcontinuous PGraphMapping of G1, G2;
  cluster H |` F -> semi-Dcontinuous;
  coherence by Th63;
end;

registration
  let G1, G2 be _Graph, H be Subgraph of G2;
  let F be Dcontinuous PGraphMapping of G1, G2;
  cluster H |` F -> Dcontinuous;
  coherence by Th63;
end;

registration
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  cluster rng F |` F -> onto;
  coherence
  proof
    thus rng (rng F |` F)_V = rng (rng F_V |` F_V) by Th54
      .= the_Vertices_of rng F by Th54;
    thus rng (rng F |` F)_E = rng (rng F_E |` F_E) by Th54
      .= the_Edges_of rng F by Th54;
  end;
end;

theorem
  for G1, G2 being _Graph, H being Subgraph of G2,
    F being PGraphMapping of G1, G2
  holds rng (H|`F)_V = rng F_V /\ the_Vertices_of H &
    rng (H|`F)_E = rng F_E /\ the_Edges_of H by RELAT_1:88;

theorem
  for G1, G2 being WGraph, H being WSubgraph of G2,
    F being PGraphMapping of G1, G2
  st F is weight-preserving holds H |` F is weight-preserving
proof
  let G1, G2 be WGraph, H being WSubgraph of G2;
  let F be PGraphMapping of G1, G2;
  assume A1: F is weight-preserving;
  (the_Edges_of H)|`F_E c= F_E by RELAT_1:86;
  then A2: dom ((the_Edges_of H)|`F_E) /\  dom F_E = dom (H|`F)_E
    by XBOOLE_1:28, RELAT_1:11;
  the_Weight_of H * (H|`F)_E
     = ((the_Weight_of G2) | the_Edges_of H) * (H|`F)_E by GLIB_003:def 10
    .= the_Weight_of G2 * ((the_Edges_of H)|`((the_Edges_of H)|`F_E))
      by GROUP_9:121
    .= the_Weight_of G2 * (F_E | dom((the_Edges_of H)|`F_E)) by GLIB_009:4
    .= ((the_Weight_of G1) | dom F_E) | dom (H|`F)_E by A1, RELAT_1:83
    .= (the_Weight_of G1) | dom (H|`F)_E by A2, RELAT_1:71;
  hence thesis;
end;

theorem
  for G1, G2 being EGraph, H being ESubgraph of G2,
    F being PGraphMapping of G1, G2
  st F is elabel-preserving holds H |` F is elabel-preserving
proof
  let G1, G2 be EGraph, H being ESubgraph of G2;
  let F be PGraphMapping of G1, G2;
  assume A1: F is elabel-preserving;
  (the_Edges_of H)|`F_E c= F_E by RELAT_1:86;
  then A2: dom ((the_Edges_of H)|`F_E) /\  dom F_E = dom (H|`F)_E
    by XBOOLE_1:28, RELAT_1:11;
  the_ELabel_of H * (H|`F)_E
     = ((the_ELabel_of G2) | the_Edges_of H) * (H|`F)_E by GLIB_003:def 11
    .= the_ELabel_of G2 * ((the_Edges_of H)|`((the_Edges_of H)|`F_E))
      by GROUP_9:121
    .= the_ELabel_of G2 * (F_E | dom((the_Edges_of H)|`F_E)) by GLIB_009:4
    .= ((the_ELabel_of G1) | dom F_E) | dom (H|`F)_E by A1, RELAT_1:83
    .= (the_ELabel_of G1) | dom (H|`F)_E by A2, RELAT_1:71;
  hence thesis;
end;

theorem
  for G1, G2 being VGraph, H being VSubgraph of G2,
    F being PGraphMapping of G1, G2
  st F is vlabel-preserving holds H |` F is vlabel-preserving
proof
  let G1, G2 be VGraph, H being VSubgraph of G2;
  let F be PGraphMapping of G1, G2;
  assume A1: F is vlabel-preserving;
  (the_Vertices_of H)|`F_V c= F_V by RELAT_1:86;
  then A2: dom ((the_Vertices_of H)|`F_V) /\  dom F_V = dom (H|`F)_V
    by XBOOLE_1:28, RELAT_1:11;
  the_VLabel_of H * (H|`F)_V
     = ((the_VLabel_of G2) | the_Vertices_of H) * (H|`F)_V by GLIB_003:def 12
    .= the_VLabel_of G2 * ((the_Vertices_of H)|`((the_Vertices_of H)|`F_V))
      by GROUP_9:121
    .= the_VLabel_of G2 * (F_V | dom((the_Vertices_of H)|`F_V)) by GLIB_009:4
    .= ((the_VLabel_of G1) | dom F_V) | dom (H|`F)_V by A1, RELAT_1:83
    .= (the_VLabel_of G1) | dom (H|`F)_V by A2, RELAT_1:71;
  hence thesis;
end;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2,
    H1 being Subgraph of G1, H2 being Subgraph of G2
  holds (H2|`F)|H1 = H2|`(F|H1)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  let H1 be Subgraph of G1, H2 be Subgraph of G2;
  thus (H2|`F)|H1
     = [ (the_Vertices_of H2) |` (F_V | the_Vertices_of H1),
      ((the_Edges_of H2) |` F_E) | the_Edges_of H1 ] by RELAT_1:109
    .= H2|`(F|H1) by RELAT_1:109;
end;

:: define inverse of graph mappings

definition
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  func F" -> PGraphMapping of G2, G1 equals
  [ F_V" , F_E" ];
  coherence
  proof
    reconsider f = F_V" as PartFunc of the_Vertices_of G2, the_Vertices_of G1;
    reconsider g = F_E" as PartFunc of the_Edges_of G2, the_Edges_of G1;
    :: show definition properties
    now
      hereby
        let e be object;
        assume e in dom g;
        then e in rng F_E by FUNCT_1:33;
        then (the_Source_of G2).e in rng F_V & (the_Target_of G2).e in rng F_V
          by Th6;
        hence (the_Source_of G2).e in dom f & (the_Target_of G2).e in dom f
          by FUNCT_1:33;
      end;
      let e,v,w be object;
      assume e in dom g & v in dom f & w in dom f;
      then A1: e in rng F_E & v in rng F_V & w in rng F_V by FUNCT_1:33;
      then consider e0 being object such that
        A2: e0 in dom F_E & F_E.e0 = e by FUNCT_1:def 3;
      consider v0 being object such that
        A3: v0 in dom F_V & F_V.v0 = v by A1, FUNCT_1:def 3;
      consider w0 being object such that
        A4: w0 in dom F_V & F_V.w0 = w by A1, FUNCT_1:def 3;
      A5: g.e = e0 & f.v = v0 & f.w = w0 by A2, A3, A4, FUNCT_1:34;
      A6: F is semi-continuous;
      assume e Joins v,w,G2;
      then F_E.e0 Joins F_V.v0,F_V.w0,G2 by A2, A3, A4;
      hence g.e Joins f.v,f.w,G1 by A2, A3, A4, A5, A6;
    end;
    hence thesis by Th8;
  end;
end;

registration
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  cluster F" -> one-to-one semi-continuous;
  coherence
  proof
    thus F" is one-to-one;
    hence thesis;
  end;
end;

registration
  let G1, G2 be _Graph, F be empty one-to-one PGraphMapping of G1, G2;
  cluster F" -> empty;
  coherence
  proof
    reconsider f = F_V as one-to-one Function;
    dom (F"_V) = rng f by FUNCT_1:33
      .= {};
    hence thesis;
  end;
end;

registration
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  cluster F" -> non empty;
  coherence
  proof
    reconsider f = F_V as one-to-one Function;
    dom (F"_V) = rng f by FUNCT_1:33;
    hence thesis;
  end;
end;

registration
  let G1, G2 be _Graph;
  let F be one-to-one semi-Dcontinuous PGraphMapping of G1, G2;
  cluster F" -> semi-Dcontinuous;
  coherence
  proof
    reconsider f = F_V, g = F_E as one-to-one Function;
    let e,v,w be object;
    assume e in dom (F"_E) & v in dom (F"_V) & w in dom (F"_V);
    then A1: e in rng g & v in rng f & w in rng f by FUNCT_1:33;
    then consider e0 being object such that
      A2: e0 in dom g & g.e0 = e by FUNCT_1:def 3;
    consider v0 being object such that
      A3: v0 in dom f & f.v0 = v by A1, FUNCT_1:def 3;
    consider w0 being object such that
      A4: w0 in dom f & f.w0 = w by A1, FUNCT_1:def 3;
    assume F"_E.e DJoins F"_V.v,F"_V.w,G1;
    then g".(g.e0) DJoins f".(f.v0),w0,G1 by A2, A3, A4, FUNCT_1:34;
    then g".(g.e0) DJoins v0,w0,G1 by A3, FUNCT_1:34;
    then e0 DJoins v0,w0,G1 by A2, FUNCT_1:34;
    hence e DJoins v,w,G2 by A2, A3, A4, Th16;
  end;
end;

theorem :: this would otherwise need Proof outside of this article
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  holds F"_V = F_V" & F"_E = F_E";

theorem Th70:
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  holds (F")" = F
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  thus (F")" = [F_V, (F_E")"] by FUNCT_1:43
    .= [F_V, F_E] by FUNCT_1:43
    .= F;
end;

theorem Th71:
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  holds F is total iff F" is onto by FUNCT_1:33;

theorem Th72:
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  holds F is onto iff F" is total by FUNCT_1:33;

theorem
  for G1, G2 being _Graph, F be one-to-one PGraphMapping of G1, G2
  st F is total continuous holds F" is continuous
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  assume F is total continuous;
  then F" is onto by FUNCT_1:33;
  hence F" is continuous;
end;

theorem Th74:
  for G1, G2 being _Graph, F be one-to-one PGraphMapping of G1, G2
  st F is total Dcontinuous holds F" is Dcontinuous
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  assume A1: F is total Dcontinuous;
  then F" is onto by FUNCT_1:33;
  hence F" is Dcontinuous by A1;
end;

theorem Th75:
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  holds F is isomorphism iff F" is isomorphism by Th71, Th72;

theorem
  for G1, G2 being WGraph, F being one-to-one PGraphMapping of G1, G2
  holds F is weight-preserving iff F" is weight-preserving
proof
  let G1, G2 be WGraph, F be one-to-one PGraphMapping of G1, G2;
  thus F is weight-preserving implies F" is weight-preserving by Th2;
  F" is weight-preserving implies (F")" is weight-preserving by Th2;
  hence thesis by Th70;
end;

theorem
  for G1, G2 being EGraph, F being one-to-one PGraphMapping of G1, G2
  holds F is elabel-preserving iff F" is elabel-preserving
proof
  let G1, G2 be EGraph, F be one-to-one PGraphMapping of G1, G2;
  thus F is elabel-preserving implies F" is elabel-preserving by Th2;
  F" is elabel-preserving implies (F")" is elabel-preserving by Th2;
  hence thesis by Th70;
end;

theorem
  for G1, G2 being VGraph, F being one-to-one PGraphMapping of G1, G2
  holds F is vlabel-preserving iff F" is vlabel-preserving
proof
  let G1, G2 be VGraph, F be one-to-one PGraphMapping of G1, G2;
  thus F is vlabel-preserving implies F" is vlabel-preserving by Th2;
  F" is vlabel-preserving implies (F")" is vlabel-preserving by Th2;
  hence thesis by Th70;
end;

theorem Th79:
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  st F is onto for v being Vertex of G2 holds F"_V.v is Vertex of G1
  by Th34, Th72;

theorem
  for G being _Graph holds (id G)" = id G
proof
  let G be _Graph;
  thus (id G)"
     = [id the_Vertices_of G, (id the_Edges_of G)"] by FUNCT_1:45
    .= id G by FUNCT_1:45;
end;

theorem Th81:
  for G1, G2 be _Graph, F being non empty one-to-one PGraphMapping of G1, G2
  holds dom F = rng(F") & rng F = dom(F")
proof
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  A1: the_Vertices_of dom F = dom F_V by Th54
    .= rng (F_V") by FUNCT_1:33
    .= the_Vertices_of rng(F") by Th54;
  the_Edges_of dom F = dom F_E by Th54
    .= rng (F_E") by FUNCT_1:33
    .= the_Edges_of rng(F") by Th54;
  hence dom F = rng(F") by A1, GLIB_000:86, GLIB_009:44;
  A2: the_Vertices_of rng F = rng F_V by Th54
    .= dom (F_V") by FUNCT_1:33
    .= the_Vertices_of dom(F") by Th54;
  the_Edges_of rng F = rng F_E by Th54
    .= dom (F_E") by FUNCT_1:33
    .= the_Edges_of dom(F") by Th54;
  hence rng F = dom(F") by A2, GLIB_000:86, GLIB_009:44;
end;

theorem Th82:
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2,
    H being Subgraph of G1 holds (F|H)" = H |` (F")
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  let H be Subgraph of G1;
  reconsider f = F_V, g = F_E as one-to-one Function;
  thus (F|H)"
     = [ (the_Vertices_of H) |` (f"), (g | the_Edges_of H)"] by GLIB_009:5
    .= H |` (F") by GLIB_009:5;
end;

theorem
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2,
    H being Subgraph of G2 holds (H |` F)" = F" | H
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  let H be Subgraph of G2;
  (F"|H)" = H |` ((F")") by Th82;
  then ((F"|H)")" = (H |` F)" by Th70;
  hence thesis by Th70;
end;

:: properties derived by use of F"

theorem Th84:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2 st F is isomorphism
  holds G1.order() = G2.order() & G1.size() = G2.size()
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is isomorphism;
  then reconsider F as one-to-one PGraphMapping of G1, G2;
  A2: G1.order() c= G2.order() & G1.size() c= G2.size() by A1, Th45;
  F" is isomorphism by A1, Th75;
  then G2.order() c= G1.order() & G2.size() c= G1.size() by Th45;
  hence thesis by A2, XBOOLE_0:def 10;
end;

theorem
  for G1, G2 being _finite _Graph, F being PGraphMapping of G1, G2
  st F is strong_SG-embedding
  holds (ex F0 being PGraphMapping of G1, G2 st F0 is isomorphism)
    implies F is isomorphism
proof
  let G1, G2 be _finite _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is strong_SG-embedding;
  given F0 being PGraphMapping of G1, G2 such that
    A2: F0 is isomorphism;
  G1.order() = G2.order() & G1.size() = G2.size() by A2, Th84;
  hence thesis by A1, Th51;
end;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  for X,Y being Subset of the_Vertices_of G1 st F is isomorphism
  holds card G1.edgesBetween(X,Y) = card G2.edgesBetween(F_V.:X,F_V.:Y)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  let X,Y be Subset of the_Vertices_of G1;
  assume A1: F is isomorphism;
  then A2: card G1.edgesBetween(X,Y) c= card G2.edgesBetween(F_V.:X,F_V.:Y)
    by Th46;
  reconsider F0 = F as one-to-one PGraphMapping of G1, G2 by A1;
  F0" is isomorphism by A1, Th75;
  then A3: card G2.edgesBetween(F_V.:X,F_V.:Y)
    c= card G1.edgesBetween(F0"_V.:(F_V.:X),F0"_V.:(F_V.:Y)) by Th46;
  A4: dom F_V = the_Vertices_of G1 by A1, Def11;
  A5: F0"_V.:(F_V.:X) = (F_V)"(F_V.:X) by FUNCT_1:85
    .= X by A1, A4, FUNCT_1:94;
  F0"_V.:(F_V.:Y) = (F_V)"(F_V.:Y) by FUNCT_1:85
    .= Y by A1, A4, FUNCT_1:94;
  hence thesis by A2, A3, A5, XBOOLE_0:def 10;
end;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  for X being Subset of the_Vertices_of G1 st F is isomorphism
  holds card G1.edgesBetween(X) = card G2.edgesBetween(F_V.:X)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  let X be Subset of the_Vertices_of G1;
  assume A1: F is isomorphism;
  then A2: card G1.edgesBetween(X) c= card G2.edgesBetween(F_V.:X) by Th47;
  reconsider F0 = F as one-to-one PGraphMapping of G1, G2 by A1;
  F0" is isomorphism by A1, Th75;
  then A3: card G2.edgesBetween(F_V.:X)
    c= card G1.edgesBetween(F0"_V.:(F_V.:X)) by Th47;
  A4: dom F_V = the_Vertices_of G1 by A1, Def11;
  F0"_V.:(F_V.:X) = (F_V)"(F_V.:X) by FUNCT_1:85
    .= X by A1, A4, FUNCT_1:94;
  hence thesis by A2, A3, XBOOLE_0:def 10;
end;

theorem
  for G1, G2 being _Graph, F being directed PGraphMapping of G1, G2
  for X,Y being Subset of the_Vertices_of G1 st F is isomorphism
  holds card G1.edgesDBetween(X,Y) = card G2.edgesDBetween(F_V.:X,F_V.:Y)
proof
  let G1, G2 be _Graph, F be directed PGraphMapping of G1, G2;
  let X,Y be Subset of the_Vertices_of G1;
  assume A1: F is isomorphism;
  then A2: card G1.edgesDBetween(X,Y) c= card G2.edgesDBetween(F_V.:X,F_V.:Y)
    by Th48;
  reconsider F0 = F as one-to-one PGraphMapping of G1, G2 by A1;
  F0" is isomorphism by A1, Th75;
  then A3: card G2.edgesDBetween(F_V.:X,F_V.:Y)
    c= card G1.edgesDBetween(F0"_V.:(F_V.:X),F0"_V.:(F_V.:Y)) by Th48;
  A4: dom F_V = the_Vertices_of G1 by A1, Def11;
  A5: F0"_V.:(F_V.:X) = (F_V)"(F_V.:X) by FUNCT_1:85
    .= X by A1, A4, FUNCT_1:94;
  F0"_V.:(F_V.:Y) = (F_V)"(F_V.:Y) by FUNCT_1:85
    .= Y by A1, A4, FUNCT_1:94;
  hence thesis by A2, A3, A5, XBOOLE_0:def 10;
end;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is isomorphism holds
    (G1 is _trivial iff G2 is _trivial) &
    (G1 is loopless iff G2 is loopless) &
    (G1 is edgeless iff G2 is edgeless) &
    (G1 is non-multi iff G2 is non-multi) &
    (G1 is simple iff G2 is simple) &
    (G1 is _finite iff G2 is _finite) &
    (G1 is complete iff G2 is complete)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is isomorphism;
  then reconsider F as one-to-one PGraphMapping of G1, G2;
  F" is isomorphism by A1, Th75;
  hence thesis by A1, Th35, Th49, Th52;
end;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is Dcontinuous isomorphism holds
    (G1 is non-Dmulti iff G2 is non-Dmulti) &
    (G1 is Dsimple iff G2 is Dsimple)
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is Dcontinuous isomorphism;
  then reconsider F0 = F as one-to-one PGraphMapping of G1, G2;
  F0" is Dcontinuous isomorphism by A1, Th74, Th75;
  hence thesis by A1, Th50;
end;

Lm4:
  for G1, G2 being _Graph, F being non empty one-to-one PGraphMapping of G1, G2
  holds card((dom F).loops()) c= card((rng F).loops())
proof
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  now
    reconsider f = F_E | (dom F).loops() as Function;
    take f;
    thus f is one-to-one by FUNCT_1:52;
    (dom F).loops() c= the_Edges_of dom F;
    then A1: (dom F).loops() c= dom F_E by Th54;
    thus A2: dom f = dom F_E /\ (dom F).loops() by RELAT_1:61
      .= (dom F).loops() by A1, XBOOLE_1:28;
    now
      let y be object;
      assume y in rng f;
      then consider x being object such that
        A3: x in dom f & f.x = y by FUNCT_1:def 3;
      consider v being object such that
        A4: x Joins v,v,dom F by A2, A3, GLIB_009:def 2;
      v in the_Vertices_of dom F by A4, GLIB_000:13;
      then A5: v in dom F_V by Th54;
      A6: x in dom F_E by A3, RELAT_1:57;
      x is set & v is set by TARSKI:1;
      then x Joins v,v,G1 by A4, GLIB_000:72;
      then A7: F_E.x Joins F_V.v,F_V.v,G2 by A5, A6, Th4;
      F_E.x in rng F_E by A6, FUNCT_1:3;
      then F_E.x in the_Edges_of rng F by Th54;
      then F_E.x Joins F_V.v,F_V.v,rng F by A7, GLIB_000:73;
      then F_E.x in (rng F).loops() by GLIB_009:def 2;
      hence y in (rng F).loops() by A3, FUNCT_1:47;
    end;
    hence rng f c= (rng F).loops() by TARSKI:def 3;
  end;
  hence thesis by CARD_1:10;
end;

theorem
  for G1, G2 being _Graph, F being non empty one-to-one PGraphMapping of G1, G2
  holds card((dom F).loops()) = card((rng F).loops())
proof
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  reconsider F2 = F" as non empty one-to-one PGraphMapping of G2, G1;
  A1: card((dom F).loops()) c= card((rng F).loops()) &
    card((dom F2).loops()) c= card((rng F2).loops()) by Lm4;
  dom F2 = rng F & rng F2 = dom F by Th81;
  hence thesis by A1, XBOOLE_0:def 10;
end;

theorem Th92:
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  st F is total holds card(G1.loops()) c= card(G2.loops())
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  assume A1: F is total;
  then reconsider F as non empty one-to-one PGraphMapping of G1, G2;
  A2: (dom F).loops() = G1.loops() by A1, Th55, GLIB_009:50;
  A3: card (rng F).loops() c= card G2.loops() by GLIB_009:48, CARD_1:11;
  card (dom F).loops() c= card (rng F).loops() by Lm4;
  hence thesis by A2, A3, XBOOLE_1:1;
end;

theorem Th93:
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  st F is onto holds card(G2.loops()) c= card(G1.loops())
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  reconsider F2 = F" as one-to-one PGraphMapping of G2, G1;
  assume F is onto;
  then F2 is total by Th72;
  hence thesis by Th92;
end;

theorem
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  st F is isomorphism holds card(G1.loops()) = card(G2.loops())
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  assume F is isomorphism;
  then card G1.loops() c= card G2.loops() & card G2.loops() c= card G1.loops()
    by Th92, Th93;
  hence thesis by XBOOLE_0:def 10;
end;

theorem
  for G1 being _Graph, G2 being G1-isomorphic _Graph
  holds G1 is G2-isomorphic
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  consider F being PGraphMapping of G1, G2 such that
    A1: F is isomorphism by Def23;
  reconsider F as one-to-one PGraphMapping of G1, G2 by A1;
  take F";
  thus thesis by A1, Th75;
end;

theorem
  for G1 being _Graph, G2 being G1-Disomorphic _Graph
  holds G1 is G2-Disomorphic
proof
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  consider F being PGraphMapping of G1, G2 such that
    A1: F is Disomorphism by Def24;
  reconsider F as one-to-one Dcontinuous PGraphMapping of G1, G2 by A1;
  take F";
  thus thesis by A1, Th71, Th72;
end;

theorem Th97:
  for G1 being _Graph, G2 being G1-isomorphic _Graph
  for G3 being G2-isomorphic _Graph, F being Isomorphism of G1, G2
  st (ex E being set st G3 is reverseEdgeDirections of G1, E)
  holds F" is Isomorphism of G2, G3
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  let G3 be G2-isomorphic _Graph, F being Isomorphism of G1, G2;
  given E being set such that
    A1: G3 is reverseEdgeDirections of G1, E;
  G2 is reverseEdgeDirections of G2, {} by GLIB_009:43;
  then reconsider F2 = F" as PGraphMapping of G2, G3 by A1, Th10;
  A2: F2 is total
  proof
    thus dom F2_V = rng F_V by FUNCT_1:33
      .= the_Vertices_of G2 by Def12;
    thus dom F2_E = rng F_E by FUNCT_1:33
      .= the_Edges_of G2 by Def12;
  end;
  A3: F2 is onto
  proof
    thus rng F2_V = dom F_V by FUNCT_1:33
      .= the_Vertices_of G1 by Def11
      .= the_Vertices_of G3 by A1, GLIB_007:4;
    thus rng F2_E = dom F_E by FUNCT_1:33
      .= the_Edges_of G1 by Def11
      .= the_Edges_of G3 by A1, GLIB_007:4;
  end;
  F2 is one-to-one;
  hence thesis by A2, A3;
end;

theorem
  for G1 being _Graph, G2 being G1-isomorphic _Graph
  for G3 being G2-isomorphic _Graph, F being Isomorphism of G1, G2
  st G1 == G3 holds F" is Isomorphism of G2, G3
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  let G3 be G2-isomorphic _Graph, F being Isomorphism of G1, G2;
  assume A1: G1 == G3;
  G1 is reverseEdgeDirections of G1, {} by GLIB_009:43;
  then G3 is reverseEdgeDirections of G1, {} by A1, GLIB_007:2;
  hence thesis by Th97;
end;

theorem
  for G1 being _Graph, G2 being G1-Disomorphic _Graph
  for G3 being G2-Disomorphic _Graph, F being DIsomorphism of G1, G2
  st G1 == G3 holds F" is DIsomorphism of G2, G3
proof
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  let G3 be G2-Disomorphic _Graph, F being DIsomorphism of G1, G2;
  assume A1: G1 == G3;
  then reconsider F2 = F" as PGraphMapping of G2, G3 by Th9;
  A2: F2 is total
  proof
    thus dom F2_V = rng F_V by FUNCT_1:33
      .= the_Vertices_of G2 by Def12;
    thus dom F2_E = rng F_E by FUNCT_1:33
      .= the_Edges_of G2 by Def12;
  end;
  A3: F2 is onto
  proof
    thus rng F2_V = dom F_V by FUNCT_1:33
      .= the_Vertices_of G1 by Def11
      .= the_Vertices_of G3 by A1, GLIB_000:def 34;
    thus rng F2_E = dom F_E by FUNCT_1:33
      .= the_Edges_of G1 by Def11
      .= the_Edges_of G3 by A1, GLIB_000:def 34;
  end;
  A4: F2 is one-to-one;
  now
    let e,v,w be object;
    assume e in dom F2_E & v in dom F2_V & w in dom F2_V;
    then A5: e in dom(F"_E) & v in dom(F"_V) & w in dom(F"_V);
    assume e DJoins v,w,G2;
    then (F"_E).e DJoins (F"_V).v,(F"_V).w,G1 by A5, Def14;
    hence (F"_E).e DJoins (F"_V).v,(F"_V).w,G3 by A1, GLIB_000:88;
  end;
  then F2 is directed;
  hence thesis by A2, A3, A4;
end;

:: define composition of graph mappings

definition
  let G1, G2, G3 be _Graph;
  let F1 be PGraphMapping of G1, G2, F2 be PGraphMapping of G2, G3;
  func F2 * F1 -> PGraphMapping of G1, G3 equals
  [ F2_V * F1_V, F2_E * F1_E ];
  coherence
  proof
    reconsider f = F2_V * F1_V
      as PartFunc of the_Vertices_of G1, the_Vertices_of G3;
    reconsider g = F2_E * F1_E as PartFunc of the_Edges_of G1, the_Edges_of G3;
    :: show properties of definition
    now
      hereby
        let e be object;
        assume e in dom g;
        then A1: e in dom F1_E & F1_E.e in dom F2_E by FUNCT_1:11;
        then A2: (the_Source_of G1).e in dom F1_V &
          (the_Target_of G1).e in dom F1_V by Th5;
        A3: (the_Source_of G2).(F1_E.e) in dom F2_V &
          (the_Target_of G2).(F1_E.e) in dom F2_V by A1, Th5;
        e Joins (the_Source_of G1).e, (the_Target_of G1).e, G1
          by A1, GLIB_000:def 13;
        then F1_E.e Joins F1_V.((the_Source_of G1).e),
          F1_V.((the_Target_of G1).e), G2 by A1, A2, Th4;
        then per cases by GLIB_000:def 13;
        suppose F1_V.((the_Source_of G1).e) = (the_Source_of G2).(F1_E.e) &
            F1_V.((the_Target_of G1).e) = (the_Target_of G2).(F1_E.e);
          hence (the_Source_of G1).e in dom f &
            (the_Target_of G1).e in dom f by A2, A3, FUNCT_1:11;
        end;
        suppose F1_V.((the_Source_of G1).e) = (the_Target_of G2).(F1_E.e) &
            F1_V.((the_Target_of G1).e) = (the_Source_of G2).(F1_E.e);
          hence (the_Source_of G1).e in dom f &
            (the_Target_of G1).e in dom f by A2, A3, FUNCT_1:11;
        end;
      end;
      let e,v,w be object;
      assume A4: e in dom g & v in dom f & w in dom f;
      then A5: e in dom F1_E & F1_E.e in dom F2_E by FUNCT_1:11;
      A6: v in dom F1_V & F1_V.v in dom F2_V &
        w in dom F1_V & F1_V.w in dom F2_V by A4, FUNCT_1:11;
      e Joins v,w,G1 implies F1_E.e Joins F1_V.v,F1_V.w,G2 by A5, A6, Th4;
      then A7: e Joins v,w,G1 implies F2_E.(F1_E.e) Joins
        F2_V.(F1_V.v),F2_V.(F1_V.w),G3 by A5, A6, Th4;
      F2_V.(F1_V.v) = f.v & F2_V.(F1_V.w) = f.w by A4, FUNCT_1:12;
      hence e Joins v,w,G1 implies g.e Joins f.v,f.w,G3 by A4, A7, FUNCT_1:12;
    end;
    hence thesis by Th8;
  end;
end;

theorem :: this would otherwise need Proof outside of this article
  for G1, G2, G3 being _Graph
  for F1 being PGraphMapping of G1, G2, F2 being PGraphMapping of G2, G3
  holds (F2*F1)_V = F2_V * F1_V & (F2*F1)_E = F2_E * F1_E;

theorem
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F2 * F1 is onto holds F2 is onto
proof
  let G1, G2, G3 be _Graph, F1 be PGraphMapping of G1, G2,
    F2 be PGraphMapping of G2, G3;
  assume F2 * F1 is onto;
  then the_Vertices_of G3 c= rng F2_V & the_Edges_of G3 c= rng F2_E
    by RELAT_1:26;
  hence thesis by XBOOLE_0:def 10;
end;

theorem
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F2 * F1 is total holds F1 is total
proof
  let G1, G2, G3 be _Graph, F1 be PGraphMapping of G1, G2,
    F2 be PGraphMapping of G2, G3;
  assume F2 * F1 is total;
  then the_Vertices_of G1 c= dom F1_V & the_Edges_of G1 c= dom F1_E
    by RELAT_1:25;
  hence thesis by XBOOLE_0:def 10;
end;

registration
  let G1, G2, G3 be _Graph;
  let F1 be one-to-one PGraphMapping of G1, G2;
  let F2 be one-to-one PGraphMapping of G2, G3;
  cluster F2 * F1 -> one-to-one;
  coherence;
end;

registration
  let G1, G2, G3 be _Graph;
  let F1 be semi-continuous PGraphMapping of G1, G2;
  let F2 be semi-continuous PGraphMapping of G2, G3;
  cluster F2 * F1 -> semi-continuous;
  coherence
  proof
    set g = F2_E * F1_E, f = F2_V * F1_V;
    let e,v,w be object;
    assume A1: e in dom (F2*F1)_E & v in dom (F2*F1)_V & w in dom (F2*F1)_V;
    then A2: e in dom F1_E & F1_E.e in dom F2_E by FUNCT_1:11;
    A3: v in dom F1_V & F1_V.v in dom F2_V &
      w in dom F1_V & F1_V.w in dom F2_V by A1, FUNCT_1:11;
    e Joins v,w,G1 iff F1_E.e Joins F1_V.v,F1_V.w,G2 by A2, A3, Th15;
    then A4: e Joins v,w,G1 iff F2_E.(F1_E.e) Joins
      F2_V.(F1_V.v),F2_V.(F1_V.w),G3 by A2, A3, Th15;
    F2_V.(F1_V.v) = f.v & F2_V.(F1_V.w) = f.w by A1, FUNCT_1:12;
    hence thesis by A1, A4, FUNCT_1:12;
  end;
end;

registration
  let G1, G2, G3 be _Graph;
  let F1 be continuous PGraphMapping of G1, G2;
  let F2 be continuous PGraphMapping of G2, G3;
  cluster F2 * F1 -> continuous;
  coherence
  proof
    let e9,v,w be object;
    assume A1: v in dom (F2*F1)_V & w in dom (F2*F1)_V &
      e9 Joins (F2*F1)_V.v,(F2*F1)_V.w,G3;
    then A2: v in dom F1_V & F1_V.v in dom F2_V &
      w in dom F1_V & F1_V.w in dom F2_V by FUNCT_1:11;
    then (F2*F1)_V.v = F2_V.(F1_V.v) & (F2*F1)_V.w = F2_V.(F1_V.w)
      by FUNCT_1:13;
    then consider e8 being object such that
      A3: e8 Joins F1_V.v,F1_V.w,G2 & e8 in dom F2_E & F2_E.e8 = e9
      by A1, A2, Def16;
    consider e being object such that
      A4: e Joins v,w,G1 & e in dom F1_E & F1_E.e = e8 by A2, A3, Def16;
    take e;
    thus e Joins v,w,G1 by A4;
    thus e in dom (F2*F1)_E by A3, A4, FUNCT_1:11;
    hence (F2*F1)_E.e = e9 by A3, A4, FUNCT_1:12;
  end;
end;

registration
  let G1, G2, G3 be _Graph;
  let F1 be directed PGraphMapping of G1, G2;
  let F2 be directed PGraphMapping of G2, G3;
  cluster F2 * F1 -> directed;
  coherence
  proof
    set g = F2_E * F1_E, f = F2_V * F1_V;
    let e,v,w be object;
    assume A1: e in dom (F2*F1)_E & v in dom (F2*F1)_V & w in dom (F2*F1)_V;
    then A2: e in dom F1_E & F1_E.e in dom F2_E by FUNCT_1:11;
    A3: v in dom F1_V & F1_V.v in dom F2_V &
      w in dom F1_V & F1_V.w in dom F2_V by A1, FUNCT_1:11;
    e DJoins v,w,G1 implies F1_E.e DJoins F1_V.v,F1_V.w,G2 by A2, A3, Def14;
    then A4: e DJoins v,w,G1 implies F2_E.(F1_E.e) DJoins
      F2_V.(F1_V.v),F2_V.(F1_V.w),G3 by A2, A3, Def14;
    F2_V.(F1_V.v) = f.v & F2_V.(F1_V.w) = f.w by A1, FUNCT_1:12;
    hence thesis by A1, A4, FUNCT_1:12;
  end;
end;

registration
  let G1, G2, G3 be _Graph;
  let F1 be semi-Dcontinuous PGraphMapping of G1, G2;
  let F2 be semi-Dcontinuous PGraphMapping of G2, G3;
  cluster F2 * F1 -> semi-Dcontinuous;
  coherence
  proof
    set g = F2_E * F1_E, f = F2_V * F1_V;
    let e,v,w be object;
    assume A1: e in dom (F2*F1)_E & v in dom (F2*F1)_V & w in dom (F2*F1)_V;
    then A2: e in dom F1_E & F1_E.e in dom F2_E by FUNCT_1:11;
    A3: v in dom F1_V & F1_V.v in dom F2_V &
      w in dom F1_V & F1_V.w in dom F2_V by A1, FUNCT_1:11;
    e DJoins v,w,G1 iff F1_E.e DJoins F1_V.v,F1_V.w,G2 by A2, A3, Th16;
    then A4: e DJoins v,w,G1 iff F2_E.(F1_E.e) DJoins
      F2_V.(F1_V.v),F2_V.(F1_V.w),G3 by A2, A3, Th16;
    F2_V.(F1_V.v) = f.v & F2_V.(F1_V.w) = f.w by A1, FUNCT_1:12;
    hence thesis by A1, A4, FUNCT_1:12;
  end;
end;

registration
  let G1, G2, G3 be _Graph;
  let F1 be Dcontinuous PGraphMapping of G1, G2;
  let F2 be Dcontinuous PGraphMapping of G2, G3;
  cluster F2 * F1 -> Dcontinuous;
  coherence
  proof
    let e9,v,w be object;
    assume A1: v in dom (F2*F1)_V & w in dom (F2*F1)_V &
      e9 DJoins (F2*F1)_V.v,(F2*F1)_V.w,G3;
    then A2: v in dom F1_V & F1_V.v in dom F2_V &
      w in dom F1_V & F1_V.w in dom F2_V by FUNCT_1:11;
    then (F2*F1)_V.v = F2_V.(F1_V.v) & (F2*F1)_V.w = F2_V.(F1_V.w)
      by FUNCT_1:13;
    then consider e8 being object such that
      A3: e8 DJoins F1_V.v,F1_V.w,G2 & e8 in dom F2_E & F2_E.e8 = e9
      by A1, A2, Def18;
    consider e being object such that
      A4: e DJoins v,w,G1 & e in dom F1_E & F1_E.e = e8 by A2, A3, Def18;
    take e;
    thus e DJoins v,w,G1 by A4;
    thus e in dom (F2*F1)_E by A3, A4, FUNCT_1:11;
    hence (F2*F1)_E.e = e9 by A3, A4, FUNCT_1:12;
  end;
end;

registration
  let G1, G2, G3 be _Graph;
  let F1 be empty PGraphMapping of G1, G2;
  let F2 be PGraphMapping of G2, G3;
  cluster F2 * F1 -> empty;
  coherence;
end;

registration
  let G1, G2, G3 be _Graph;
  let F1 be PGraphMapping of G1, G2;
  let F2 be empty PGraphMapping of G2, G3;
  cluster F2 * F1 -> empty;
  coherence;
end;

theorem Th103:
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F1 is total & rng F1_V c= dom F2_V & rng F1_E c= dom F2_E
  holds F2 * F1 is total by RELAT_1:27;

theorem Th104:
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F1 is total & F2 is total holds F2 * F1 is total
proof
  let G1, G2, G3 be _Graph;
  let F1 be PGraphMapping of G1, G2;
  let F2 be PGraphMapping of G2, G3;
  assume A1: F1 is total & F2 is total;
  then rng F1_V c= dom F2_V & rng F1_E c= dom F2_E;
  hence thesis by A1, Th103;
end;

theorem Th105:
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F2 is onto & dom F2_V c= rng F1_V & dom F2_E c= rng F1_E
  holds F2 * F1 is onto by RELAT_1:28;

theorem Th106:
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F1 is onto & F2 is onto holds F2 * F1 is onto
proof
  let G1, G2, G3 be _Graph;
  let F1 be PGraphMapping of G1, G2;
  let F2 be PGraphMapping of G2, G3;
  assume A1: F1 is onto & F2 is onto;
  then dom F2_V c= rng F1_V & dom F2_E c= rng F1_E;
  hence thesis by A1, Th105;
end;

theorem
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F1 is weak_SG-embedding & F2 is weak_SG-embedding
  holds F2 * F1 is weak_SG-embedding by Th104;

theorem
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F1 is strong_SG-embedding & F2 is strong_SG-embedding
  holds F2 * F1 is strong_SG-embedding by Th104;

theorem Th109:
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3 st F1 is isomorphism & F2 is isomorphism
  holds F2 * F1 is isomorphism by Th104, Th106;

theorem Th110:
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3 st F1 is Disomorphism & F2 is Disomorphism
  holds F2 * F1 is Disomorphism
proof
  let G1, G2, G3 be _Graph;
  let F1 be PGraphMapping of G1, G2, F2 be PGraphMapping of G2, G3;
  assume F1 is Disomorphism & F2 is Disomorphism;
  then F2 * F1 is directed isomorphism by Th109;
  hence thesis;
end;

theorem
  for G1, G2, G3 being WGraph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F1 is weight-preserving & F2 is weight-preserving
  holds F2 * F1 is weight-preserving
proof
  let G1, G2, G3 be WGraph;
  let F1 be PGraphMapping of G1, G2, F2 be PGraphMapping of G2, G3;
  assume A1: F1 is weight-preserving & F2 is weight-preserving;
  thus the_Weight_of G3 * (F2 * F1)_E
     = (the_Weight_of G3 * F2_E) * F1_E by RELAT_1:36
    .= (the_Weight_of G1) | dom (F2 * F1)_E  by A1, Th1;
end;

theorem
  for G1, G2, G3 being EGraph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F1 is elabel-preserving & F2 is elabel-preserving
  holds F2 * F1 is elabel-preserving
proof
  let G1, G2, G3 be EGraph;
  let F1 be PGraphMapping of G1, G2, F2 be PGraphMapping of G2, G3;
  assume A1: F1 is elabel-preserving & F2 is elabel-preserving;
  thus the_ELabel_of G3 * (F2 * F1)_E
     = (the_ELabel_of G3 * F2_E) * F1_E by RELAT_1:36
    .= (the_ELabel_of G1) | dom (F2 * F1)_E by A1, Th1;
end;

theorem
  for G1, G2, G3 being VGraph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3
  st F1 is vlabel-preserving & F2 is vlabel-preserving
  holds F2 * F1 is vlabel-preserving
proof
  let G1, G2, G3 be VGraph;
  let F1 be PGraphMapping of G1, G2, F2 be PGraphMapping of G2, G3;
  assume A1: F1 is vlabel-preserving & F2 is vlabel-preserving;
  thus the_VLabel_of G3 * (F2 * F1)_V
     = (the_VLabel_of G3 * F2_V) * F1_V by RELAT_1:36
    .= (the_VLabel_of G1) | dom (F2 * F1)_V by A1, Th1;
end;

theorem
  for G1, G2, G3, G4 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3, F3 being PGraphMapping of G3, G4
  holds F3 * (F2 * F1) = (F3 * F2) * F1
proof
  let G1, G2, G3, G4 be _Graph, F1 be PGraphMapping of G1, G2,
    F2 be PGraphMapping of G2, G3, F3 be PGraphMapping of G3, G4;
  thus F3 * (F2 * F1)
     = [(F3_V * F2_V) * F1_V, F3_E * (F2_E * F1_E)] by RELAT_1:36
    .= (F3 * F2) * F1 by RELAT_1:36;
end;

theorem
  for G1, G2 being _Graph, F being one-to-one PGraphMapping of G1, G2
  st F is isomorphism holds F*(F") = id G2 & (F")*F = id G1
proof
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  assume A1: F is isomorphism;
  thus F*(F") = [id rng F_V, F_E * (F_E")] by FUNCT_1:39
    .= [id rng F_V, id rng F_E] by FUNCT_1:39
    .= [id the_Vertices_of G2, id rng F_E] by A1, Def12
    .= id G2 by A1, Def12;
  thus (F")*F = [id dom F_V, (F_E") * F_E] by FUNCT_1:39
    .= [id dom F_V, id dom F_E] by FUNCT_1:39
    .= [id the_Vertices_of G1, id dom F_E] by A1, Def11
    .= id G1 by A1, Def11;
end;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  holds F * id G1 = F & (id G2) * F = F
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  A1: dom F_V c= the_Vertices_of G1 & dom F_E c= the_Edges_of G1;
  thus F * id G1 = [F_V, F_E * id the_Edges_of G1] by A1, RELAT_1:51
    .= [F_V, F_E] by A1, RELAT_1:51
    .= F;
  A2: rng F_V c= the_Vertices_of G2 & rng F_E c= the_Edges_of G2;
  thus (id G2) * F = [F_V, (id the_Edges_of G2) * F_E] by A2, RELAT_1:53
    .= [F_V, F_E] by A2, RELAT_1:53
    .= F;
end;

theorem
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3, H being Subgraph of G1
  holds F2 * (F1|H) = (F2*F1) | H
proof
  let G1, G2, G3 be _Graph;
  let F1 be PGraphMapping of G1, G2;
  let F2 be PGraphMapping of G2, G3;
  let H be Subgraph of G1;
  thus F2 * (F1|H)
     = [ (F2_V * F1_V) | the_Vertices_of H, F2_E * (F1_E | the_Edges_of H) ]
      by RELAT_1:83
    .= (F2*F1) | H by RELAT_1:83;
end;

theorem
  for G1, G2, G3 being _Graph, F1 being PGraphMapping of G1, G2,
    F2 being PGraphMapping of G2, G3, H being Subgraph of G3
  holds (H|`F2) * F1 = H |` (F2*F1)
proof
  let G1, G2, G3 be _Graph;
  let F1 be PGraphMapping of G1, G2;
  let F2 be PGraphMapping of G2, G3;
  let H be Subgraph of G3;
  thus (H|`F2) * F1
     = [ (the_Vertices_of H) |` (F2_V * F1_V),
      ((the_Edges_of H) |` F2_E) * F1_E ] by RELAT_1:108
    .= H |` (F2*F1) by RELAT_1:108;
end;

registration
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  cluster G2-isomorphic -> G1-isomorphic for _Graph;
  coherence
  proof
    let G3 be _Graph;
    assume G3 is G2-isomorphic;
    then consider F2 being PGraphMapping of G2, G3 such that
      A1: F2 is isomorphism;
    consider F1 being PGraphMapping of G1, G2 such that
      A2: F1 is isomorphism by Def23;
    take F2*F1;
    thus thesis by A1, A2, Th109;
  end;
end;

registration
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  cluster G2-Disomorphic -> G1-Disomorphic for _Graph;
  coherence
  proof
    let G3 be _Graph;
    assume G3 is G2-Disomorphic;
    then consider F2 being PGraphMapping of G2, G3 such that
      A1: F2 is Disomorphism;
    reconsider F2 as directed PGraphMapping of G2, G3 by A1;
    consider F1 being PGraphMapping of G1, G2 such that
      A2: F1 is Disomorphism by Def24;
    reconsider F1 as directed PGraphMapping of G1, G2 by A2;
    take F2*F1;
    thus thesis by A1, A2, Th110;
  end;
end;

begin :: Walks induced by Graph Mappings

definition
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2, W1 be Walk of G1;
  attr W1 is F-defined means
  :Def35:
  W1.vertices() c= dom F_V & W1.edges() c= dom F_E;
end;

definition
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2, W2 be Walk of G2;
  attr W2 is F-valued means
  :Def36:
  W2.vertices() c= rng F_V & W2.edges() c= rng F_E;
end;

registration
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  cluster F-defined trivial for Walk of G1;
  existence
  proof
    set v = the Element of dom F_V;
    reconsider v as Vertex of G1;
    set W1 = G1.walkOf(v);
    take W1;
    W1.vertices() = {v} by GLIB_001:90;
    hence W1.vertices() c= dom F_V by ZFMISC_1:31;
    thus W1.edges() c= dom F_E by XBOOLE_1:2;
    thus thesis;
  end;
  cluster F-valued trivial for Walk of G2;
  existence
  proof
    set v = the Element of rng F_V;
    reconsider v as Vertex of G2;
    set W2 = G2.walkOf(v);
    take W2;
    W2.vertices() = {v} by GLIB_001:90;
    hence W2.vertices() c= rng F_V by ZFMISC_1:31;
    thus W2.edges() c= rng F_E by XBOOLE_1:2;
    thus thesis;
  end;
end;

theorem
  for G1, G2 being _Graph, F being empty PGraphMapping of G1, G2,
    W1 being Walk of G1 holds W1 is non F-defined by XBOOLE_1:3;

theorem
  for G1, G2 being _Graph, F being empty PGraphMapping of G1, G2,
    W2 being Walk of G2 holds W2 is non F-valued by XBOOLE_1:3;

theorem Th121:
  for G1, G2 being _Graph, F be PGraphMapping of G1, G2, W1 being Walk of G1
  st F is total holds W1 is F-defined;

theorem Th122:
  for G1, G2 being _Graph, F be PGraphMapping of G1, G2, W2 being Walk of G2
  st F is onto holds W2 is F-valued;

registration
  let G1, G2 be _Graph, F be one-to-one PGraphMapping of G1, G2;
  cluster F-defined -> F"-valued for Walk of G1;
  coherence by FUNCT_1:33;
  cluster F-valued -> F"-defined for Walk of G2;
  coherence by FUNCT_1:33;
end;

definition
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  func F.:W1 -> Walk of G2 means
  :Def37:
  F_V * W1.vertexSeq() = it.vertexSeq() & F_E * W1.edgeSeq() = it.edgeSeq();
  existence
  proof
    W1.vertices() c= dom F_V by Def35;
    then A1: rng W1.vertexSeq() c= dom F_V by GLIB_001:def 16;
    then reconsider p = F_V * W1.vertexSeq() as FinSequence by FINSEQ_1:16;
    rng p c= the_Vertices_of G2 by RELAT_1:def 19;
    then reconsider p as FinSequence of the_Vertices_of G2 by FINSEQ_1:def 4;
    W1.edges() c= dom F_E by Def35;
    then A2: rng W1.edgeSeq() c= dom F_E by GLIB_001:def 17;
    then reconsider q = F_E * W1.edgeSeq() as FinSequence by FINSEQ_1:16;
    rng q c= the_Edges_of G2 by RELAT_1:def 19;
    then reconsider q as FinSequence of the_Edges_of G2 by FINSEQ_1:def 4;
    A3: 2*len p = 2*len W1.vertexSeq() by A1, FINSEQ_2:29
      .= len W1 + 1 by GLIB_001:def 14
      .= (2*len W1.edgeSeq()+1) + 1 by GLIB_001:def 15
      .= (2*len q+1) + 1 by A2, FINSEQ_2:29
      .= 2*(len q+1);
    for n being Element of NAT st 1 <= n & n+1 <= len p
      holds q.n Joins p.n, p.(n+1), G2
    proof
      let n be Element of NAT;
      assume A4: 1 <= n & n+1 <= len p;
      then A5: n <= len q by A3, XREAL_1:6;
      n+0 <= n+1 by XREAL_1:6;
      then A6: n <= len p by A4, XXREAL_0:2;
      then A7: n in dom p by A4, FINSEQ_3:25;
      A8: 1+0 <= n+1 by XREAL_1:7;
      then A9: n+1 in dom p by A4, FINSEQ_3:25;
      n in dom q by A4, A5, FINSEQ_3:25;
      then A10: n in dom W1.vertexSeq() & W1.vertexSeq().n in dom F_V &
        n+1 in dom W1.vertexSeq() & W1.vertexSeq().(n+1) in dom F_V &
        n in dom W1.edgeSeq()& W1.edgeSeq().n in dom F_E by A7, A9, FUNCT_1:11;
      n <= len W1.edgeSeq() & n <= len W1.vertexSeq() &
        n+1 <= len W1.vertexSeq() by A1, A2, A4, A5, A6, FINSEQ_2:29;
      then A11: W1.edgeSeq().n = W1.(2*n) & W1.vertexSeq().n = W1.(2*n-1) &
        W1.vertexSeq().(n+1) = W1.(2*(n+1)-1)
        by A4, A8, GLIB_001:def 14, GLIB_001:def 15;
      2*1 <= 2*n by A4, XREAL_1:64;
      then 2-1 <= 2*n-1 by XREAL_1:9;
      then reconsider m = 2*n-1 as Element of NAT by INT_1:3;
      2*(n+1) <= 2*len p by A4, XREAL_1:64;
      then 2*n+2 <= 2*len p -2+2;
      then m <= 2*(len p)-2-1 by XREAL_1:6, XREAL_1:9;
      then m <= 2*len W1.vertexSeq() -2-1 by A1, FINSEQ_2:29;
      then A12: m <= len W1 +1 -2-1 by GLIB_001:def 14;
      len W1 -2 < len W1 -0 by XREAL_1:15;
      then m < len W1 by A12, XXREAL_0:2;
      then A13: W1.(m+1) Joins W1.m, W1.(m+2), G1 by GLIB_001:def 3;
      F_E.(W1.edgeSeq().n) Joins F_V.(W1.vertexSeq().n),
        F_V.(W1.vertexSeq().(n+1)), G2 by A10, A11, A13, Th4;
      then q.n Joins F_V.(W1.vertexSeq().n), F_V.(W1.vertexSeq().(n+1)), G2
        by A10, FUNCT_1:13;
      then q.n Joins p.n, F_V.(W1.vertexSeq().(n+1)), G2 by A10, FUNCT_1:13;
      hence q.n Joins p.n, p.(n+1), G2 by A10, FUNCT_1:13;
    end;
    then consider W2 being Walk of G2 such that
      A14: W2.vertexSeq() = p & W2.edgeSeq() = q by A3, GLIB_009:27;
    take W2;
    thus thesis by A14;
  end;
  uniqueness by GLIB_009:26;
end;

registration
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  cluster F.:W1 -> F-valued;
  coherence
  proof
    A1: F_V * W1.vertexSeq() = (F.:W1).vertexSeq() &
      F_E * W1.edgeSeq() = (F.:W1).edgeSeq() by Def37;
    (F.:W1).vertices() = rng (F.:W1).vertexSeq() by GLIB_001:def 16;
    hence (F.:W1).vertices() c= rng F_V by A1, RELAT_1:26;
    (F.:W1).edges() = rng (F.:W1).edgeSeq() by GLIB_001:def 17;
    hence (F.:W1).edges() c= rng F_E by A1, RELAT_1:26;
    thus thesis;
  end;
end;

definition
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  redefine func F.:W1 -> F-valued Walk of G2;
  correctness;
end;

definition
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  let W2 be F-valued Walk of G2;
  func F"W2 -> F-defined Walk of G1 equals
  F".:W2;
  coherence
  proof
    F".:W2 is (F")"-defined;
    then F".:W2 is F-defined by Th70;
    hence thesis;
  end;
end;

Lm5:
  for G1, G2 being _Graph
  for F being non empty one-to-one PGraphMapping of G1, G2
  for W2 be F-valued Walk of G2 holds
    F_V * (F"W2).vertexSeq() = W2.vertexSeq() &
    F_E * (F"W2).edgeSeq() = W2.edgeSeq()
proof
  let G1, G2 be _Graph;
  let F be non empty one-to-one PGraphMapping of G1, G2;
  let W2 be F-valued Walk of G2;
  W2.vertices() c= rng F_V by Def36;
  then A1: rng W2.vertexSeq() c= rng F_V by GLIB_001:def 16;
  (F"W2).vertexSeq() = F_V" * W2.vertexSeq() by Def37;
  hence F_V * (F"W2).vertexSeq() = (F_V * F_V") * W2.vertexSeq() by RELAT_1:36
    .= (id rng F_V) * W2.vertexSeq() by FUNCT_1:39
    .= W2.vertexSeq() by A1, RELAT_1:53;
  W2.edges() c= rng F_E by Def36;
  then A2: rng W2.edgeSeq() c= rng F_E by GLIB_001:def 17;
  (F"W2).edgeSeq() = F_E" * W2.edgeSeq() by Def37;
  hence F_E * (F"W2).edgeSeq() = (F_E * F_E") * W2.edgeSeq() by RELAT_1:36
    .= (id rng F_E) * W2.edgeSeq() by FUNCT_1:39
    .= W2.edgeSeq() by A2, RELAT_1:53;
end;

definition
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  let W2 be F-valued Walk of G2;
  redefine func F"W2 means
  F_V * it.vertexSeq() = W2.vertexSeq() & F_E * it.edgeSeq() = W2.edgeSeq();
  compatibility
  proof
    let W1 be F-defined Walk of G1;
    thus W1 = F"W2 implies
      F_V * W1.vertexSeq() = W2.vertexSeq() &
      F_E * W1.edgeSeq() = W2.edgeSeq() by Lm5;
    assume that
      A1: F_V * W1.vertexSeq() = W2.vertexSeq() and
      A2: F_E * W1.edgeSeq() = W2.edgeSeq();
    rng (W1.vertexSeq()) = W1.vertices() & rng (W1.edgeSeq()) = W1.edges()
      by GLIB_001:def 16, GLIB_001:def 17;
    then A3: rng (W1.vertexSeq()) c= dom F_V &
      rng (W1.edgeSeq()) c= dom F_E by Def35;
    A4: F"_V * W2.vertexSeq() = (F_V" * F_V) * W1.vertexSeq() by A1, RELAT_1:36
      .= (id dom F_V) * W1.vertexSeq() by FUNCT_1:39
      .= W1.vertexSeq() by A3, RELAT_1:53;
    F"_E * W2.edgeSeq() = (F_E" * F_E) * W1.edgeSeq() by A2, RELAT_1:36
      .= (id dom F_E) * W1.edgeSeq() by FUNCT_1:39
      .= W1.edgeSeq() by A3, RELAT_1:53;
    hence W1 = F"W2 by A4, Def37;
  end;
end;

theorem Th123:
  for G1, G2 being _Graph
  for F being non empty one-to-one PGraphMapping of G1, G2
  for W1 being F-defined Walk of G1 holds F"(F.:W1) = W1
proof
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  W1.vertices() c= dom F_V by Def35;
  then A1: rng W1.vertexSeq() c= dom F_V by GLIB_001:def 16;
  A2: (F"(F.:W1)).vertexSeq() = F"_V * ((F.:W1).vertexSeq()) by Def37
    .= F_V" * (F_V * W1.vertexSeq()) by Def37
    .= (F_V" * F_V) * W1.vertexSeq() by RELAT_1:36
    .= (id dom F_V) * W1.vertexSeq() by FUNCT_1:39
    .= W1.vertexSeq() by A1, RELAT_1:53;
  W1.edges() c= dom F_E by Def35;
  then A3: rng W1.edgeSeq() c= dom F_E by GLIB_001:def 17;
  (F"(F.:W1)).edgeSeq() = F"_E * ((F.:W1).edgeSeq()) by Def37
    .= F_E" * (F_E * W1.edgeSeq()) by Def37
    .= (F_E" * F_E) * W1.edgeSeq() by RELAT_1:36
    .= (id dom F_E) * W1.edgeSeq() by FUNCT_1:39
    .= W1.edgeSeq() by A3, RELAT_1:53;
  hence thesis by A2, GLIB_009:26;
end;

theorem
  for G1, G2 being _Graph
  for F being non empty one-to-one PGraphMapping of G1, G2
  for W2 being F-valued Walk of G2 holds F.:(F"W2) = W2
proof
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  let W2 be F-valued Walk of G2;
  W2.vertices() c= rng F_V by Def36;
  then A1: rng W2.vertexSeq() c= rng F_V by GLIB_001:def 16;
  A2: (F.:(F"W2)).vertexSeq() = F_V * (F".:W2).vertexSeq() by Def37
    .= F_V * (F"_V * W2.vertexSeq()) by Def37
    .= (F_V * F_V") * W2.vertexSeq() by RELAT_1:36
    .= (id rng F_V) * W2.vertexSeq() by FUNCT_1:39
    .= W2.vertexSeq() by A1, RELAT_1:53;
  W2.edges() c= rng F_E by Def36;
  then A3: rng W2.edgeSeq() c= rng F_E by GLIB_001:def 17;
  (F.:(F"W2)).edgeSeq() = F_E * (F".:W2).edgeSeq() by Def37
    .= F_E * (F"_E * W2.edgeSeq()) by Def37
    .= (F_E * F_E") * W2.edgeSeq() by RELAT_1:36
    .= (id rng F_E) * W2.edgeSeq() by FUNCT_1:39
    .= W2.edgeSeq() by A3, RELAT_1:53;
  hence thesis by A2, GLIB_009:26;
end;

theorem Th125:
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1
  holds W1.length() = (F.:W1).length() & len W1 = len (F.:W1)
proof
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  W1.edges() = rng W1.edgeSeq() by GLIB_001:def 17;
  then A1: rng W1.edgeSeq() c= dom F_E by Def35;
  then reconsider p = F_E * W1.edgeSeq() as FinSequence by FINSEQ_1:16;
  thus A2: W1.length() = len W1.edgeSeq() by GLIB_001:def 18
    .= len p by A1, FINSEQ_2:29
    .= len (F.:W1).edgeSeq() by Def37
    .= (F.:W1).length() by GLIB_001:def 18;
  thus len W1 = 2*len W1.edgeSeq() + 1 by GLIB_001:def 15
    .= 2*W1.length() + 1 by GLIB_001:def 18
    .= 2*len (F.:W1).edgeSeq() + 1 by A2, GLIB_001:def 18
    .= len (F.:W1) by GLIB_001:def 15;
end;

theorem
  for G1, G2 being _Graph,
    F being non empty one-to-one PGraphMapping of G1, G2,
    W2 being F-valued Walk of G2
  holds W2.length() = (F"W2).length() & len W2 = len (F"W2) by Th125;

theorem Th127:
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1
  holds
    F_V.(W1.first()) = (F.:W1).first() & F_V.(W1.last()) = (F.:W1).last()
proof
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  set n = len W1.vertexSeq();
  1 <= n by GLIB_001:67;
  then A1: 1 in dom W1.vertexSeq() & n in dom W1.vertexSeq() by FINSEQ_3:25;
  W1.vertices() = rng W1.vertexSeq() by GLIB_001:def 16;
  then A2: rng W1.vertexSeq() c= dom F_V by Def35;
  then reconsider p = F_V * W1.vertexSeq() as FinSequence by FINSEQ_1:16;
  A3: n = len p by A2, FINSEQ_2:29
    .= len (F.:W1).vertexSeq() by Def37;
  thus F_V.(W1.first()) = F_V.(W1.vertexSeq().1) by GLIB_001:71
    .= (F_V * W1.vertexSeq()).1 by A1, FUNCT_1:13
    .= (F.:W1).vertexSeq().1 by Def37
    .= (F.:W1).first() by GLIB_001:71;
  thus F_V.(W1.last()) = F_V.(W1.vertexSeq().n) by GLIB_001:71
    .= (F_V * W1.vertexSeq()).n by A1, FUNCT_1:13
    .= (F.:W1).vertexSeq().n by Def37
    .= (F.:W1).last() by A3, GLIB_001:71;
end;

theorem
  for G1, G2 being _Graph,
    F being non empty one-to-one PGraphMapping of G1, G2,
    W2 being F-valued Walk of G2
  holds
    F_V".(W2.first()) = (F"W2).first() & F_V".(W2.last()) = (F"W2).last()
  by Th127;

theorem Th129:
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1, n being odd Element of NAT
  st n <= len W1 holds F_V.(W1.n) = (F.:W1).n
proof
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1, n be odd Element of NAT;
  assume A1: n <= len W1;
  then A2: n <= len (F.:W1) by Th125;
  A3: 1 <= (n+1) div 2 & (n+1) div 2 <= len W1.vertexSeq() by A1, GLIB_001:68;
  A4: (n+1) div 2 in dom W1.vertexSeq() by A3, FINSEQ_3:25;
  W1.n = W1.vertexAt(n) by A1, GLIB_001:def 8
    .= W1.vertexSeq().((n+1) div 2) by A1, GLIB_001:72;
  hence F_V.(W1.n) = (F_V * W1.vertexSeq()).((n+1) div 2) by A4, FUNCT_1:13
    .= ((F.:W1).vertexSeq()).((n+1) div 2) by Def37
    .= (F.:W1).vertexAt(n) by A2, GLIB_001:72
    .= (F.:W1).n by A2, GLIB_001:def 8;
end;

theorem
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1, n being even Element of NAT
  st 1 <= n & n <= len W1 holds F_E.(W1.n) = (F.:W1).n
proof
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1, n be even Element of NAT;
  assume A1: 1 <= n & n <= len W1;
  then A2: n <= len (F.:W1) by Th125;
  A3: n div 2 in dom W1.edgeSeq() & W1.n = W1.edgeSeq().(n div 2)
    by A1, GLIB_001:77;
  thus F_E.(W1.n) = (F_E * W1.edgeSeq()).(n div 2) by A3, FUNCT_1:13
    .= ((F.:W1).edgeSeq()).(n div 2) by Def37
    .= (F.:W1).n by A1, A2, GLIB_001:77;
end;

theorem Th131:
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1, v, w being object
  holds W1 is_Walk_from v,w implies v in dom F_V & w in dom F_V
proof
  let G1, G2 be _Graph;
  let F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1, v, w be object;
  assume W1 is_Walk_from v,w;
  then W1.first() = v & W1.last() = w by GLIB_001:def 23;
  then v in W1.vertices() & w in W1.vertices() by GLIB_001:88;
  hence v in dom F_V & w in dom F_V by Def35, TARSKI:def 3;
end;

theorem Th132:
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1, v, w being object
  holds W1 is_Walk_from v,w implies F.:W1 is_Walk_from F_V.v, F_V.w
proof
  let G1, G2 be _Graph;
  let F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1, v, w be object;
  assume W1 is_Walk_from v,w;
  then W1.first() = v & W1.last() = w by GLIB_001:def 23;
  then W1.1 = v & W1.len W1 = w by GLIB_001:def 6, GLIB_001:def 7;
  then F_V.v = (F.:W1).1 & F_V.w = (F.:W1).len W1 by Th129
, ABIAN:12,POLYFORM:4;
  then F_V.v = (F.:W1).first() & F_V.w = (F.:W1).len (F.:W1)
    by GLIB_001:def 6, Th125;
  then F_V.v = (F.:W1).first() & F_V.w = (F.:W1).last() by GLIB_001:def 7;
  hence F.:W1 is_Walk_from F_V.v, F_V.w by GLIB_001:def 23;
end;

theorem
  for G1, G2 being _Graph,
    F being non empty one-to-one PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1, v, w being object
  holds W1 is_Walk_from v,w iff v in dom F_V & w in dom F_V
    & F.:W1 is_Walk_from F_V.v, F_V.w
proof
  let G1, G2 be _Graph;
  let F be non empty one-to-one PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1, v, w be object;
  thus W1 is_Walk_from v,w implies v in dom F_V & w in dom F_V &
    F.:W1 is_Walk_from F_V.v, F_V.w by Th131, Th132;
  assume that
    A1: v in dom F_V & w in dom F_V and
    A2: F.:W1 is_Walk_from F_V.v, F_V.w;
  F"(F.:W1) is_Walk_from F"_V.(F_V.v), F"_V.(F_V.w) by A2, Th132;
  then W1 is_Walk_from F_V".(F_V.v), F_V".(F_V.w) by Th123;
  then W1 is_Walk_from v, F_V".(F_V.w) by A1, FUNCT_1:34;
  hence thesis by A1, FUNCT_1:34;
end;

theorem
  for G1, G2 being _Graph, F being non empty one-to-one PGraphMapping of G1, G2
  for W1 being F-defined Walk of G1 st F_V.(W1.first()) = F_V.(W1.last())
  holds W1.first() = W1.last()
proof
  let G1, G2 be _Graph, F be non empty one-to-one PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  A1: F is semi-continuous;
  assume A2: F_V.(W1.first()) = F_V.(W1.last());
  per cases;
  suppose A3: len W1 >= 3;
    then 1 < len W1 by XXREAL_0:2;
    then A4: W1.(1+1) Joins W1.1, W1.(1+2), G1 by POLYFORM:4, GLIB_001:def 3;
    A5: W1.1 in W1.vertices() & W1.3 in W1.vertices()
      & W1.last() in W1.vertices()
      by A3, XXREAL_0:2, GLIB_001:87, GLIB_001:88, POLYFORM:4, POLYFORM:6;
    1 <= 2 & 2 <= len W1 by A3, XXREAL_0:2;
    then W1.2 in W1.edges() by POLYFORM:5, GLIB_001:99;
    then A6: W1.1 in dom F_V & W1.2 in dom F_E & W1.3 in dom F_V
      & W1.last() in dom F_V by A5, Def35, TARSKI:def 3;
    F_E.(W1.2) Joins F_V.(W1.1), F_V.(W1.3), G2 by A6, A4, Th4;
    then F_E.(W1.2) Joins F_V.(W1.last()), F_V.(W1.3), G2
      by A2, GLIB_001:def 6;
    then W1.2 Joins W1.last(), W1.3, G1 by A1, A6;
    then (W1.1 = W1.last() & W1.3 = W1.3) or (W1.1 = W1.3 & W1.3 = W1.last())
      by A4, GLIB_000:15;
    hence thesis by GLIB_001:def 6;
  end;
  suppose not (len W1 >= 3);
    hence thesis by GLIB_001:125, GLIB_001:127;
  end;
end;

theorem
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2
  for W1 being F-defined Walk of G1
  holds (F.:W1).vertices() = F_V.:W1.vertices()
proof
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  A1: (F.:W1).vertices() = rng((F.:W1).vertexSeq()) by GLIB_001:def 16
    .= rng(F_V * W1.vertexSeq()) by Def37;
  for y being object holds y in rng(F_V * W1.vertexSeq())
    iff y in F_V.:W1.vertices()
  proof
    let y be object;
    hereby
      assume y in rng(F_V * W1.vertexSeq());
      then consider x being object such that
        A2: x in dom(F_V * W1.vertexSeq()) & (F_V * W1.vertexSeq()).x = y
        by FUNCT_1:def 3;
      set v = W1.vertexSeq().x;
      x in dom W1.vertexSeq() by A2, FUNCT_1:11;
      then v in rng W1.vertexSeq() by FUNCT_1:3;
      then A3: v in W1.vertices() by GLIB_001:def 16;
      A4: v in dom F_V by A2, FUNCT_1:11;
      F_V.v = y by A2, FUNCT_1:12;
      hence y in F_V.:W1.vertices() by A3, A4, FUNCT_1:def 6;
    end;
    assume y in F_V.:W1.vertices();
    then consider v being object such that
      A5: v in dom F_V & v in W1.vertices() & F_V.v = y by FUNCT_1:def 6;
    v in rng W1.vertexSeq() by A5, GLIB_001:def 16;
    then consider x being object such that
      A6: x in dom W1.vertexSeq() & W1.vertexSeq().x = v by FUNCT_1:def 3;
    A7: (F_V * W1.vertexSeq()).x = y by A5, A6, FUNCT_1:13;
    x in dom(F_V * W1.vertexSeq()) by A5, A6, FUNCT_1:11;
    hence y in rng(F_V * W1.vertexSeq()) by A7, FUNCT_1:3;
  end;
  hence thesis by A1, TARSKI:2;
end;

theorem Th136:
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2
  for W1 being F-defined Walk of G1
  holds (F.:W1).edges() = F_E.:W1.edges()
proof
  let G1, G2 be _Graph, F be non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  A1: (F.:W1).edges() = rng((F.:W1).edgeSeq()) by GLIB_001:def 17
    .= rng(F_E * W1.edgeSeq()) by Def37;
  for y being object holds y in rng(F_E * W1.edgeSeq())
    iff y in F_E.:W1.edges()
  proof
    let y be object;
    hereby
      assume y in rng(F_E * W1.edgeSeq());
      then consider x being object such that
        A2: x in dom(F_E * W1.edgeSeq()) & (F_E * W1.edgeSeq()).x = y
        by FUNCT_1:def 3;
      set v = W1.edgeSeq().x;
      x in dom W1.edgeSeq() by A2, FUNCT_1:11;
      then v in rng W1.edgeSeq() by FUNCT_1:3;
      then A3: v in W1.edges() by GLIB_001:def 17;
      A4: v in dom F_E by A2, FUNCT_1:11;
      F_E.v = y by A2, FUNCT_1:12;
      hence y in F_E.:W1.edges() by A3, A4, FUNCT_1:def 6;
    end;
    assume y in F_E.:W1.edges();
    then consider v being object such that
      A5: v in dom F_E & v in W1.edges() & F_E.v = y by FUNCT_1:def 6;
    v in rng W1.edgeSeq() by A5, GLIB_001:def 17;
    then consider x being object such that
      A6: x in dom W1.edgeSeq() & W1.edgeSeq().x = v by FUNCT_1:def 3;
    A7: (F_E * W1.edgeSeq()).x = y by A5, A6, FUNCT_1:13;
    x in dom(F_E * W1.edgeSeq()) by A5, A6, FUNCT_1:11;
    hence y in rng(F_E * W1.edgeSeq()) by A7, FUNCT_1:3;
  end;
  hence thesis by A1, TARSKI:2;
end;

theorem Th137:
  for G1, G2 being _Graph, F being non empty PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1
  holds
    (W1 is trivial implies F.:W1 is trivial) &
    (W1 is closed implies F.:W1 is closed) &
    (F.:W1 is Trail-like implies W1 is Trail-like) &
    (F.:W1 is Path-like implies W1 is Path-like)
proof
  let G1, G2 be _Graph, F being non empty PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  hereby
    assume W1 is trivial;
    then W1.length() = 0 by GLIB_001:def 26;
    then (F.:W1).length() = 0 by Th125;
    hence F.:W1 is trivial by GLIB_001:def 26;
  end;
  hereby
    assume A1: W1 is closed;
    (F.:W1).first() = F_V.(W1.first()) by Th127
      .= F_V.(W1.last()) by A1, GLIB_001:def 24
      .= (F.:W1).last() by Th127;
    hence F.:W1 is closed by GLIB_001:def 24;
  end;
  thus A2: F.:W1 is Trail-like implies W1 is Trail-like
  proof
    assume F.:W1 is Trail-like;
    then (F.:W1).edgeSeq() is one-to-one by GLIB_001:def 27;
    then A3: F_E * W1.edgeSeq() is one-to-one by Def37;
    W1.edges() = rng W1.edgeSeq() by GLIB_001:def 17;
    then rng W1.edgeSeq() c= dom F_E by Def35;
    then W1.edgeSeq() is one-to-one by A3, FUNCT_1:25;
    hence W1 is Trail-like by GLIB_001:def 27;
  end;
  assume A4: F.:W1 is Path-like;
  for m, n being odd Element of NAT st m < n & n <= len W1
    holds W1.m = W1.n implies m = 1 & n = len W1
  proof
    let m, n be odd Element of NAT;
    assume A5: m < n & n <= len W1;
    A6: len W1 = 2*len W1.edgeSeq() + 1 by GLIB_001:def 15
      .= 2*W1.length() + 1 by GLIB_001:def 18
      .= 2*(F.:W1).length() + 1 by Th125
      .= 2*len (F.:W1).edgeSeq() +1 by GLIB_001:def 18
      .= len (F.:W1) by GLIB_001:def 15;
    assume A7: W1.n = W1.m;
    (F.:W1).n = F_V.(W1.n) by A5, Th129
      .= (F.:W1).m by A5, A7, Th129, XXREAL_0:2;
    then m = 1 & n = len (F.:W1) by A4, A5, A6, GLIB_001:def 28;
    hence thesis by A6;
  end;
  hence W1 is Path-like by A2, A4, GLIB_001:def 28;
end;

theorem Th138:
  for G1, G2 being _Graph,
    F being non empty one-to-one PGraphMapping of G1, G2,
    W1 being F-defined Walk of G1
  holds
    (W1 is trivial iff F.:W1 is trivial) &
    (W1 is closed iff F.:W1 is closed) &
    (W1 is Trail-like iff F.:W1 is Trail-like) &
    (W1 is Path-like iff F.:W1 is Path-like) &
    (W1 is Circuit-like iff F.:W1 is Circuit-like) &
    (W1 is Cycle-like iff F.:W1 is Cycle-like)
proof
  let G1, G2 be _Graph;
  let F be non empty one-to-one PGraphMapping of G1, G2;
  let W1 be F-defined Walk of G1;
  W1 = F"(F.:W1) by Th123;
  hence A1:
    (W1 is trivial iff F.:W1 is trivial) &
    (W1 is closed iff F.:W1 is closed) &
    (W1 is Trail-like iff F.:W1 is Trail-like) &
    (W1 is Path-like iff F.:W1 is Path-like) by Th137;
  thus W1 is Circuit-like iff F.:W1 is Circuit-like by A1;
  thus W1 is Cycle-like iff F.:W1 is Cycle-like by A1;
end;

:: properties derived using walks

theorem Th139:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is strong_SG-embedding
  holds G2 is acyclic implies G1 is acyclic
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is strong_SG-embedding;
  then reconsider F as non empty one-to-one PGraphMapping of G1, G2;
  assume A2: G2 is acyclic;
  not ex W1 being Walk of G1 st W1 is Cycle-like
  proof
    given W1 being Walk of G1 such that
      A3: W1 is Cycle-like;
    reconsider W1 as F-defined Walk of G1 by A1, Th121;
    F.:W1 is Cycle-like by A3, Th138;
    hence contradiction by A2, GLIB_002:def 2;
  end;
  hence G1 is acyclic by GLIB_002:def 2;
end;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2 st F is isomorphism
  holds (G1 is acyclic iff G2 is acyclic) &
    (G1 is chordal iff G2 is chordal) &
    (G1 is connected iff G2 is connected)
proof
  let G1, G2 be _Graph;
  let F be PGraphMapping of G1, G2;
  assume A1: F is isomorphism;
  then reconsider F as non empty one-to-one PGraphMapping of G1, G2;
  A2: F" is isomorphism semi-continuous by A1, Th75;
  hence G1 is acyclic iff G2 is acyclic by A1, Th139;
  A3: F is semi-continuous;
  hereby
    assume A4: G1 is chordal;
    now
      let P be Walk of G2;
      assume A5: P.length() > 3 & P is Cycle-like;
      now
        reconsider C = P as F-valued Walk of G2 by A1, Th122;
        A6: (F"C).length() > 3 by A5, Th125;
        F"C is Cycle-like by A5, Th138;
        then F"C is chordal by A4, A6, CHORD:def 11;
        then consider m,n being odd Nat such that
          A7: m+2 < n & n <= len(F"C) & (F"C).m <> (F"C).n and
          A8: ex e being object st e Joins (F"C).m,(F"C).n,G1 and
          A9: for f being object st f in (F"C).edges()
            holds not f Joins (F"C).m,(F"C).n,G1 by CHORD:def 10;
        take m,n;
        thus A10: m+2 < n & n <= len P by A7, Th125;
        A11: n is odd Element of NAT by ORDINAL1:def 12;
        then A12: (F"C).n = F"_V.(C.n) by A10, Th129;
        m+2-2 <= n-0 by A10, XREAL_1:13;
        then A13: m <= len P by A10, XXREAL_0:2;
        A14: m is odd Element of NAT by ORDINAL1:def 12;
        then A15: (F"C).m = F"_V.(C.m) by A13, Th129;
        hence P.m <> P.n by A7, A12;
        P.m in the_Vertices_of G2 & P.n in the_Vertices_of G2
          by A10, A11, A13, A14, GLIB_001:7;
        then A16: P.m in dom(F"_V) & P.n in dom(F"_V) by A2, Def11;
        thus ex e being object st e Joins P.m,P.n,G2
        proof
          consider e0 being object such that
            A17: e0 Joins (F"C).m,(F"C).n,G1 by A8;
          e0 in the_Edges_of G1 by A17, GLIB_000:def 13;
          then e0 in rng(F"_E) by A2, Def12;
          then consider e being object such that
            A18: e in dom(F"_E) & F"_E.e = e0 by FUNCT_1:def 3;
          take e;
          F"_E.e Joins F"_V.(C.m),F"_V.(C.n),G1 by A12, A15, A17, A18;
          hence e Joins P.m,P.n,G2 by A2, A16, A18;
        end;
        let f be object;
        assume A19: f in P.edges();
        then f in the_Edges_of G2;
        then A20: f in dom(F"_E) by A2, Def11;
        then F"_E.f in F"_E.:P.edges() by A19, FUNCT_1:def 6;
        then A21: F"_E.f in (F"C).edges() by Th136;
        thus not f Joins P.m,P.n,G2 by A9, A12, A15, A16, A20, A21, Th4;
      end;
      hence P is chordal by CHORD:def 10;
    end;
    hence G2 is chordal by CHORD:def 11;
  end;
  hereby
    assume A22: G2 is chordal;
    now
      let P be Walk of G1;
      assume A23: P.length() > 3 & P is Cycle-like;
      now
        reconsider C = P as F-defined Walk of G1 by A1, Th121;
        A24: (F.:C).length() > 3 by A23, Th125;
        F.:C is Cycle-like by A23, Th138;
        then F.:C is chordal by A22, A24, CHORD:def 11;
        then consider m,n being odd Nat such that
          A25: m+2 < n & n <= len(F.:C) & (F.:C).m <> (F.:C).n and
          A26: ex e being object st e Joins (F.:C).m,(F.:C).n,G2 and
          A27: for f being object st f in (F.:C).edges()
            holds not f Joins (F.:C).m,(F.:C).n,G2 by CHORD:def 10;
        take m,n;
        thus A28: m+2 < n & n <= len P by A25, Th125;
        A29: n is odd Element of NAT by ORDINAL1:def 12;
        then A30: (F.:C).n = F_V.(C.n) by A28, Th129;
        m+2-2 <= n-0 by A28, XREAL_1:13;
        then A31: m <= len P by A28, XXREAL_0:2;
        A32: m is odd Element of NAT by ORDINAL1:def 12;
        then A33: (F.:C).m = F_V.(C.m) by A31, Th129;
        hence P.m <> P.n by A25, A30;
        P.m in the_Vertices_of G1 & P.n in the_Vertices_of G1
          by A28, A29, A31, A32, GLIB_001:7;
        then A34: P.m in dom F_V & P.n in dom F_V by A1, Def11;
        thus ex e being object st e Joins P.m,P.n,G1
        proof
          consider e0 being object such that
            A35: e0 Joins (F.:C).m,(F.:C).n,G2 by A26;
          e0 in the_Edges_of G2 by A35, GLIB_000:def 13;
          then e0 in rng F_E by A1, Def12;
          then consider e being object such that
            A36: e in dom F_E & F_E.e = e0 by FUNCT_1:def 3;
          take e;
          F_E.e Joins F_V.(C.m),F_V.(C.n),G2 by A30, A33, A35, A36;
          hence e Joins P.m,P.n,G1 by A3, A34, A36;
        end;
        let f be object;
        assume A37: f in P.edges();
        then f in the_Edges_of G1;
        then A38: f in dom F_E by A1, Def11;
        then F_E.f in F_E.:P.edges() by A37, FUNCT_1:def 6;
        then A39: F_E.f in (F.:C).edges() by Th136;
        thus not f Joins P.m,P.n,G1 by A27, A30, A33, A34, A38, A39, Th4;
      end;
      hence P is chordal by CHORD:def 10;
    end;
    hence G1 is chordal by CHORD:def 11;
  end;
  hereby
    assume A40: G1 is connected;
    for u,v being Vertex of G2 ex W2 being Walk of G2 st W2 is_Walk_from u,v
    proof
      let u2,v2 be Vertex of G2;
      reconsider u1 = F"_V.u2, v1 = F"_V.v2 as Vertex of G1 by A1, Th79;
      consider W1 being Walk of G1 such that
        A41: W1 is_Walk_from u1,v1 by A40, GLIB_002:def 1;
      reconsider W1 as F-defined Walk of G1 by A1, Th121;
      take F.:W1;
      F" is total by A2;
      then u2 in dom (F_V") & v2 in dom (F_V");
      then A42: u2 in rng F_V & v2 in rng F_V by FUNCT_1:33;
      F.:W1 is_Walk_from F_V.(F_V".u2), F_V.v1 by A41, Th132;
      then F.:W1 is_Walk_from u2, F_V.(F_V".v2) by A42, FUNCT_1:35;
      hence thesis by A42, FUNCT_1:35;
    end;
    hence G2 is connected by GLIB_002:def 1;
  end;
  assume A43: G2 is connected;
  for u,v being Vertex of G1 ex W1 being Walk of G1 st W1 is_Walk_from u,v
  proof
    let u1,v1 be Vertex of G1;
    reconsider u2 = F_V.u1, v2 = F_V.v1 as Vertex of G2 by A1, Th34;
    consider W2 being Walk of G2 such that
      A44: W2 is_Walk_from u2,v2 by A43, GLIB_002:def 1;
    reconsider W2 as F-valued Walk of G2 by A1, Th122;
    take F"W2;
    A45: F is total by A1;
    F"W2 is_Walk_from F_V".(F_V.u1), F"_V.v2 by A44, Th132;
    then F"W2 is_Walk_from u1, F_V".(F_V.v1) by A45, FUNCT_1:34;
    hence thesis by A45, FUNCT_1:34;
  end;
  hence G1 is connected by GLIB_002:def 1;
end;

begin :: Graph Mappings and Graph Modes

theorem Th141:
  for G1, G2 being _Graph, E1, E2 being set
  for G3 being reverseEdgeDirections of G1, E1
  for G4 being reverseEdgeDirections of G2, E2
  for F0 being PGraphMapping of G1, G2
  ex F being PGraphMapping of G3, G4 st F = F0 &
    (F0 is non empty  implies F is non empty) &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is semi-continuous implies F is semi-continuous) &
    (F0 is continuous implies F is continuous)
proof
  let G1, G2 be _Graph, E1, E2 be set;
  let G3 be reverseEdgeDirections of G1, E1;
  let G4 be reverseEdgeDirections of G2, E2;
  let F0 be PGraphMapping of G1, G2;
  reconsider F = F0 as PGraphMapping of G3, G4 by Th10;
  take F;
  thus F = F0;
  thus F0 is non empty implies F is non empty;
  thus F0 is total implies F is total by GLIB_007:4;
  thus F0 is onto implies F is onto by GLIB_007:4;
  thus F0 is one-to-one implies F is one-to-one;
  thus F0 is semi-continuous implies F is semi-continuous
  proof
    assume A1: F0 is semi-continuous;
    now
      let e,v,w be object;
      assume A2: e in dom F_E & v in dom F_V & w in dom F_V;
      assume F_E.e Joins F_V.v, F_V.w, G4;
      then e Joins v,w,G1 by A1, A2, GLIB_007:9;
      hence e Joins v,w,G3 by GLIB_007:9;
    end;
    hence thesis;
  end;
  thus F0 is continuous implies F is continuous
  proof
    assume A3: F0 is continuous;
    now
      let e9,v,w be object;
      assume v in dom F_V & w in dom F_V & e9 Joins F_V.v, F_V.w, G4;
      then consider e being object such that
        A4: e Joins v,w,G1 & e in dom F0_E & F0_E.e = e9 by A3, GLIB_007:9;
      take e;
      thus e Joins v,w,G3 by A4, GLIB_007:9;
      thus e in dom F_E & F_E.e = e9 by A4;
    end;
    hence thesis;
  end;
end;

theorem Th142:
  for G1, G2 being _Graph, E1, E2 being set
  for G3 being reverseEdgeDirections of G1, E1
  for G4 being reverseEdgeDirections of G2, E2
  for F0 being PGraphMapping of G1, G2
  ex F being PGraphMapping of G3, G4 st F = F0 &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is strong_SG-embedding implies F is strong_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism)
proof
  let G1, G2 be _Graph, E1, E2 be set;
  let G3 be reverseEdgeDirections of G1, E1;
  let G4 be reverseEdgeDirections of G2, E2;
  let F0 be PGraphMapping of G1, G2;
  consider F being PGraphMapping of G3, G4 such that
    A1: F = F0 and
    F0 is non empty  implies F is non empty and
    A2: F0 is total implies F is total and
    A3: F0 is onto implies F is onto and
    A4: F0 is one-to-one implies F is one-to-one and
    F0 is semi-continuous implies F is semi-continuous and
    A5: F0 is continuous implies F is continuous by Th141;
  take F;
  thus F = F0 by A1;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A2, A4;
  thus F0 is strong_SG-embedding implies F is strong_SG-embedding
    by A2, A4, A5;
  thus F0 is isomorphism implies F is isomorphism by A2, A3, A4;
end;

theorem Th143:
  for G1 being _Graph, G2 being G1-isomorphic _Graph, E1, E2 being set
  for G3 being reverseEdgeDirections of G1, E1
  for G4 being reverseEdgeDirections of G2, E2
  holds G4 is G3-isomorphic
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph, E1, E2 be set;
  let G3 be reverseEdgeDirections of G1, E1;
  let G4 be reverseEdgeDirections of G2, E2;
  consider F0 being PGraphMapping of G1, G2 such that
    A1: F0 is isomorphism by Def23;
  consider F being PGraphMapping of G3, G4 such that
    F = F0 and
    F0 is weak_SG-embedding implies F is weak_SG-embedding and
    F0 is strong_SG-embedding implies F is strong_SG-embedding and
    A2: F0 is isomorphism implies F is isomorphism by Th142;
  thus thesis by A1, A2;
end;

theorem Th144:
  for G3, G4 being _Graph, V1, V2 being set
  for G1 being addVertices of G3,V1, G2 being addVertices of G4,V2
  for F0 being PGraphMapping of G3,G4, f being one-to-one Function
  st dom f = V1 \ the_Vertices_of G3 & rng f = V2 \ the_Vertices_of G4
  ex F being PGraphMapping of G1, G2 st F = [F0_V +* f, F0_E] &
    (F0 is non empty  implies F is non empty) &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is directed implies F is directed) &
    (F0 is semi-continuous implies F is semi-continuous) &
    (F0 is continuous implies F is continuous) &
    (F0 is semi-Dcontinuous implies F is semi-Dcontinuous) &
    (F0 is Dcontinuous implies F is Dcontinuous)
proof
  let G3, G4 be _Graph, V1, V2 be set;
  let G1 be addVertices of G3,V1, G2 be addVertices of G4,V2;
  let F0 be PGraphMapping of G3,G4, f be one-to-one Function;
  assume A1: dom f = V1 \ the_Vertices_of G3 & rng f = V2 \ the_Vertices_of G4;
  :: construct F
  set h = F0_V +* f;
  A2: dom h = dom F0_V \/ (V1 \ the_Vertices_of G3) by A1, FUNCT_4:def 1;
  dom h c= the_Vertices_of G3 \/ V1 by A2, XBOOLE_1:13;
  then A3: dom h c= the_Vertices_of G1 by GLIB_006:def 10;
  rng F0_V \/ rng f c= the_Vertices_of G4 \/ V2 by A1, XBOOLE_1:13;
  then A4: rng F0_V \/ rng f c= the_Vertices_of G2 by GLIB_006:def 10;
  rng h c= rng F0_V \/ rng f by FUNCT_4:17;
  then rng h c= the_Vertices_of G2 by A4, XBOOLE_1:1;
  then reconsider h as PartFunc of the_Vertices_of G1, the_Vertices_of G2
    by A3, RELSET_1:4;
  the_Edges_of G1 = the_Edges_of G3 & the_Edges_of G2 = the_Edges_of G4
    by GLIB_006:def 10;
  then reconsider g = F0_E as PartFunc of the_Edges_of G1, the_Edges_of G2;
  A5: dom f /\ the_Vertices_of G3 = {} by A1, XBOOLE_1:79, XBOOLE_0:def 7;
  dom F0_V /\ dom f c= dom f /\ the_Vertices_of G3 by XBOOLE_1:26;
  then A6: dom F0_V misses dom f by A5, XBOOLE_1:3, XBOOLE_0:def 7;
  A7: rng f /\ the_Vertices_of G4 = {} by A1, XBOOLE_1:79, XBOOLE_0:def 7;
  rng F0_V /\ rng f c= rng f /\ the_Vertices_of G4 by XBOOLE_1:26;
  then A8: rng F0_V misses rng f by A7, XBOOLE_1:3, XBOOLE_0:def 7;
  A9: dom h /\ the_Vertices_of G3
     = (dom F0_V \/ dom f) /\ the_Vertices_of G3 by FUNCT_4:def 1
    .= (dom F0_V /\ the_Vertices_of G3) \/ (dom f /\ the_Vertices_of G3)
      by XBOOLE_1:23
    .= dom F0_V by A5, XBOOLE_1:28;
  now
    hereby
      let e be object;
      assume A10: e in dom g;
      (the_Source_of G1).e = (the_Source_of G3).e &
        (the_Target_of G1).e = (the_Target_of G3).e by GLIB_006:def 10;
      then A11: (the_Source_of G1).e in dom F0_V &
        (the_Target_of G1).e in dom F0_V by A10, Th5;
      dom F0_V c= dom h by FUNCT_4:10;
      hence (the_Source_of G1).e in dom h &
        (the_Target_of G1).e in dom h by A11;
    end;
    let e,v,w be object;
    assume A12: e in dom g & v in dom h & w in dom h & e Joins v,w,G1;
    A13: e Joins v,w,G3 by A12, GLIB_009:41;
    then A14: v in the_Vertices_of G3 & w in the_Vertices_of G3 by GLIB_000:13;
    then v in dom F0_V & w in dom F0_V by A12, A9, XBOOLE_0:def 4;
    then F0_E.e Joins F0_V.v,F0_V.w,G4 by A12, A13, Th4;
    then A15: g.e Joins F0_V.v,F0_V.w,G2 by GLIB_009:41;
    not v in dom f & not w in dom f by A1, A14, XBOOLE_0:def 5;
    then h.v = F0_V.v & h.w = F0_V.w by FUNCT_4:11;
    hence g.e Joins h.v,h.w,G2 by A15;
  end;
  then reconsider F = [h,g] as PGraphMapping of G1, G2 by Th8;
  take F;
  thus F = [F0_V +* f, F0_E];
  :: show properties
  thus F0 is non empty implies F is non empty by FUNCT_4:10, XBOOLE_1:3;
  thus F0 is total implies F is total
  proof
    assume F0 is total;
    then A16: dom F0_V = the_Vertices_of G3 & dom F0_E = the_Edges_of G3;
    then dom h = the_Vertices_of G3 \/ (V1 \ the_Vertices_of G3)
        by A1, FUNCT_4:def 1
      .= the_Vertices_of G3 \/ V1 by XBOOLE_1:39
      .= the_Vertices_of G1 by GLIB_006:def 10;
    hence thesis by A16, GLIB_006:def 10;
  end;
  thus F0 is onto implies F is onto
  proof
    assume F0 is onto;
    then A17: rng F0_V = the_Vertices_of G4 & rng F0_E = the_Edges_of G4;
    rng h = rng F0_V \/ rng f by A6, NECKLACE:6
      .= the_Vertices_of G4 \/ V2 by A1, A17, XBOOLE_1:39
      .= the_Vertices_of G2 by GLIB_006:def 10;
    hence thesis by A17, GLIB_006:def 10;
  end;
  thus F0 is one-to-one implies F is one-to-one by A8, FUNCT_4:92;
  thus F0 is directed implies F is directed
  proof
    assume A18: F0 is directed;
    now
      let e,v,w be object;
      assume A19: e in dom g & v in dom h & w in dom h & e DJoins v,w,G1;
      A20: e DJoins v,w,G3 by A19, GLIB_009:41;
      then e Joins v,w,G3 by GLIB_000:16;
      then A21: v in the_Vertices_of G3 & w in the_Vertices_of G3
        by GLIB_000:13;
      then v in dom F0_V & w in dom F0_V by A19, A9, XBOOLE_0:def 4;
      then F0_E.e DJoins F0_V.v,F0_V.w,G4 by A18, A19, A20;
      then A22: g.e DJoins F0_V.v,F0_V.w,G2 by GLIB_009:41;
      not v in dom f & not w in dom f by A1, A21, XBOOLE_0:def 5;
      then h.v = F0_V.v & h.w = F0_V.w by FUNCT_4:11;
      hence g.e DJoins h.v,h.w,G2 by A22;
    end;
    hence thesis;
  end;
  thus F0 is semi-continuous implies F is semi-continuous
  proof
    assume A23: F0 is semi-continuous;
    now
      let e,v,w be object;
      assume A24: e in dom g & v in dom h & w in dom h & g.e Joins h.v,h.w,G2;
      then A25: F0_E.e Joins h.v,h.w,G4 by GLIB_009:41;
      then h.v in the_Vertices_of G4 & h.w in the_Vertices_of G4
        by GLIB_000:13;
      then A26: not h.v in rng f & not h.w in rng f by A7, XBOOLE_0:def 4;
      A27: not v in dom f & not w in dom f
      proof
        assume v in dom f or w in dom f;
        then per cases;
        suppose v in dom f;
          then f.v in rng f & h.v = f.v by FUNCT_1:3, FUNCT_4:13;
          hence contradiction by A26;
        end;
        suppose w in dom f;
          then f.w in rng f & h.w = f.w by FUNCT_1:3, FUNCT_4:13;
          hence contradiction by A26;
        end;
      end;
      v in dom F0_V \/ dom f & w in dom F0_V \/ dom f by A24, FUNCT_4:def 1;
      then A28: v in dom F0_V & w in dom F0_V by A27, XBOOLE_0:def 3;
      F0_V.v = h.v & F0_V.w = h.w by A27, FUNCT_4:11;
      then F0_E.e Joins F0_V.v,F0_V.w,G4 by A25;
      then A29: e Joins v,w,G3 by A23, A24, A28;
      v is set & w is set by TARSKI:1;
      hence e Joins v,w,G1 by A29, GLIB_009:41;
    end;
    hence thesis;
  end;
  thus F0 is continuous implies F is continuous
  proof
    assume A30: F0 is continuous;
    now
      let e9,v,w be object;
      assume A31: v in dom h & w in dom h & e9 Joins h.v,h.w,G2;
      then A32: e9 Joins h.v,h.w,G4 by GLIB_009:41;
      then h.v in the_Vertices_of G4 & h.w in the_Vertices_of G4
        by GLIB_000:13;
      then A33: not h.v in rng f & not h.w in rng f by A7, XBOOLE_0:def 4;
      A34: not v in dom f & not w in dom f
      proof
        assume v in dom f or w in dom f;
        then per cases;
        suppose v in dom f;
          then f.v in rng f & h.v = f.v by FUNCT_1:3, FUNCT_4:13;
          hence contradiction by A33;
        end;
        suppose w in dom f;
          then f.w in rng f & h.w = f.w by FUNCT_1:3, FUNCT_4:13;
          hence contradiction by A33;
        end;
      end;
      v in dom F0_V \/ dom f & w in dom F0_V \/ dom f by A31, FUNCT_4:def 1;
      then A35: v in dom F0_V & w in dom F0_V by A34, XBOOLE_0:def 3;
      F0_V.v = h.v & F0_V.w = h.w by A34, FUNCT_4:11;
      then consider e being object such that
        A36: e Joins v,w,G3 & e in dom F_E & F_E.e = e9 by A30, A32, A35;
      take e;
      v is set & w is set by TARSKI:1;
      hence e Joins v,w,G1 by A36, GLIB_009:41;
      thus e in dom g & g.e = e9 by A36;
    end;
    hence thesis;
  end;
  thus F0 is semi-Dcontinuous implies F is semi-Dcontinuous
  proof
    assume A37: F0 is semi-Dcontinuous;
    now
      let e,v,w be object;
      assume A38: e in dom g & v in dom h & w in dom h & g.e DJoins h.v,h.w,G2;
      then A39: F0_E.e DJoins h.v,h.w,G4 by GLIB_009:41;
      then F0_E.e Joins h.v,h.w,G4 by GLIB_000:16;
      then h.v in the_Vertices_of G4 & h.w in the_Vertices_of G4
        by GLIB_000:13;
      then A40: not h.v in rng f & not h.w in rng f by A7, XBOOLE_0:def 4;
      A41: not v in dom f & not w in dom f
      proof
        assume v in dom f or w in dom f;
        then per cases;
        suppose v in dom f;
          then f.v in rng f & h.v = f.v by FUNCT_1:3, FUNCT_4:13;
          hence contradiction by A40;
        end;
        suppose w in dom f;
          then f.w in rng f & h.w = f.w by FUNCT_1:3, FUNCT_4:13;
          hence contradiction by A40;
        end;
      end;
      v in dom F0_V \/ dom f & w in dom F0_V \/ dom f by A38, FUNCT_4:def 1;
      then A42: v in dom F0_V & w in dom F0_V by A41, XBOOLE_0:def 3;
      F0_V.v = h.v & F0_V.w = h.w by A41, FUNCT_4:11;
      then F0_E.e DJoins F0_V.v,F0_V.w,G4 by A39;
      then A43: e DJoins v,w,G3 by A37, A38, A42;
      v is set & w is set by TARSKI:1;
      hence e DJoins v,w,G1 by A43, GLIB_009:41;
    end;
    hence thesis;
  end;
  thus F0 is Dcontinuous implies F is Dcontinuous
  proof
    assume A44: F0 is Dcontinuous;
    now
      let e9,v,w be object;
      assume A45: v in dom h & w in dom h & e9 DJoins h.v,h.w,G2;
      then A46: e9 DJoins h.v,h.w,G4 by GLIB_009:41;
      then e9 Joins h.v,h.w,G4 by GLIB_000:16;
      then h.v in the_Vertices_of G4 & h.w in the_Vertices_of G4
        by GLIB_000:13;
      then A47: not h.v in rng f & not h.w in rng f by A7, XBOOLE_0:def 4;
      A48: not v in dom f & not w in dom f
      proof
        assume v in dom f or w in dom f;
        then per cases;
        suppose v in dom f;
          then f.v in rng f & h.v = f.v by FUNCT_1:3, FUNCT_4:13;
          hence contradiction by A47;
        end;
        suppose w in dom f;
          then f.w in rng f & h.w = f.w by FUNCT_1:3, FUNCT_4:13;
          hence contradiction by A47;
        end;
      end;
      v in dom F0_V \/ dom f & w in dom F0_V \/ dom f by A45, FUNCT_4:def 1;
      then A49: v in dom F0_V & w in dom F0_V by A48, XBOOLE_0:def 3;
      F0_V.v = h.v & F0_V.w = h.w by A48, FUNCT_4:11;
      then consider e being object such that
        A50: e DJoins v,w,G3 & e in dom F_E & F_E.e = e9 by A44, A46, A49;
      take e;
      v is set & w is set by TARSKI:1;
      hence e DJoins v,w,G1 by A50, GLIB_009:41;
      thus e in dom g & g.e = e9 by A50;
    end;
    hence thesis;
  end;
end;

theorem Th145:
  for G3, G4 being _Graph, V1, V2 being set
  for G1 being addVertices of G3,V1, G2 being addVertices of G4,V2
  for F0 being PGraphMapping of G3,G4, f being one-to-one Function
  st dom f = V1 \ the_Vertices_of G3 & rng f = V2 \ the_Vertices_of G4
  ex F being PGraphMapping of G1, G2 st F = [F0_V +* f, F0_E] &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is strong_SG-embedding implies F is strong_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism) &
    (F0 is Disomorphism implies F is Disomorphism)
proof
  let G3, G4 be _Graph, V1, V2 be set;
  let G1 be addVertices of G3,V1, G2 be addVertices of G4,V2;
  let F0 be PGraphMapping of G3,G4, f be one-to-one Function;
  assume dom f = V1 \ the_Vertices_of G3 & rng f = V2 \ the_Vertices_of G4;
  then consider F being PGraphMapping of G1, G2 such that
    A1: F = [F0_V +* f, F0_E] and
    F0 is non empty  implies F is non empty and
    A2: F0 is total implies F is total and
    A3: F0 is onto implies F is onto and
    A4: F0 is one-to-one implies F is one-to-one and
    A5: F0 is directed implies F is directed and
    F0 is semi-continuous implies F is semi-continuous and
    A6: F0 is continuous implies F is continuous and
    F0 is semi-Dcontinuous implies F is semi-Dcontinuous and
    F0 is Dcontinuous implies F is Dcontinuous by Th144;
  take F;
  thus F = [F0_V +* f, F0_E] by A1;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A2, A4;
  thus F0 is strong_SG-embedding implies F is strong_SG-embedding
    by A2, A4, A6;
  thus F0 is isomorphism implies F is isomorphism by A2, A3, A4;
  thus F0 is Disomorphism implies F is Disomorphism by A2, A3, A4, A5;
end;

theorem Th146:
  for G3 being _Graph, G4 being G3-isomorphic _Graph, V1, V2 being set
  for G1 being addVertices of G3,V1, G2 being addVertices of G4,V2
  st card(V1 \ the_Vertices_of G3) = card(V2 \ the_Vertices_of G4)
  holds G2 is G1-isomorphic
proof
  let G3 be _Graph, G4 be G3-isomorphic _Graph, V1, V2 be set;
  let G1 be addVertices of G3,V1, G2 be addVertices of G4,V2;
  assume card(V1 \ the_Vertices_of G3) = card(V2 \ the_Vertices_of G4);
  then consider f being Function such that
    A1: f is one-to-one & dom f = V1 \ the_Vertices_of G3 &
      rng f = V2 \ the_Vertices_of G4 by CARD_1:5, WELLORD2:def 4;
  reconsider f as one-to-one Function by A1;
  consider F0 be PGraphMapping of G3, G4 such that
    A2: F0 is isomorphism by Def23;
  consider F being PGraphMapping of G1, G2 such that
    F = [F0_V +* f, F0_E] and
    F0 is weak_SG-embedding implies F is weak_SG-embedding and
    F0 is strong_SG-embedding implies F is strong_SG-embedding and
    A3: F0 is isomorphism implies F is isomorphism and
    F0 is Disomorphism implies F is Disomorphism by A1, Th145;
  thus thesis by A2, A3;
end;

theorem Th147:
  for G3 being _Graph, G4 being G3-Disomorphic _Graph, V1, V2 being set
  for G1 being addVertices of G3, V1,G2 being addVertices of G4,V2
  st card(V1 \ the_Vertices_of G3) = card(V2 \ the_Vertices_of G4)
  holds G2 is G1-Disomorphic
proof
  let G3 be _Graph, G4 be G3-Disomorphic _Graph, V1, V2 be set;
  let G1 be addVertices of G3,V1, G2 be addVertices of G4,V2;
  assume card(V1 \ the_Vertices_of G3) = card(V2 \ the_Vertices_of G4);
  then consider f being Function such that
    A1: f is one-to-one & dom f = V1 \ the_Vertices_of G3 &
      rng f = V2 \ the_Vertices_of G4 by CARD_1:5, WELLORD2:def 4;
  reconsider f as one-to-one Function by A1;
  consider F0 be PGraphMapping of G3, G4 such that
    A2: F0 is Disomorphism by Def24;
  consider F being PGraphMapping of G1, G2 such that
    F = [F0_V +* f, F0_E] and
    F0 is weak_SG-embedding implies F is weak_SG-embedding and
    F0 is strong_SG-embedding implies F is strong_SG-embedding and
    F0 is isomorphism implies F is isomorphism and
    A3: F0 is Disomorphism implies F is Disomorphism by A1, Th145;
  thus thesis by A2, A3;
end;

theorem Th148:
  for G3, G4 being _Graph, v1, v2 being object
  for G1 being addVertex of G3,v1, G2 being addVertex of G4,v2
  for F0 being PGraphMapping of G3,G4
  st not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4
  ex F being PGraphMapping of G1, G2 st F = [F0_V +* (v1 .--> v2), F0_E] &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is directed implies F is directed) &
    (F0 is semi-continuous implies F is semi-continuous) &
    (F0 is continuous implies F is continuous) &
    (F0 is semi-Dcontinuous implies F is semi-Dcontinuous) &
    (F0 is Dcontinuous implies F is Dcontinuous)
proof
  let G3, G4 be _Graph, v1, v2 be object;
  let G1 be addVertex of G3,v1, G2 be addVertex of G4,v2;
  let F0 be PGraphMapping of G3,G4;
  assume A1: not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4;
  set f = v1 .--> v2;
  A2: dom f = dom({v1} --> v2) by FUNCOP_1:def 9
    .= {v1} \ the_Vertices_of G3 by A1, ZFMISC_1:59;
  v1 is set & v2 is set by TARSKI:1;
  then rng f = {v2} by FUNCOP_1:88
    .= {v2} \ the_Vertices_of G4 by A1, ZFMISC_1:59;
  then consider F being PGraphMapping of G1, G2 such that
    A3: F = [F0_V +* f, F0_E] &
    (F0 is non empty  implies F is non empty) &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is directed implies F is directed) &
    (F0 is semi-continuous implies F is semi-continuous) &
    (F0 is continuous implies F is continuous) &
    (F0 is semi-Dcontinuous implies F is semi-Dcontinuous) &
    (F0 is Dcontinuous implies F is Dcontinuous) by A2, Th144;
  take F;
  thus thesis by A3;
end;

theorem
  for G3, G4 being _Graph, v1, v2 being object
  for G1 being addVertex of G3,v1, G2 being addVertex of G4,v2
  for F0 being PGraphMapping of G3,G4
  st not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4
  ex F being PGraphMapping of G1, G2 st F = [F0_V +* (v1 .--> v2), F0_E] &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is strong_SG-embedding implies F is strong_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism) &
    (F0 is Disomorphism implies F is Disomorphism)
proof
  let G3, G4 be _Graph, v1, v2 be object;
  let G1 be addVertex of G3,v1, G2 be addVertex of G4,v2;
  let F0 be PGraphMapping of G3,G4;
  assume not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4;
  then consider F being PGraphMapping of G1, G2 such that
    A1: F = [F0_V +* (v1 .--> v2), F0_E] and
    A2: F0 is total implies F is total and
    A3: F0 is onto implies F is onto and
    A4: F0 is one-to-one implies F is one-to-one and
    A5: F0 is directed implies F is directed and
    F0 is semi-continuous implies F is semi-continuous and
    A6: F0 is continuous implies F is continuous and
    F0 is semi-Dcontinuous implies F is semi-Dcontinuous and
    F0 is Dcontinuous implies F is Dcontinuous by Th148;
  take F;
  thus F = [F0_V +* (v1 .--> v2), F0_E] by A1;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A2, A4;
  thus F0 is strong_SG-embedding implies F is strong_SG-embedding
    by A2, A4, A6;
  thus F0 is isomorphism implies F is isomorphism by A2, A3, A4;
  thus F0 is Disomorphism implies F is Disomorphism by A2, A3, A4, A5;
end;

theorem
  for G3 being _Graph, G4 being G3-isomorphic _Graph, v1, v2 being object
  for G1 being addVertex of G3, v1, G2 being addVertex of G4, v2
  st v1 in the_Vertices_of G3 iff v2 in the_Vertices_of G4
  holds G2 is G1-isomorphic
proof
  let G3 be _Graph, G4 be G3-isomorphic _Graph, v1, v2 be object;
  let G1 be addVertex of G3,v1, G2 be addVertex of G4,v2;
  assume v1 in the_Vertices_of G3 iff v2 in the_Vertices_of G4;
  then per cases;
  suppose v1 in the_Vertices_of G3 & v2 in the_Vertices_of G4;
    then {v1} \ the_Vertices_of G3 = {} & {v2} \ the_Vertices_of G4 = {}
      by ZFMISC_1:60;
    then card({v1} \ the_Vertices_of G3) = card({v2} \ the_Vertices_of G4);
    hence thesis by Th146;
  end;
  suppose not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4;
    then {v1} \ the_Vertices_of G3 = {v1} & {v2} \ the_Vertices_of G4 = {v2}
      by ZFMISC_1:59;
    then card({v1} \ the_Vertices_of G3) = 1 &
      card({v2} \ the_Vertices_of G4) = 1 by CARD_1:30;
    hence thesis by Th146;
  end;
end;

theorem
  for G3 being _Graph, G4 being G3-Disomorphic _Graph, v1, v2 being object
  for G1 being addVertex of G3, v1, G2 being addVertex of G4, v2
  st v1 in the_Vertices_of G3 iff v2 in the_Vertices_of G4
  holds G2 is G1-Disomorphic
proof
  let G3 be _Graph, G4 be G3-Disomorphic _Graph, v1, v2 be object;
  let G1 be addVertex of G3,v1, G2 be addVertex of G4,v2;
  assume v1 in the_Vertices_of G3 iff v2 in the_Vertices_of G4;
  then per cases;
  suppose v1 in the_Vertices_of G3 & v2 in the_Vertices_of G4;
    then {v1} \ the_Vertices_of G3 = {} & {v2} \ the_Vertices_of G4 = {}
      by ZFMISC_1:60;
    then card({v1} \ the_Vertices_of G3) = card({v2} \ the_Vertices_of G4);
    hence thesis by Th147;
  end;
  suppose not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4;
    then {v1} \ the_Vertices_of G3 = {v1} & {v2} \ the_Vertices_of G4 = {v2}
      by ZFMISC_1:59;
    then card({v1} \ the_Vertices_of G3) = 1 &
      card({v2} \ the_Vertices_of G4) = 1 by CARD_1:30;
    hence thesis by Th147;
  end;
end;

:: for F to be (semi-)continous, it is not enough for F0
:: to be (semi-)continuous. To see this, let G3 be the edgeless graph
:: with 2 vertices, G4 be the trivial edgeless graph, F0 the total PGM
:: from G3 to G4 and v1 <> v3. F0 is (semi-)continuous, but F is not,
:: since that would result in e2 Joins F_V.v1, F_V.v1, G2
:: (because F_V.v1 = F_V.v3), but not e1 Joins v1, v1, G1.
:: If v2 and v4 are additionally not isolated in rng F0, F would be
:: (semi-)continuous, but that theorem isn't proven here.
theorem Th152:
  for G3, G4 being _Graph, v1, v3 being Vertex of G3, v2, v4 being Vertex of G4
  for e1, e2 being object
  for G1 being addEdge of G3,v1,e1,v3, G2 being addEdge of G4,v2,e2,v4
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    v1 in dom F0_V & v3 in dom F0_V &
    (F0_V.v1 = v2 & F0_V.v3 = v4 or F0_V.v1 = v4 & F0_V.v3 = v2)
  ex F being PGraphMapping of G1, G2 st F = [F0_V, F0_E +* (e1 .--> e2)] &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one)
proof
  let G3, G4 be _Graph, v1, v3 be Vertex of G3, v2, v4 be Vertex of G4;
  let e1, e2 be object;
  let G1 be addEdge of G3,v1,e1,v3, G2 be addEdge of G4,v2,e2,v4;
  let F0 be PGraphMapping of G3, G4;
  A1: e1 is set & e2 is set by TARSKI:1;
  assume that A2: not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 and
    A3: v1 in dom F0_V & v3 in dom F0_V and
    A4: F0_V.v1 = v2 & F0_V.v3 = v4 or F0_V.v1 = v4 & F0_V.v3 = v2;
  :: construct F
  the_Vertices_of G1 = the_Vertices_of G3 &
    the_Vertices_of G2 = the_Vertices_of G4 by GLIB_006:102;
  then reconsider f = F0_V
    as PartFunc of the_Vertices_of G1, the_Vertices_of G2;
  set g = F0_E +* (e1 .--> e2);
  A5: dom g = dom F0_E \/ dom(e1 .--> e2) by FUNCT_4:def 1
    .= dom F0_E \/ dom({e1} --> e2) by FUNCOP_1:def 9
    .= dom F0_E \/ {e1};
  not e1 in dom F0_E by A2;
  then dom F0_E misses {e1} by ZFMISC_1:50;
  then dom F0_E misses dom({e1} --> e2);
  then A6: dom F0_E misses dom(e1 .--> e2) by FUNCOP_1:def 9;
  dom g c= the_Edges_of G3 \/ {e1} by A5, XBOOLE_1:9;
  then A7: dom g c= the_Edges_of G1 by A2, GLIB_006:def 11;
  not e2 in rng F0_E by A2;
  then rng F0_E misses {e2} by ZFMISC_1:50;
  then A8: rng F0_E misses rng(e1 .--> e2) by A1, FUNCOP_1:88;
  A9: rng g = rng F0_E \/ rng(e1 .--> e2) by A6, NECKLACE:6
    .= rng F0_E \/ {e2} by A1, FUNCOP_1:88;
  rng g c= the_Edges_of G4 \/ {e2} by A9, XBOOLE_1:9;
  then rng g c= the_Edges_of G2 by A2, GLIB_006:def 11;
  then reconsider g as PartFunc of the_Edges_of G1, the_Edges_of G2
    by A7, RELSET_1:4;
  A10: dom g /\ the_Edges_of G3
     = (dom F0_E/\the_Edges_of G3)\/({e1}/\the_Edges_of G3) by A5, XBOOLE_1:23
    .= dom F0_E \/ ({e1}/\ the_Edges_of G3) by XBOOLE_1:28
    .= dom F0_E \/ {} by A2, ZFMISC_1:50, XBOOLE_0:def 7;
  now
    hereby
      let e be object;
      assume A11: e in dom g;
      then A12: e Joins (the_Source_of G1).e,(the_Target_of G1).e,G1
        by GLIB_000:def 13;
      then per cases by GLIB_006:72;
      suppose A13: e Joins (the_Source_of G1).e,(the_Target_of G1).e,G3;
        then A14: e in the_Edges_of G3 by GLIB_000:def 13;
        then e in dom F0_E by A10, A11, XBOOLE_0:def 4;
        then A15: (the_Source_of G3).e in dom F0_V &
          (the_Target_of  G3).e in dom F0_V by Th5;
        e Joins (the_Source_of G3).e,(the_Target_of G3).e,G3
          by A14, GLIB_000:def 13;
        hence (the_Source_of G1).e in dom f &
          (the_Target_of G1).e in dom f by A13, A15, GLIB_000:15;
      end;
      suppose A16: not e in the_Edges_of G3;
        then e = e1 by A2, A12, GLIB_006:106;
        then e DJoins v1,v3,G1 by A16, GLIB_006:105;
        hence (the_Source_of G1).e in dom f &
          (the_Target_of G1).e in dom f by A3, GLIB_000:def 14;
      end;
    end;
    let e,v,w be object;
    assume A17: e in dom g & v in dom f & w in dom f;
    assume A18: e Joins v,w,G1;
    then per cases by GLIB_006:72;
    suppose A19: e Joins v,w,G3;
      then e in the_Edges_of G3 by GLIB_000:def 13;
      then A20: e in dom F0_E by A10, A17, XBOOLE_0:def 4;
      not e in dom(e1 .--> e2)
      proof
        assume e in dom(e1 .--> e2);
        then e in dom F0_E /\ dom(e1 .--> e2) by A20, XBOOLE_0:def 4;
        hence contradiction by A6, XBOOLE_0:def 7;
      end;
      then g.e = F0_E.e by FUNCT_4:11;
      then g.e Joins f.v,f.w,G4 by A17, A19, A20, Th4;
      hence g.e Joins f.v,f.w,G2 by GLIB_006:70;
    end;
    suppose A21: not e in the_Edges_of G3;
      then A22: e = e1 by A2, A18, GLIB_006:106;
      then e in {e1} by TARSKI:def 1;
      then e in dom({e1} --> e2);
      then A23: e in dom(e1 .--> e2) by FUNCOP_1:def 9;
      A24: e2 = (e1 .--> e2).e by A22, FUNCOP_1:72
        .= g.e by A23, FUNCT_4:13;
      e2 DJoins v2,v4,G2 by A2, GLIB_006:105;
      then g.e Joins v2,v4,G2 by A24, GLIB_000:16;
      then A25: g.e Joins F0_V.v1,F0_V.v3,G2 by A4, GLIB_000:14;
      v = v1 & w = v3 or v = v3 & w = v1 by A2, A18, A21, GLIB_006:107;
      hence g.e Joins f.v,f.w,G2 by A25, GLIB_000:14;
    end;
  end;
  then reconsider F = [f,g] as PGraphMapping of G1, G2 by Th8;
  take F;
  :: show properties
  thus F = [F0_V, F0_E +* (e1 .--> e2)];
  thus F0 is total implies F is total by A2, A5, GLIB_006:def 11;
  thus F0 is onto implies F is onto by A2, A9, GLIB_006:def 11;
  thus F0 is one-to-one implies F is one-to-one by A8, FUNCT_4:92;
end;

theorem
  for G3, G4 being _Graph, v1, v3 being Vertex of G3, v2, v4 being Vertex of G4
  for e1, e2 being object
  for G1 being addEdge of G3,v1,e1,v3, G2 being addEdge of G4,v2,e2,v4
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    v1 in dom F0_V & v3 in dom F0_V &
    (F0_V.v1 = v2 & F0_V.v3 = v4 or F0_V.v1 = v4 & F0_V.v3 = v2)
  ex F being PGraphMapping of G1, G2 st F = [F0_V, F0_E +* (e1 .--> e2)] &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism)
proof
  let G3, G4 be _Graph, v1, v3 be Vertex of G3, v2, v4 be Vertex of G4;
  let e1, e2 be object;
  let G1 be addEdge of G3,v1,e1,v3, G2 be addEdge of G4,v2,e2,v4;
  let F0 be PGraphMapping of G3, G4;
  assume not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    v1 in dom F0_V & v3 in dom F0_V &
    (F0_V.v1 = v2 & F0_V.v3 = v4 or F0_V.v1 = v4 & F0_V.v3 = v2);
  then consider F being PGraphMapping of G1, G2 such that
    A1: F = [F0_V, F0_E +* (e1 .--> e2)] and
    A2: F0 is total implies F is total and
    A3: F0 is onto implies F is onto and
    A4: F0 is one-to-one implies F is one-to-one by Th152;
  take F;
  thus F = [F0_V, F0_E +* (e1 .--> e2)] by A1;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A2, A4;
  thus F0 is isomorphism implies F is isomorphism by A2, A3, A4;
end;

:: For (semi-)Dcontinuous, the same remarks as above apply.
theorem Th154:
  for G3, G4 being _Graph, v1, v3 being Vertex of G3, v2, v4 being Vertex of G4
  for e1, e2 being object
  for G1 being addEdge of G3,v1,e1,v3, G2 being addEdge of G4,v2,e2,v4
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    v1 in dom F0_V & v3 in dom F0_V & F0_V.v1 = v2 & F0_V.v3 = v4
  ex F being PGraphMapping of G1, G2 st F = [F0_V, F0_E +* (e1 .--> e2)] &
    (F0 is directed implies F is directed) &
    (F0 is Disomorphism implies F is Disomorphism)
proof
  let G3, G4 be _Graph, v1, v3 be Vertex of G3, v2, v4 be Vertex of G4;
  let e1, e2 be object;
  let G1 be addEdge of G3,v1,e1,v3, G2 be addEdge of G4,v2,e2,v4;
  let F0 be PGraphMapping of G3, G4;
  assume that A1: not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 and
    A2: v1 in dom F0_V & v3 in dom F0_V & F0_V.v1 = v2 & F0_V.v3 = v4;
  consider F being PGraphMapping of G1, G2 such that
    A3: F = [F0_V, F0_E +* (e1 .--> e2)] and
    A4: F0 is total implies F is total and
    A5: F0 is onto implies F is onto and
    A6: F0 is one-to-one implies F is one-to-one by A1, A2, Th152;
  take F;
  thus F = [F0_V, F0_E +* (e1 .--> e2)] by A3;
  :: some prelims must be done again
  set f = F_V, g = F_E;
  A7: dom g = dom F0_E \/ dom(e1 .--> e2) by A3, FUNCT_4:def 1
    .= dom F0_E \/ dom({e1} --> e2) by FUNCOP_1:def 9
    .= dom F0_E \/ {e1};
  not e1 in dom F0_E by A1;
  then dom F0_E misses {e1} by ZFMISC_1:50;
  then dom F0_E misses dom({e1} --> e2);
  then A8: dom F0_E misses dom(e1 .--> e2) by FUNCOP_1:def 9;
  A9: dom g /\ the_Edges_of G3
     = (dom F0_E/\the_Edges_of G3)\/({e1}/\the_Edges_of G3) by A7, XBOOLE_1:23
    .= dom F0_E \/ ({e1}/\ the_Edges_of G3) by XBOOLE_1:28
    .= dom F0_E \/ {} by A1, ZFMISC_1:50, XBOOLE_0:def 7;
  thus F0 is directed implies F is directed
  proof
    assume A10: F0 is directed;
    now
      let e,v,w be object;
      assume A11: e in dom F_E & v in dom F_V & w in dom F_V;
      assume A12: e DJoins v,w,G1;
      then A13: e Joins v,w,G1 by GLIB_000:16;
      per cases by A12, GLIB_006:71;
      suppose A14: e DJoins v,w,G3;
        then e in the_Edges_of G3 by GLIB_000:def 14;
        then A15: e in dom F0_E by A9, A11, XBOOLE_0:def 4;
        not e in dom(e1 .--> e2)
        proof
          assume e in dom(e1 .--> e2);
          then e in dom F0_E /\ dom(e1 .--> e2) by A15, XBOOLE_0:def 4;
          hence contradiction by A8, XBOOLE_0:def 7;
        end;
        then A16: g.e = F0_E.e by A3, FUNCT_4:11;
        v in dom F0_V & w in dom F0_V by A3, A11;
        then g.e DJoins f.v,f.w,G4 by A3, A10, A14, A15, A16;
        hence g.e DJoins f.v,f.w,G2 by GLIB_006:70;
      end;
      suppose not e in the_Edges_of G3;
        then A17: e = e1 by A1, A13, GLIB_006:106;
        then e in {e1} by TARSKI:def 1;
        then e in dom({e1} --> e2);
        then A18: e in dom(e1 .--> e2) by FUNCOP_1:def 9;
        A19: e2 = (e1 .--> e2).e by A17, FUNCOP_1:72
          .= g.e by A18, A3, FUNCT_4:13;
        e2 DJoins v2,v4,G2 by A1, GLIB_006:105;
        then A20: g.e DJoins F0_V.v1,F0_V.v3,G2 by A2, A19;
        e DJoins v1,v3,G1 by A1, A17, GLIB_006:105;
        then v1 = v & v3 = w by A12, GLIB_009:6;
        hence g.e DJoins f.v,f.w,G2 by A3, A20;
      end;
    end;
    hence thesis;
  end;
  hence F0 is Disomorphism implies F is Disomorphism by A4, A5, A6;
end;

:: Similar to addEdge, the (semi-)(D)continuous properties are not
:: always carried over from F0 to F due to possible isolated vertices.
theorem Th155:
  for G3, G4 being _Graph, v3 being Vertex of G3, v4 being Vertex of G4
  for e1,e2,v1,v2 being object
  for G1 being addAdjVertex of G3,v1,e1,v3
  for G2 being addAdjVertex of G4,v2,e2,v4
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    v3 in dom F0_V & F0_V.v3 = v4
  ex F being PGraphMapping of G1, G2 st
    F = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is directed implies F is directed)
proof
  let G3, G4 be _Graph, v3 be Vertex of G3, v4 be Vertex of G4;
  let e1,e2,v1,v2 be object;
  let G1 be addAdjVertex of G3,v1,e1,v3, G2 be addAdjVertex of G4,v2,e2,v4;
  let F0 be PGraphMapping of G3, G4;
  assume that A1: not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 and
    A2: v3 in dom F0_V & F0_V.v3 = v4;
  consider G5 being addVertex of G3,v1 such that
    A3: G1 is addEdge of G5,v1,e1,v3 by A1, GLIB_006:126;
  consider G6 being addVertex of G4,v2 such that
    A4: G2 is addEdge of G6,v2,e2,v4 by A1, GLIB_006:126;
  consider F1 being PGraphMapping of G5, G6 such that
    A5: F1 = [F0_V +* (v1 .--> v2), F0_E] and
    A6: F0 is total implies F1 is total and
    A7: F0 is onto implies F1 is onto and
    A8: F0 is one-to-one implies F1 is one-to-one and
    A9: F0 is directed implies F1 is directed and
    F0 is semi-continuous implies F1 is semi-continuous and
    F0 is continuous implies F1 is continuous and
    F0 is semi-Dcontinuous implies F1 is semi-Dcontinuous and
    F0 is Dcontinuous implies F1 is Dcontinuous by A1, Th148;
  A10: v1 in dom F1_V & v3 in dom F1_V & F1_V.v1 = v2 & F1_V.v3 = v4
  proof
    v1 in {v1} by TARSKI:def 1;
    then v1 in dom({v1} --> v2);
    then A11: v1 in dom(v1 .--> v2) by FUNCOP_1:def 9;
    hence v1 in dom F1_V by A5, FUNCT_4:10, TARSKI:def 3;
    thus v3 in dom F1_V by A2, A5, FUNCT_4:10, TARSKI:def 3;
    thus F1_V.v1 = (v1 .--> v2).v1 by A5, A11, FUNCT_4:13
      .= v2 by FUNCOP_1:72;
    v3 <> v1 by A1;
    then not v3 in {v1} by TARSKI:def 1;
    then not v3 in dom(v1 .--> v2);
    hence F1_V.v3 = v4 by A2, A5, FUNCT_4:11;
  end;
  A12: not e1 in the_Edges_of G5 & not e2 in the_Edges_of G6
    by A1, GLIB_006:def 10;
  v2 in rng F1_V & v4 in rng F1_V by A10, FUNCT_1:3;
  then A13: v2 is Vertex of G6 & v4 is Vertex of G6;
  then consider F2 being PGraphMapping of G1, G2 such that
    A14: F2 = [F1_V, F1_E +* (e1 .--> e2)] and
    A15: F1 is total implies F2 is total and
    A16: F1 is onto implies F2 is onto and
    A17: F1 is one-to-one implies F2 is one-to-one
    by A3, A4, A10, A12, Th152;
  take F2;
  thus F2 = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] by A5, A14;
  thus F0 is total implies F2 is total by A6, A15;
  thus F0 is onto implies F2 is onto by A7, A16;
  thus F0 is one-to-one implies F2 is one-to-one by A8, A17;
  consider F3 being PGraphMapping of G1, G2 such that
    A18: F3 = [F1_V, F1_E +* (e1 .--> e2)] and
    A19: F1 is directed implies F3 is directed and
    F1 is Disomorphism implies F3 is Disomorphism
    by A3, A4, A10, A12, A13, Th154;
  thus F0 is directed implies F2 is directed by A9, A14, A18, A19;
end;

theorem
  for G3, G4 being _Graph, v3 being Vertex of G3, v4 being Vertex of G4
  for e1,e2,v1,v2 being object
  for G1 being addAdjVertex of G3,v1,e1,v3
  for G2 being addAdjVertex of G4,v2,e2,v4
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    v3 in dom F0_V & F0_V.v3 = v4
  ex F being PGraphMapping of G1, G2 st
    F = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism) &
    (F0 is Disomorphism implies F is Disomorphism)
proof
  let G3, G4 be _Graph, v3 be Vertex of G3, v4 be Vertex of G4;
  let e1,e2,v1,v2 be object;
  let G1 be addAdjVertex of G3,v1,e1,v3, G2 be addAdjVertex of G4,v2,e2,v4;
  let F0 be PGraphMapping of G3, G4;
  assume not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    v3 in dom F0_V & F0_V.v3 = v4;
  then consider F being PGraphMapping of G1, G2 such that
    A1: F = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] and
    A2: F0 is total implies F is total and
    A3: F0 is onto implies F is onto and
    A4: F0 is one-to-one implies F is one-to-one and
    A5: F0 is directed implies F is directed by Th155;
  take F;
  thus F = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] by A1;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A2, A4;
  thus F0 is isomorphism implies F is isomorphism by A2, A3, A4;
  thus F0 is Disomorphism implies F is Disomorphism by A2, A3, A4, A5;
end;

theorem Th157:
  for G3, G4 being _Graph, v3 being Vertex of G3, v4 being Vertex of G4
  for e1,e2,v1,v2 being object
  for G1 being addAdjVertex of G3,v3,e1,v1
  for G2 being addAdjVertex of G4,v4,e2,v2
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    v3 in dom F0_V & F0_V.v3 = v4
  ex F being PGraphMapping of G1, G2 st
    F = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is directed implies F is directed)
proof
  let G3, G4 be _Graph, v3 be Vertex of G3, v4 be Vertex of G4;
  let e1,e2,v1,v2 be object;
  let G1 be addAdjVertex of G3,v3,e1,v1, G2 be addAdjVertex of G4,v4,e2,v2;
  let F0 be PGraphMapping of G3, G4;
  assume that A1: not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 and
    A2: v3 in dom F0_V & F0_V.v3 = v4;
  consider G5 being addVertex of G3,v1 such that
    A3: G1 is addEdge of G5,v3,e1,v1 by A1, GLIB_006:125;
  consider G6 being addVertex of G4,v2 such that
    A4: G2 is addEdge of G6,v4,e2,v2 by A1, GLIB_006:125;
  consider F1 being PGraphMapping of G5, G6 such that
    A5: F1 = [F0_V +* (v1 .--> v2), F0_E] and
    A6: F0 is total implies F1 is total and
    A7: F0 is onto implies F1 is onto and
    A8: F0 is one-to-one implies F1 is one-to-one and
    A9: F0 is directed implies F1 is directed and
    F0 is semi-continuous implies F1 is semi-continuous and
    F0 is continuous implies F1 is continuous and
    F0 is semi-Dcontinuous implies F1 is semi-Dcontinuous and
    F0 is Dcontinuous implies F1 is Dcontinuous by A1, Th148;
  A10: v1 in dom F1_V & v3 in dom F1_V & F1_V.v1 = v2 & F1_V.v3 = v4
  proof
    v1 in {v1} by TARSKI:def 1;
    then v1 in dom({v1} --> v2);
    then A11: v1 in dom(v1 .--> v2) by FUNCOP_1:def 9;
    hence v1 in dom F1_V by A5, FUNCT_4:10, TARSKI:def 3;
    thus v3 in dom F1_V by A2, A5, FUNCT_4:10, TARSKI:def 3;
    thus F1_V.v1 = (v1 .--> v2).v1 by A5, A11, FUNCT_4:13
      .= v2 by FUNCOP_1:72;
    v3 <> v1 by A1;
    then not v3 in {v1} by TARSKI:def 1;
    then not v3 in dom(v1 .--> v2);
    hence F1_V.v3 = v4 by A2, A5, FUNCT_4:11;
  end;
  A12: not e1 in the_Edges_of G5 & not e2 in the_Edges_of G6
    by A1, GLIB_006:def 10;
  v2 in rng F1_V & v4 in rng F1_V by A10, FUNCT_1:3;
  then A13: v2 is Vertex of G6 & v4 is Vertex of G6;
  then consider F2 being PGraphMapping of G1, G2 such that
    A14: F2 = [F1_V, F1_E +* (e1 .--> e2)] and
    A15: F1 is total implies F2 is total and
    A16: F1 is onto implies F2 is onto and
    A17: F1 is one-to-one implies F2 is one-to-one
    by A3, A4, A10, A12, Th152;
  take F2;
  thus F2 = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] by A5, A14;
  thus F0 is total implies F2 is total by A6, A15;
  thus F0 is onto implies F2 is onto by A7, A16;
  thus F0 is one-to-one implies F2 is one-to-one by A8, A17;
  consider F3 being PGraphMapping of G1, G2 such that
    A18: F3 = [F1_V, F1_E +* (e1 .--> e2)] and
    A19: F1 is directed implies F3 is directed and
    F1 is Disomorphism implies F3 is Disomorphism
    by A3, A4, A10, A12, A13, Th154;
  thus F0 is directed implies F2 is directed by A9, A14, A18, A19;
end;

theorem
  for G3, G4 being _Graph, v3 being Vertex of G3, v4 being Vertex of G4
  for e1,e2,v1,v2 being object
  for G1 being addAdjVertex of G3,v3,e1,v1
  for G2 being addAdjVertex of G4,v4,e2,v2
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    v3 in dom F0_V & F0_V.v3 = v4
  ex F being PGraphMapping of G1, G2 st
    F = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism) &
    (F0 is Disomorphism implies F is Disomorphism)
proof
  let G3, G4 be _Graph, v3 be Vertex of G3, v4 be Vertex of G4;
  let e1,e2,v1,v2 be object;
  let G1 be addAdjVertex of G3,v3,e1,v1, G2 be addAdjVertex of G4,v4,e2,v2;
  let F0 be PGraphMapping of G3, G4;
  assume not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    v3 in dom F0_V & F0_V.v3 = v4;
  then consider F being PGraphMapping of G1, G2 such that
    A1: F = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] and
    A2: F0 is total implies F is total and
    A3: F0 is onto implies F is onto and
    A4: F0 is one-to-one implies F is one-to-one and
    A5: F0 is directed implies F is directed by Th157;
  take F;
  thus F = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] by A1;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A2, A4;
  thus F0 is isomorphism implies F is isomorphism by A2, A3, A4;
  thus F0 is Disomorphism implies F is Disomorphism by A2, A3, A4, A5;
end;

theorem
  for G3, G4 being _Graph, v3 being Vertex of G3, v4 being Vertex of G4
  for e1,e2,v1,v2 being object
  for G1 being addAdjVertex of G3,v1,e1,v3
  for G2 being addAdjVertex of G4,v4,e2,v2
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    v3 in dom F0_V & F0_V.v3 = v4
  ex F being PGraphMapping of G1, G2 st
    F = [F0_V +*(v1 .--> v2), F0_E +*(e1 .--> e2)] &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism)
proof
  let G3, G4 be _Graph, v3 be Vertex of G3, v4 be Vertex of G4;
  let e1,e2,v1,v2 be object;
  let G1 be addAdjVertex of G3,v1,e1,v3, G2 be addAdjVertex of G4,v4,e2,v2;
  let F0 be PGraphMapping of G3, G4;
  assume that A1: not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 and
    A2: v3 in dom F0_V & F0_V.v3 = v4;
  consider G5 being addVertex of G3,v1 such that
    A3: G1 is addEdge of G5,v1,e1,v3 by A1, GLIB_006:126;
  consider G6 being addVertex of G4,v2 such that
    A4: G2 is addEdge of G6,v4,e2,v2 by A1, GLIB_006:125;
  consider F1 being PGraphMapping of G5, G6 such that
    A5: F1 = [F0_V +* (v1 .--> v2), F0_E] and
    A6: F0 is total implies F1 is total and
    A7: F0 is onto implies F1 is onto and
    A8: F0 is one-to-one implies F1 is one-to-one and
    F0 is directed implies F1 is directed and
    F0 is semi-continuous implies F1 is semi-continuous and
    F0 is continuous implies F1 is continuous and
    F0 is semi-Dcontinuous implies F1 is semi-Dcontinuous and
    F0 is Dcontinuous implies F1 is Dcontinuous by A1, Th148;
  A9: v1 in dom F1_V & v3 in dom F1_V & F1_V.v1 = v2 & F1_V.v3 = v4
  proof
    v1 in {v1} by TARSKI:def 1;
    then v1 in dom({v1} --> v2);
    then A10: v1 in dom(v1 .--> v2) by FUNCOP_1:def 9;
    hence v1 in dom F1_V by A5, FUNCT_4:10, TARSKI:def 3;
    thus v3 in dom F1_V by A2, A5, FUNCT_4:10, TARSKI:def 3;
    thus F1_V.v1 = (v1 .--> v2).v1 by A5, A10, FUNCT_4:13
      .= v2 by FUNCOP_1:72;
    v3 <> v1 by A1;
    then not v3 in {v1} by TARSKI:def 1;
    then not v3 in dom(v1 .--> v2);
    hence F1_V.v3 = v4 by A2, A5, FUNCT_4:11;
  end;
  A11: not e1 in the_Edges_of G5 & not e2 in the_Edges_of G6
    by A1, GLIB_006:def 10;
  v2 in rng F1_V & v4 in rng F1_V by A9, FUNCT_1:3;
  then v2 is Vertex of G6 & v4 is Vertex of G6;
  then consider F2 being PGraphMapping of G1, G2 such that
    A12: F2 = [F1_V, F1_E +* (e1 .--> e2)] and
    A13: F1 is total implies F2 is total and
    A14: F1 is onto implies F2 is onto and
    A15: F1 is one-to-one implies F2 is one-to-one
    by A3, A4, A9, A11, Th152;
  take F2;
  thus F2 = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] by A5, A12;
  thus A16: F0 is total implies F2 is total by A6, A13;
  thus A17: F0 is onto implies F2 is onto by A7, A14;
  thus A18: F0 is one-to-one implies F2 is one-to-one by A8, A15;
  thus F0 is weak_SG-embedding implies F2 is weak_SG-embedding by A16, A18;
  thus F0 is isomorphism implies F2 is isomorphism by A16, A17, A18;
end;

theorem
  for G3, G4 being _Graph, v3 being Vertex of G3, v4 being Vertex of G4
  for e1,e2,v1,v2 being object
  for G1 being addAdjVertex of G3,v3,e1,v1
  for G2 being addAdjVertex of G4,v2,e2,v4
  for F0 being PGraphMapping of G3, G4
  st not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    v3 in dom F0_V & F0_V.v3 = v4
  ex F being PGraphMapping of G1, G2 st
    F = [F0_V +*(v1 .--> v2), F0_E +*(e1 .--> e2)] &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism)
proof
  let G3, G4 be _Graph, v3 be Vertex of G3, v4 be Vertex of G4;
  let e1,e2,v1,v2 be object;
  let G1 be addAdjVertex of G3,v3,e1,v1, G2 be addAdjVertex of G4,v2,e2,v4;
  let F0 be PGraphMapping of G3, G4;
  assume that A1: not e1 in the_Edges_of G3 & not e2 in the_Edges_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 and
    A2: v3 in dom F0_V & F0_V.v3 = v4;
  consider G5 being addVertex of G3,v1 such that
    A3: G1 is addEdge of G5,v3,e1,v1 by A1, GLIB_006:125;
  consider G6 being addVertex of G4,v2 such that
    A4: G2 is addEdge of G6,v2,e2,v4 by A1, GLIB_006:126;
  consider F1 being PGraphMapping of G5, G6 such that
    A5: F1 = [F0_V +* (v1 .--> v2), F0_E] and
    A6: F0 is total implies F1 is total and
    A7: F0 is onto implies F1 is onto and
    A8: F0 is one-to-one implies F1 is one-to-one and
    F0 is directed implies F1 is directed and
    F0 is semi-continuous implies F1 is semi-continuous and
    F0 is continuous implies F1 is continuous and
    F0 is semi-Dcontinuous implies F1 is semi-Dcontinuous and
    F0 is Dcontinuous implies F1 is Dcontinuous by A1, Th148;
  A9: v1 in dom F1_V & v3 in dom F1_V & F1_V.v1 = v2 & F1_V.v3 = v4
  proof
    v1 in {v1} by TARSKI:def 1;
    then v1 in dom({v1} --> v2);
    then A10: v1 in dom(v1 .--> v2) by FUNCOP_1:def 9;
    hence v1 in dom F1_V by A5, FUNCT_4:10, TARSKI:def 3;
    thus v3 in dom F1_V by A2, A5, FUNCT_4:10, TARSKI:def 3;
    thus F1_V.v1 = (v1 .--> v2).v1 by A5, A10, FUNCT_4:13
      .= v2 by FUNCOP_1:72;
    v3 <> v1 by A1;
    then not v3 in {v1} by TARSKI:def 1;
    then not v3 in dom(v1 .--> v2);
    hence F1_V.v3 = v4 by A2, A5, FUNCT_4:11;
  end;
  A11: not e1 in the_Edges_of G5 & not e2 in the_Edges_of G6
    by A1, GLIB_006:def 10;
  v2 in rng F1_V & v4 in rng F1_V by A9, FUNCT_1:3;
  then v2 is Vertex of G6 & v4 is Vertex of G6;
  then consider F2 being PGraphMapping of G1, G2 such that
    A12: F2 = [F1_V, F1_E +* (e1 .--> e2)] and
    A13: F1 is total implies F2 is total and
    A14: F1 is onto implies F2 is onto and
    A15: F1 is one-to-one implies F2 is one-to-one
    by A3, A4, A9, A11, Th152;
  take F2;
  thus F2 = [F0_V +* (v1 .--> v2), F0_E +* (e1 .--> e2)] by A5, A12;
  thus A16: F0 is total implies F2 is total by A6, A13;
  thus A17: F0 is onto implies F2 is onto by A7, A14;
  thus A18: F0 is one-to-one implies F2 is one-to-one by A8, A15;
  thus F0 is weak_SG-embedding implies F2 is weak_SG-embedding by A16, A18;
  thus F0 is isomorphism implies F2 is isomorphism by A16, A17, A18;
end;

theorem
  for G being _Graph, v being object, V being set
  for G1, G2 being addAdjVertexAll of G,v,V
  holds G2 is G1-isomorphic
proof
  let G be _Graph, v be object, V be set;
  let G1, G2 be addAdjVertexAll of G,v,V;
  per cases;
  suppose A1: V c= the_Vertices_of G & not v in the_Vertices_of G;
    set f = id(the_Vertices_of G \/ {v});
    consider E1 being set such that
      A2: card V = card E1 & E1 misses the_Edges_of G &
      the_Edges_of G1 = the_Edges_of G \/ E1 and
      for v1 being object st v1 in V ex e1 being object st e1 in E1 &
        e1 Joins v1,v,G1 &
        for e9 being object st e9 Joins v1,v,G1 holds e1 = e9
      by A1, GLIB_007:def 4;
    consider g being Function of the_Edges_of G1, the_Edges_of G2 such that
      A3: g|the_Edges_of G = id the_Edges_of G & g is one-to-one onto and
      A4: for v1,e,v2 being object st e Joins v1,v2,G1 holds g.e Joins v1,v2,G2
      by GLIB_007:68;
    A5: dom f = the_Vertices_of G1 by A1, GLIB_007:def 4;
    A6: rng f = the_Vertices_of G2 by A1, GLIB_007:def 4;
    reconsider f as PartFunc of the_Vertices_of G1, the_Vertices_of G2
      by A5, A6;
    A7: dom g = the_Edges_of G1
    proof
      per cases;
      suppose the_Edges_of G2 <> {};
        hence thesis by FUNCT_2:def 1;
      end;
      suppose A8: the_Edges_of G2 = {};
        the_Edges_of G c= the_Edges_of G2 by GLIB_006:def 9;
        then A9: the_Edges_of G = {} by A8, XBOOLE_1:3;
        V is empty by A1, A8, GLIB_007:47;
        then A10: card the_Edges_of G = 0 & card E1 = 0 by A2, A9;
        card the_Edges_of G1 = card the_Edges_of G +` card E1 by A2, CARD_2:35
          .= 0 by A10, CARD_2:18;
        then the_Edges_of G1 = {};
        hence thesis;
      end;
    end;
    A11: rng g = the_Edges_of G2 by A3, FUNCT_2:def 3;
    reconsider g as PartFunc of the_Edges_of G1, the_Edges_of G2;
    now
      hereby
        let e be object;
        assume e in dom g;
        then e Joins (the_Source_of G1).e, (the_Target_of G1).e, G1
          by GLIB_000:def 13;
        hence (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f
          by A5, GLIB_000:13;
      end;
      let e,v0,w be object;
      assume e in dom g & v0 in dom f & w in dom f;
      then A12: v0 in the_Vertices_of G \/ {v} & w in the_Vertices_of G \/ {v};
      assume e Joins v0,w,G1;
      then g.e Joins v0,w,G2 by A4;
      then g.e Joins f.v0,w,G2 by A12, FUNCT_1:18;
      hence g.e Joins f.v0,f.w,G2 by A12, FUNCT_1:18;
    end;
    then reconsider F = [f,g] as PGraphMapping of G1, G2 by Th8;
    A13: F is total by A5, A7;
    A14: F is one-to-one by A3;
    F is onto by A6, A11;
    hence thesis by A13, A14;
  end;
  suppose not (V c= the_Vertices_of G & not v in the_Vertices_of G);
    then G1 == G & G2 == G by GLIB_007:def 4;
    then A15: G1 is reverseEdgeDirections of G, {} &
      G2 is reverseEdgeDirections of G, {} by GLIB_009:42;
    G is G-isomorphic by Th53;
    hence thesis by A15, Th143;
  end;
end;

theorem Th162:
  for G3, G4 being _Graph, v1,v2 being object, V1, V2 being set
  for G1 being addAdjVertexAll of G3,v1,V1
  for G2 being addAdjVertexAll of G4,v2,V2
  for F0 being PGraphMapping of G3, G4
  st V1 c= the_Vertices_of G3 & V2 c= the_Vertices_of G4 &
    not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 &
    F0_V | V1 is one-to-one & dom(F0_V | V1) = V1 & rng(F0_V | V1) = V2
  ex F being PGraphMapping of G1, G2 st
    F_V = F0_V +* (v1 .--> v2) & F_E | dom F0_E = F0_E &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism)
proof
  let G3, G4 be _Graph, v1,v2 be object, V1, V2 be set;
  let G1 be addAdjVertexAll of G3,v1,V1, G2 be addAdjVertexAll of G4,v2,V2;
  let F0 be PGraphMapping of G3, G4;
  assume that
    A1: V1 c= the_Vertices_of G3 & V2 c= the_Vertices_of G4 &
      not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4 and
    A2: F0_V | V1 is one-to-one & dom(F0_V | V1) = V1 & rng(F0_V | V1) = V2;
  :: construct F, starting with F_V
  A3: V1 c= dom F0_V
  proof
    V1 = dom F0_V /\ V1 by A2, RELAT_1:61;
    hence thesis by XBOOLE_1:17;
  end;
  set f = F0_V +* (v1 .--> v2);
  A4: v1 is set & v2 is set by TARSKI:1;
  A5: {v1} = dom({v1} --> v2)
    .= dom(v1 .--> v2) by FUNCOP_1:def 9;
  A6: dom f = dom F0_V \/ {v1} by A5, FUNCT_4:def 1;
  not v1 in dom F0_V by A1;
  then A7: dom F0_V misses dom(v1 .--> v2) by A5, ZFMISC_1:50;
  dom f c= the_Vertices_of G3 \/ {v1} by A6, XBOOLE_1:9;
  then A8: dom f c= the_Vertices_of G1 by A1, GLIB_007:def 4;
  not v2 in rng F0_V by A1;
  then rng F0_V misses {v2} by ZFMISC_1:50;
  then A9: rng F0_V misses rng(v1 .--> v2) by A4, FUNCOP_1:88;
  A10: rng f = rng F0_V \/ rng(v1 .--> v2) by A7, NECKLACE:6
    .= rng F0_V \/ {v2} by A4, FUNCOP_1:88;
  rng f c= the_Vertices_of G4 \/ {v2} by A10, XBOOLE_1:9;
  then rng f c= the_Vertices_of G2 by A1, GLIB_007:def 4;
  then reconsider f as PartFunc of the_Vertices_of G1, the_Vertices_of G2
    by A8, RELSET_1:4;
  :: next is F_E
  V1 c= V1;
  then consider h1 being Function of V1, G1.edgesBetween(V1,{v1}) such that
    A11: h1 is one-to-one onto and
    A12: for w being object st w in V1 holds h1.w Joins w,v1,G1
    by A1, GLIB_007:57;
  V2 c= V2;
  then consider h2 being Function of V2, G2.edgesBetween(V2,{v2}) such that
    A13: h2 is one-to-one onto and
    A14: for w being object st w in V2 holds h2.w Joins w,v2,G2
    by A1, GLIB_007:57;
  reconsider h1 as one-to-one Function by A11;
  set g = F0_E +* (h2*F0_V*(h1"));
  dom(h2*F0_V*(h1")) c= dom(h1") by RELAT_1:25;
  then dom F0_E \/ dom(h2*F0_V*(h1")) c= the_Edges_of G3 \/ dom(h1")
    by XBOOLE_1:13;
  then dom g c= the_Edges_of G3 \/ dom(h1") by FUNCT_4:def 1;
  then dom g c= the_Edges_of G3 \/ rng h1 by FUNCT_1:33;
  then dom g c= the_Edges_of G3 \/ G1.edgesBetween(V1,{v1})
    by A11, FUNCT_2:def 3;
  then A15: dom g c= the_Edges_of G1 by A1, GLIB_007:59;
  A16: rng(h2*F0_V*(h1")) c= rng(h2*F0_V) by RELAT_1:26;
  rng(h2*F0_V) c= rng h2 by RELAT_1:26;
  then rng(h2*F0_V*(h1")) c= rng h2 by A16, XBOOLE_1:1;
  then A17: rng F0_E \/ rng(h2*F0_V*(h1")) c= the_Edges_of G4 \/ rng h2
    by XBOOLE_1:13;
  rng g c= rng F0_E \/ rng(h2*F0_V*(h1")) by FUNCT_4:17;
  then rng g c= the_Edges_of G4 \/ rng h2 by A17, XBOOLE_1:1;
  then rng g c= the_Edges_of G4 \/ G2.edgesBetween(V2,{v2})
    by A13, FUNCT_2:def 3;
  then rng g c= the_Edges_of G2 by A1, GLIB_007:59;
  then reconsider g as PartFunc of the_Edges_of G1, the_Edges_of G2
    by A15, RELSET_1:4;
  A18: G1.edgesBetween(V1,{v1}) misses the_Edges_of G3 &
    the_Edges_of G1 = the_Edges_of G3 \/ G1.edgesBetween(V1,{v1})
    by A1, GLIB_007:59;
  A19: dom F0_E misses dom(h2*F0_V*(h1"))
  proof
    assume dom F0_E meets dom(h2*F0_V*(h1"));
    then dom F0_E /\ dom(h2*F0_V*(h1")) <> {} by XBOOLE_0:def 7;
    then consider e being object such that
      A20: e in dom F0_E /\ dom(h2*F0_V*(h1")) by XBOOLE_0:def 1;
    A21: e in the_Edges_of G3 by A20;
    e in dom(h2*F0_V*(h1")) by A20, XBOOLE_0:def 4;
    then e in dom(h1") by FUNCT_1:11;
    then e in rng h1 by FUNCT_1:33;
    then e in G1.edgesBetween(V1,{v1}) by A11, FUNCT_2:def 3;
    then e in the_Edges_of G3 /\ G1.edgesBetween(V1,{v1})
      by A21, XBOOLE_0:def 4;
    hence contradiction by A1, GLIB_007:59, XBOOLE_0:def 7;
  end;
  A22: rng F0_E misses rng(h2*F0_V*(h1"))
  proof
    assume rng F0_E meets rng(h2*F0_V*(h1"));
    then rng F0_E /\ rng(h2*F0_V*(h1")) <> {} by XBOOLE_0:def 7;
    then consider e being object such that
      A23: e in rng F0_E /\ rng(h2*F0_V*(h1")) by XBOOLE_0:def 1;
    e in rng F0_E by A23, XBOOLE_0:def 4;
    then A24: e in the_Edges_of G4;
    e in rng(h2*F0_V*(h1")) by A23, XBOOLE_0:def 4;
    then e in rng(h2*F0_V) by RELAT_1:26, TARSKI:def 3;
    then e in rng h2 by RELAT_1:26, TARSKI:def 3;
    then e in the_Edges_of G4 /\ G2.edgesBetween(V2,{v2})
      by A24, XBOOLE_0:def 4;
    hence contradiction by A1, GLIB_007:59, XBOOLE_0:def 7;
  end;
  consider E1 being set such that
    card V1 = card E1 & E1 misses the_Edges_of G3 &
    the_Edges_of G1 = the_Edges_of G3 \/ E1 and
    A25: for w1 being object st w1 in V1 ex e1 being object st e1 in E1 &
      e1 Joins w1,v1,G1 &
      for e9 being object st e9 Joins w1,v1,G1 holds e1 = e9
    by A1, GLIB_007:def 4;
  consider E2 being set such that
    card V2 = card E2 & E2 misses the_Edges_of G4 &
    the_Edges_of G2 = the_Edges_of G4 \/ E2 and
    A26: for w2 being object st w2 in V2 ex e2 being object st e2 in E2 &
      e2 Joins w2,v2,G2 &
      for e9 being object st e9 Joins w2,v2,G2 holds e2 = e9
    by A1, GLIB_007:def 4;
  :: defining properties of PGM
  now
    hereby
      let e be object;
      assume e in dom g;
      then e in dom F0_E \/ dom(h2*F0_V*(h1")) by FUNCT_4:def 1;
      then per cases by XBOOLE_0:def 3;
      suppose A27: e in dom F0_E;
        then (the_Source_of G1).e = (the_Source_of G3).e &
          (the_Target_of G1).e = (the_Target_of G3).e by GLIB_006:def 9;
        then (the_Source_of G1).e in dom F0_V &
          (the_Target_of G1).e in dom F0_V by A27, Th5;
        hence (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f
          by A6, XBOOLE_0:def 3;
      end;
      suppose e in dom(h2*F0_V*(h1"));
        then e in dom(h1") by RELAT_1:25, TARSKI:def 3;
        then e in rng h1 by FUNCT_1:33;
        then e in G1.edgesBetween(V1,{v1}) by A11, FUNCT_2:def 3;
        then e SJoins V1,{v1},G1 by GLIB_000:def 30;
        then (the_Source_of G1).e in V1 & (the_Target_of G1).e in {v1} or
          (the_Source_of G1).e in {v1} & (the_Target_of G1).e in V1
          by GLIB_000:def 15;
        then A28: (the_Source_of G1).e in V1 \/ {v1} &
          (the_Target_of G1).e in V1 \/ {v1} by XBOOLE_0:def 3;
        V1 \/ {v1} c= dom F0_V \/ {v1} by A3, XBOOLE_1:9;
        hence (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f
          by A6, A28;
      end;
    end;
    let e,v,w be object;
    assume A29: e in dom g & v in dom f & w in dom f;
    assume A30: e Joins v,w,G1;
    then per cases by GLIB_006:72;
    :: in case edge is from subgraph; properties of F0 can be used
    suppose A31: e Joins v,w,G3;
      then A32: e in the_Edges_of G3 by GLIB_000:def 13;
      A33: not e in dom(h2*F0_V*(h1"))
      proof
        assume e in dom(h2*F0_V*(h1"));
        then e in dom(h1") by RELAT_1:25, TARSKI:def 3;
        then e in rng h1 by FUNCT_1:33;
        then e in G1.edgesBetween(V1,{v1}) by A11, FUNCT_2:def 3;
        then the_Edges_of G3 /\ G1.edgesBetween(V1,{v1}) <> {}
          by A32, XBOOLE_0:def 4;
        hence contradiction by A18, XBOOLE_0:def 7;
      end;
      e in dom F0_E \/ dom(h2*F0_V*(h1")) by A29, FUNCT_4:def 1;
      then A34: e in dom F0_E by A33, XBOOLE_0:def 3;
      v in the_Vertices_of G3 & w in the_Vertices_of G3 by A31, GLIB_000:13;
      then A35: not v in {v1} & not w in {v1} by A1, TARSKI:def 1;
      then not v in dom(v1 .--> v2) & not w in dom(v1 .--> v2);
      then A36: f.v = F0_V.v & f.w = F0_V.w by FUNCT_4:11;
      v in dom F0_V \/ dom(v1 .--> v2) & w in dom F0_V \/ dom(v1 .--> v2)
        by A29, FUNCT_4:def 1;
      then v in dom F0_V & w in dom F0_V by A35, A5, XBOOLE_0:def 3;
      then F0_E.e Joins F0_V.v,F0_V.w,G4 by A31, A34, Th4;
      then g.e Joins f.v,f.w,G4 by A33, A36, FUNCT_4:11;
      hence g.e Joins f.v,f.w,G2 by GLIB_006:70;
    end;
    :: in case edge is one of new edges
    suppose A37: not e in the_Edges_of G3;
      then A38: e in G1.edgesBetween(V1,{v1}) &
        (v = v1 & w in V1) or (v in V1 & w = v1) by A1, A18, A30, GLIB_007:51;
      A39: not e in dom F0_E by A37;
      e in dom F0_E \/ dom(h2*F0_V*(h1")) by A29, FUNCT_4:def 1;
      then A40: e in dom(h2*F0_V*(h1")) by A39, XBOOLE_0:def 3;
      then A41: e in dom(h1") & (h1").e in dom(h2*F0_V) by FUNCT_1:11;
      A42: g.e = (h2*F0_V*(h1")).e by A40, FUNCT_4:13
        .= (h2*F0_V).(h1".e) by A40, FUNCT_1:12
        .= h2.(F0_V.(h1".e)) by A41, FUNCT_1:12;
      e in rng h1 by A41, FUNCT_1:33;
      then A43: G1.edgesBetween(V1,{v1}) <> {};
      :: symmetric cases
      per cases by A38;
      suppose A44: v = v1 & w in V1;
        then v in {v1} by TARSKI:def 1;
        then A45: f.v = (v1 .--> v2).v by A5, FUNCT_4:13
          .= v2 by A44, FUNCOP_1:72;
        w <> v1 by A1, A44;
        then not w in dom(v1 .--> v2) by TARSKI:def 1;
        then A46: f.w = F0_V.w by FUNCT_4:11;
        consider e1 being object such that
          e1 in E1 & e1 Joins w,v1,G1 and
          A47: for e2 being object st e2 Joins w,v1,G1 holds e1 = e2
          by A44, A25;
        h1.w = e1 & e = e1 by A12, A30, A44, A47, GLIB_000:14;
        then A48: h1.w = e;
        w in dom h1 by A43, A44, FUNCT_2:def 1;
        then A49: g.e = h2.(F0_V.w) by A42, A48, FUNCT_1:34;
        A50: F0_V.w = (F0_V|V1).w by A44, FUNCT_1:49;
        w in dom(F0_V|V1) by A3, A44, RELAT_1:57;
        then h2.(F0_V.w) Joins F0_V.w,v2,G2 by A2, A14, A50, FUNCT_1:3;
        hence g.e Joins f.v,f.w,G2 by A45, A46, A49, GLIB_000:14;
      end;
      suppose A51: v in V1 & w = v1;
        then w in {v1} by TARSKI:def 1;
        then A52: f.w = (v1 .--> v2).w by A5, FUNCT_4:13
          .= v2 by A51, FUNCOP_1:72;
        v in the_Vertices_of G3 by A1, A51;
        then not v in {v1} by A1, TARSKI:def 1;
        then not v in dom(v1 .--> v2);
        then A53: f.v = F0_V.v by FUNCT_4:11;
        consider e1 being object such that
          e1 in E1 & e1 Joins v,v1,G1 and
          A54: for e2 being object st e2 Joins v,v1,G1 holds e1 = e2
          by A51, A25;
        h1.v = e1 & e = e1 by A12, A30, A51, A54;
        then A55: h1.v = e;
        v in dom h1 by A43, A51, FUNCT_2:def 1;
        then A56: g.e = h2.(F0_V.v) by A42, A55, FUNCT_1:34;
        A57: F0_V.v = (F0_V|V1).v by A51, FUNCT_1:49;
        v in dom(F0_V|V1) by A3, A51, RELAT_1:57;
        then h2.(F0_V.v) Joins F0_V.v,v2,G2 by A2, A14, A57, FUNCT_1:3;
        hence g.e Joins f.v,f.w,G2 by A52, A53, A56;
      end;
    end;
  end;
  then reconsider F = [f,g] as PGraphMapping of G1, G2 by Th8;
  take F;
  thus F_V = F0_V +* (v1 .--> v2);
  thus F_E | dom F0_E = F0_E by A19, FUNCT_4:33;
  thus A58: F0 is total implies F is total
  proof
    now
      let x be object;
      hereby
        assume x in dom(h2*F0_V*(h1"));
        then A59: x in dom(h1") & h1".x in dom(h2*F0_V) by FUNCT_1:11;
        A60: x in rng h1 by A59, FUNCT_1:33;
        then h1 <> {};
        then G1.edgesBetween(V1,{v1}) <> {};
        then A61: dom h1 = V1 by FUNCT_2:def 1;
        consider y being object such that
          A62: y in dom h1 & h1.y = x by A60, FUNCT_1:def 3;
        A63: x Joins y,v1,G1 by A12, A61, A62;
        v1 in {v1} by TARSKI:def 1;
        then x SJoins V1,{v1},G1 by A61, A62, A63, GLIB_000:17;
        hence x in G1.edgesBetween(V1,{v1}) by GLIB_000:def 30;
      end;
      set w1 = (the_Source_of G1).x, w2 = (the_Target_of G1).x;
      assume A64: x in G1.edgesBetween(V1,{v1});
      then G1.edgesBetween(V1,{v1}) <> {};
      then A65: dom h1 = V1 by FUNCT_2:def 1;
      A66: x SJoins V1,{v1},G1 by A64, GLIB_000:def 30;
      then per cases by GLIB_000:def 15;
      suppose A67: w1 in V1 & w2 in {v1};
        then consider e1 being object such that
          e1 in E1 & e1 Joins w1,v1,G1 and
          A68: for e2 being object st e2 Joins w1,v1,G1 holds e1 = e2 by A25;
        w2 = v1 & x in the_Edges_of G1
          by A66, A67, TARSKI:def 1, GLIB_000:def 15;
        then A69: x Joins w1,v1,G1 by GLIB_000:def 13;
        h1.w1 = e1 & x = e1 by A12, A67, A68, A69;
        then A70: h1.w1 = x;
        then x in rng h1 by A65, A67, FUNCT_1:3;
        then A71: x in dom(h1") by FUNCT_1:33;
        A72: w1 in dom F0_V by A3, A67;
        then A73: w1 in dom(F0_V|V1) by A67, RELAT_1:57;
        F0_V.w1 = (F0_V|V1).w1 by A67, FUNCT_1:49;
        then A74: F0_V.w1 in V2 by A2, A73, FUNCT_1:3;
        then A75: h2.(F0_V.w1) Joins F0_V.w1,v2,G2 by A14;
        v2 in {v2} by TARSKI:def 1;
        then h2.(F0_V.w1) SJoins V2,{v2},G2 by A74, A75, GLIB_000:17;
        then h2.(F0_V.w1) in G2.edgesBetween(V2,{v2}) by GLIB_000:def 30;
        then dom h2 = V2 by FUNCT_2:def 1;
        then A76: w1 in dom(h2*F0_V) by A72, A74, FUNCT_1:11;
        h1".x = w1 by A65, A67, A70, FUNCT_1:34;
        hence x in dom(h2*F0_V*(h1")) by A71, A76, FUNCT_1:11;
      end;
      suppose A77: w1 in {v1} & w2 in V1;
        then consider e1 being object such that
          e1 in E1 & e1 Joins w2,v1,G1 and
          A78: for e2 being object st e2 Joins w2,v1,G1 holds e1 = e2 by A25;
        w1 = v1 & x in the_Edges_of G1
          by A66, A77, TARSKI:def 1, GLIB_000:def 15;
        then A79: x Joins w2,v1,G1 by GLIB_000:def 13;
        h1.w2 = e1 & x = e1 by A12, A77, A78, A79;
        then A80: h1.w2 = x;
        then x in rng h1 by A65, A77, FUNCT_1:3;
        then A81: x in dom(h1") by FUNCT_1:33;
        A82: w2 in dom F0_V by A3, A77;
        then A83: w2 in dom(F0_V|V1) by A77, RELAT_1:57;
        F0_V.w2 = (F0_V|V1).w2 by A77, FUNCT_1:49;
        then A84: F0_V.w2 in V2 by A2, A83, FUNCT_1:3;
        then A85: h2.(F0_V.w2) Joins F0_V.w2,v2,G2 by A14;
        v2 in {v2} by TARSKI:def 1;
        then h2.(F0_V.w2) SJoins V2,{v2},G2 by A84, A85, GLIB_000:17;
        then G2.edgesBetween(V2,{v2}) <> {} by GLIB_000:def 30;
        then F0_V.w2 in dom h2 by A84, FUNCT_2:def 1;
        then A86: w2 in dom(h2*F0_V) by A82, FUNCT_1:11;
        h1".x = w2 by A65, A77, A80, FUNCT_1:34;
        hence x in dom(h2*F0_V*(h1")) by A81, A86, FUNCT_1:11;
      end;
    end;
    then A87: dom(h2*F0_V*(h1")) = G1.edgesBetween(V1,{v1}) by TARSKI:2;
    assume F0 is total;
    then A88: dom F0_V = the_Vertices_of G3 & dom F0_E = the_Edges_of G3;
    A89: dom F_V = dom F0_V \/ {v1} by A5, FUNCT_4:def 1
      .= the_Vertices_of G1 by A1, A88, GLIB_007:def 4;
    dom F_E = the_Edges_of G1 by A18, A87, A88, FUNCT_4:def 1;
    hence thesis by A89;
  end;
  thus A90: F0 is onto implies F is onto
  proof
    now
      let x be object;
      thus x in rng(h2*F0_V*(h1")) implies x in G2.edgesBetween(V2,{v2});
      set w1 = (the_Source_of G2).x, w2 = (the_Target_of G2).x;
      assume A91: x in G2.edgesBetween(V2,{v2});
      then A92: dom h2 = V2 by FUNCT_2:def 1;
      A93: x SJoins V2,{v2},G2 by A91, GLIB_000:def 30;
      then per cases by GLIB_000:def 15;
      suppose A94: w1 in V2 & w2 in {v2};
        then A95: h2.w1 Joins w1,v2,G2 by A14;
        consider e2 being object such that
          e2 in E2 & e2 Joins w1,v2,G2 and
          A96: for e9 being object st e9 Joins w1,v2,G2 holds e2 = e9
          by A94, A26;
        w2 = v2 & x in the_Edges_of G2
          by A93, A94, GLIB_000:def 15, TARSKI:def 1;
        then x Joins w1,v2,G2 by GLIB_000:def 13;
        then h2.w1 = e2 & x = e2 by A95, A96;
        then A97: h2.w1 = x;
        w1 in rng(F0_V|V1) by A2, A94;
        then consider z being object such that
          A98: z in dom(F0_V|V1) & (F0_V|V1).z = w1 by FUNCT_1:def 3;
        A99: z in V1 by A98;
        then A100: h1.z Joins z,v1,G1 by A12;
        v1 in {v1} by TARSKI:def 1;
        then h1.z SJoins V1,{v1},G1 by A99, A100, GLIB_000:17;
        then h1.z in G1.edgesBetween(V1,{v1}) by GLIB_000:def 30;
        then dom h1 = V1 by FUNCT_2:def 1;
        then z in rng(h1") by A99, FUNCT_1:33;
        then consider y being object such that
          A101: y in dom(h1") & h1".y = z by FUNCT_1:def 3;
        h1".y in V1 by A99, A101;
        then A102: y in dom(F0_V*(h1")) by A3, A101, FUNCT_1:11;
        then A103: (F0_V*(h1")).y = F0_V.z by A101, FUNCT_1:12
          .= w1 by A98, FUNCT_1:49;
        then A104: y in dom(h2*(F0_V*(h1"))) by A92, A94, A102, FUNCT_1:11;
        A105: (h2*F0_V*(h1")).y = (h2*(F0_V*(h1"))).y by RELAT_1:36
          .= x by A97, A103, A104, FUNCT_1:12;
        y in dom(h2*F0_V*(h1")) by A104, RELAT_1:36;
        hence x in rng(h2*F0_V*(h1")) by A105, FUNCT_1:3;
      end;
      suppose A106: w1 in {v2} & w2 in V2;
        then A107: h2.w2 Joins w2,v2,G2 by A14;
        consider e2 being object such that
          e2 in E2 & e2 Joins w2,v2,G2 and
          A108: for e9 being object st e9 Joins w2,v2,G2 holds e2 = e9
          by A106, A26;
        w1 = v2 & x in the_Edges_of G2
          by A93, A106, GLIB_000:def 15, TARSKI:def 1;
        then x Joins w2,v2,G2 by GLIB_000:def 13;
        then h2.w2 = e2 & x = e2 by A107, A108;
        then A109: h2.w2 = x;
        w2 in rng(F0_V|V1) by A2, A106;
        then consider z being object such that
          A110: z in dom(F0_V|V1) & (F0_V|V1).z = w2 by FUNCT_1:def 3;
        A111: z in V1 by A110;
        then A112: h1.z Joins z,v1,G1 by A12;
        v1 in {v1} by TARSKI:def 1;
        then h1.z SJoins V1,{v1},G1 by A111, A112, GLIB_000:17;
        then h1.z in G1.edgesBetween(V1,{v1}) by GLIB_000:def 30;
        then dom h1 = V1 by FUNCT_2:def 1;
        then z in rng(h1") by A111, FUNCT_1:33;
        then consider y being object such that
          A113: y in dom(h1") & h1".y = z by FUNCT_1:def 3;
        h1".y in V1 by A111, A113;
        then A114: y in dom(F0_V*(h1")) by A3, A113, FUNCT_1:11;
        then A115: (F0_V*(h1")).y = F0_V.z by A113, FUNCT_1:12
          .= w2 by A110, FUNCT_1:49;
        then A116: y in dom(h2*(F0_V*(h1"))) by A92, A106, A114, FUNCT_1:11;
        A117: (h2*F0_V*(h1")).y = (h2*(F0_V*(h1"))).y by RELAT_1:36
          .= x by A109, A115, A116, FUNCT_1:12;
        y in dom(h2*F0_V*(h1")) by A116, RELAT_1:36;
        hence x in rng(h2*F0_V*(h1")) by A117, FUNCT_1:3;
      end;
    end;
    then A118: rng(h2*F0_V*(h1")) = G2.edgesBetween(V2,{v2}) by TARSKI:2;
    assume F0 is onto;
    then A119: rng F0_V = the_Vertices_of G4 & rng F0_E = the_Edges_of G4;
    A120: v1 is set & v2 is set by TARSKI:1;
    A121: rng F_V = rng F0_V \/ rng(v1 .--> v2) by A7, NECKLACE:6
      .= the_Vertices_of G4 \/ {v2} by A119, A120, FUNCOP_1:88
      .= the_Vertices_of G2 by A1, GLIB_007:def 4;
    rng F_E = rng F0_E \/ rng(h2*F0_V*(h1")) by A19, NECKLACE:6
      .= the_Edges_of G2 by A1, A118, A119, GLIB_007:59;
    hence thesis by A121;
  end;
  thus A122: F0 is one-to-one implies F is one-to-one
    by A9, A13, A22, FUNCT_4:92;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A58, A122;
  thus F0 is isomorphism implies F is isomorphism by A58, A90, A122;
end;

theorem
  for G3 being _Graph, G4 being G3-isomorphic _Graph, v1, v2 being object
  for G1 being addAdjVertexAll of G3,v1
  for G2 being addAdjVertexAll of G4,v2
  st v1 in the_Vertices_of G3 iff v2 in the_Vertices_of G4
  holds G2 is G1-isomorphic
proof
  let G3 be _Graph, G4 be G3-isomorphic _Graph, v1, v2 be object;
  let G1 be addAdjVertexAll of G3, v1;
  let G2 be addAdjVertexAll of G4, v2;
  assume v1 in the_Vertices_of G3 iff v2 in the_Vertices_of G4;
  then per cases;
  suppose A1: not v1 in the_Vertices_of G3 & not v2 in the_Vertices_of G4;
    consider F0 being PGraphMapping of G3, G4 such that
      A2: F0 is isomorphism by Def23;
    A3: F0_V | the_Vertices_of G3 is one-to-one by A2;
    A4: dom(F0_V | the_Vertices_of G3) = the_Vertices_of G3 by A2, Def11;
    rng(F0_V | the_Vertices_of G3) = the_Vertices_of G4 by A2, Def12;
    then consider F being PGraphMapping of G1, G2 such that
      F_V = F0_V +* (v1 .--> v2) & F_E | dom F0_E = F0_E and
      F0 is total implies F is total and
      F0 is onto implies F is onto and
      F0 is one-to-one implies F is one-to-one and
      F0 is weak_SG-embedding implies F is weak_SG-embedding and
      A5: F0 is isomorphism implies F is isomorphism by A1, A3, A4, Th162;
    thus thesis by A2, A5;
  end;
  suppose v1 in the_Vertices_of G3 & v2 in the_Vertices_of G4;
    then G1 == G3 & G2 == G4 by GLIB_007:def 4;
    then G1 is reverseEdgeDirections of G3, {} &
      G2 is reverseEdgeDirections of G4, {} by GLIB_009:42;
    hence thesis by Th143;
  end;
end;

theorem Th164:
  for G1, G2 being _Graph
  for G3 being removeLoops of G1, G4 being removeLoops of G2
  for F0 being one-to-one PGraphMapping of G1, G2
  ex F being one-to-one PGraphMapping of G3, G4
  st F = F0 | G3 &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is directed implies F is directed) &
    :: F0 and F are automatically semi-continuous
    (F0 is semi-Dcontinuous implies F is semi-Dcontinuous)
proof
  let G1, G2 be _Graph, G3 be removeLoops of G1, G4 be removeLoops of G2;
  let F0 be one-to-one PGraphMapping of G1, G2;
  reconsider F = G4 |` (F0 | G3) as one-to-one PGraphMapping of G3, G4;
  take F;
  A1: F_V = (the_Vertices_of G2) |` (F0 | G3)_V by GLIB_000:def 33
    .= (F0 | G3)_V;
  now
    let y be object;
    assume A2: y in rng (F0 | G3)_E;
    not y in G2.loops()
    proof
      consider x being object such that
        A3: x in dom(F0_E|(the_Edges_of G3)) & (F0_E|(the_Edges_of G3)).x = y
        by A2, FUNCT_1:def 3;
      A4: x in dom F0_E & x in the_Edges_of G3 by A3, RELAT_1:57;
      set v = (the_Source_of G1).x, w = (the_Target_of G1).x;
      A5: v in dom F0_V & w in dom F0_V by A4, Th5;
      A6: x Joins v,w,G1 & F0_E.x = y by A3, A4, GLIB_000:def 13, FUNCT_1:49;
      then A7: y Joins F0_V.v,F0_V.w,G2 by A4, A5, Th4;
      x in the_Edges_of G1 \ G1.loops() by A4, GLIB_000:53;
      then not x in G1.loops() by XBOOLE_0:def 5;
      then v <> w by A6, GLIB_009:def 2;
      then A8: F0_V.v <> F0_V.w by A5, FUNCT_1:def 4;
      for u being object holds not y Joins u,u,G2
      proof
        given u being object such that
          A9: y Joins u,u,G2;
        F0_V.v = u & F0_V.w = u by A7, A9, GLIB_000:15;
        hence contradiction by A8;
      end;
      hence thesis by GLIB_009:def 2;
    end;
    then y in the_Edges_of G2 \ G2.loops() by A2, XBOOLE_0:def 5;
    hence y in the_Edges_of G4 by GLIB_000:53;
  end;
  then A10: rng (F0 | G3)_E c= the_Edges_of G4 by TARSKI:def 3;
  F_E = (F0 | G3)_E by A10, RELAT_1:94;
  hence A11: F = F0 | G3 by A1, XTUPLE_0:2;
  thus F0 is total implies F is total
  proof
    assume F0 is total;
    then F0 | G3 is total by Th57;
    hence thesis by A11;
  end;
  thus F0 is onto implies F is onto
  proof
    assume F0 is onto;
    then A12: rng F0_V = the_Vertices_of G2 & rng F0_E = the_Edges_of G2;
    A13: rng F_V = rng (F0 | G3)_V by A1
      .= rng(F0_V|the_Vertices_of G1) by GLIB_000:def 33
      .= the_Vertices_of G4 by A12, GLIB_000:def 33;
    now
      let y be object;
      assume y in the_Edges_of G4;
      then y in the_Edges_of G2 \ G2.loops() by GLIB_000:53;
      then A14: y in rng F0_E & not y in G2.loops() by A12, XBOOLE_0:def 5;
      set w1 = (the_Source_of G2).y, w2 = (the_Target_of G2).y;
      w1 in rng F0_V by A14, Th6;
      then consider v1 being object such that
        A15: v1 in dom F0_V & F0_V.v1 = w1 by FUNCT_1:def 3;
      w2 in rng F0_V by A14, Th6;
      then consider v2 being object such that
        A16: v2 in dom F0_V & F0_V.v2 = w2 by FUNCT_1:def 3;
      consider x being object such that
        A17: x in dom F0_E & F0_E.x = y by A14, FUNCT_1:def 3;
      A18: y Joins w1,w2,G2 by A14, GLIB_000:def 13;
      then A19: x Joins v1,v2,G1 by A15, A16, A17, Def15;
      A20: v1 <> v2 by A14, A15, A16, A18, GLIB_009:def 2;
      for u being object holds not x Joins u,u,G1
      proof
        let u be object;
        assume x Joins u,u,G1;
        then v1 = u & v2 = u by A19, GLIB_000:15;
        hence contradiction by A20;
      end;
      then not x in G1.loops() by GLIB_009:def 2;
      then x in the_Edges_of G1 \ G1.loops() by A17, XBOOLE_0:def 5;
      then x in the_Edges_of G3 by GLIB_000:53;
      then A21: x in dom (F0 | G3)_E by A17, RELAT_1:57;
      then (F0 | G3)_E.x = y by A17, FUNCT_1:47;
      hence y in rng (F0 | G3)_E by A21, FUNCT_1:3;
    end;
    then the_Edges_of G4 c= rng (F0 | G3)_E by TARSKI:def 3;
    then the_Edges_of G4 = rng F_E by A11, XBOOLE_0:def 10;
    hence thesis by A13;
  end;
  thus F0 is directed implies F is directed;
  thus F0 is semi-Dcontinuous implies F is semi-Dcontinuous;
end;

theorem Th165:
  for G1, G2 being _Graph
  for G3 being removeLoops of G1, G4 being removeLoops of G2
  for F0 being one-to-one PGraphMapping of G1, G2
  ex F being one-to-one PGraphMapping of G3, G4
  st F = F0 | G3 &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism) &
    (F0 is Disomorphism implies F is Disomorphism)
proof
  let G1, G2 be _Graph, G3 be removeLoops of G1, G4 be removeLoops of G2;
  let F0 be one-to-one PGraphMapping of G1, G2;
  consider F being one-to-one PGraphMapping of G3, G4 such that
    A1: F = F0 | G3 and
    A2: F0 is total implies F is total and
    A3: F0 is onto implies F is onto and
    A4: F0 is directed implies F is directed and
    F0 is semi-Dcontinuous implies F is semi-Dcontinuous by Th164;
  take F;
  thus F = F0 | G3 by A1;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A2;
  thus F0 is isomorphism implies F is isomorphism by A2, A3;
  thus F0 is Disomorphism implies F is Disomorphism by A2, A3, A4;
end;

theorem Th166:
  for G1 being _Graph, G2 being G1-isomorphic _Graph
  for G3 being removeLoops of G1, G4 being removeLoops of G2
  holds G4 is G3-isomorphic
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  let G3 be removeLoops of G1, G4 be removeLoops of G2;
  consider F0 being PGraphMapping of G1, G2 such that
    A1: F0 is isomorphism by Def23;
  reconsider F0 as one-to-one PGraphMapping of G1, G2 by A1;
  consider F being one-to-one PGraphMapping of G3, G4 such that
    F = F0 | G3 and
    F0 is weak_SG-embedding implies F is weak_SG-embedding and
    A2: F0 is isomorphism implies F is isomorphism and
    F0 is Disomorphism implies F is Disomorphism by Th165;
  thus thesis by A1, A2;
end;

theorem Th167:
  for G1 being _Graph, G2 being G1-Disomorphic _Graph
  for G3 being removeLoops of G1, G4 being removeLoops of G2
  holds G4 is G3-Disomorphic
proof
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  let G3 be removeLoops of G1, G4 be removeLoops of G2;
  consider F0 being PGraphMapping of G1, G2 such that
    A1: F0 is Disomorphism by Def24;
  reconsider F0 as one-to-one PGraphMapping of G1, G2 by A1;
  consider F being one-to-one PGraphMapping of G3, G4 such that
    F = F0 | G3 and
    F0 is weak_SG-embedding implies F is weak_SG-embedding and
    F0 is isomorphism implies F is isomorphism and
    A2: F0 is Disomorphism implies F is Disomorphism by Th165;
  thus thesis by A1, A2;
end;

theorem Th168:
  for G1 being _Graph, G2 being G1-isomorphic _Graph
  for G3 being removeParallelEdges of G1
  for G4 being removeParallelEdges of G2
  holds G4 is G3-isomorphic
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  let G3 be removeParallelEdges of G1;
  let G4 be removeParallelEdges of G2;
  consider G being PGraphMapping of G1, G2 such that
    A1: G is isomorphism by Def23;
  consider E1 being RepEdgeSelection of G1 such that
    A2: G3 is inducedSubgraph of G1, the_Vertices_of G1, E1 by GLIB_009:def 7;
  consider E2 being RepEdgeSelection of G2 such that
    A3: G4 is inducedSubgraph of G2, the_Vertices_of G2, E2 by GLIB_009:def 7;
  A4: G1.edgesBetween(the_Vertices_of G1) = the_Edges_of G1 &
    G2.edgesBetween(the_Vertices_of G2) = the_Edges_of G2 by GLIB_000:34;
  the_Vertices_of G1 c= the_Vertices_of G1 &
    the_Vertices_of G2 c= the_Vertices_of G2;
  then A5: the_Edges_of G3 = E1 & the_Edges_of G4 = E2
    by A2, A3, A4, GLIB_000:def 37;
  :: define F_V
  A6: the_Vertices_of G3 = the_Vertices_of G1 &
    the_Vertices_of G4 = the_Vertices_of G2 by GLIB_000:def 33;
  then reconsider f=G_V as PartFunc of the_Vertices_of G3, the_Vertices_of G4;
  :: define the surjection h from E(G2) to E2
  defpred P[object,object] means $2 in E2 & [$1,$2] in EdgeAdjEqRel(G2);
  A7: for x,y1,y2 being object st x in the_Edges_of G2 & P[x,y1] & P[x,y2]
    holds y1 = y2
  proof
    let x,y1,y2 be object;
    set v1=(the_Source_of G2).x, v2=(the_Target_of G2).x;
    assume x in the_Edges_of G2;
    then A8: x Joins v1,v2,G2 by GLIB_000:def 13;
    then consider e being object such that
      e Joins v1,v2,G2 & e in E2 and
      A9: for e9 being object st e9 Joins v1,v2,G2 & e9 in E2 holds e9 = e
      by GLIB_009:def 5;
    assume A10: P[x,y1];
    then consider w1,w2 being object such that
      A11: x Joins w1,w2,G2 & y1 Joins w1,w2,G2 by GLIB_009:def 3;
    w1 = v1 & w2 = v2 or w1 = v2 & w2 = v1 by A8, A11, GLIB_000:15;
    then A12: y1 = e by A9, A10, A11, GLIB_000:14;
    assume A13: P[x,y2];
    then consider u1,u2 being object such that
      A14: x Joins u1,u2,G2 & y2 Joins u1,u2,G2 by GLIB_009:def 3;
    u1 = v1 & u2 = v2 or u1 = v2 & u2 = v1 by A8, A14, GLIB_000:15;
    then y2 Joins v1,v2,G2 by A14, GLIB_000:14;
    hence y1 = y2 by A9, A12, A13;
  end;
  A15: for x being object st x in the_Edges_of G2 ex y being object st P[x,y]
  proof
    let x be object;
    set v1=(the_Source_of G2).x, v2=(the_Target_of G2).x;
    assume x in the_Edges_of G2;
    then A16: x Joins v1,v2,G2 by GLIB_000:def 13;
    then consider e being object such that
      A17: e Joins v1,v2,G2 & e in E2 and
      for e9 being object st e9 Joins v1,v2,G2 & e9 in E2 holds e9 = e
      by GLIB_009:def 5;
    take e;
    thus thesis by A16, A17, GLIB_009:def 3;
  end;
  consider h being Function such that
    A18: dom h = the_Edges_of G2 and
    A19: for x being object st x in the_Edges_of G2 holds P[x,h.x]
    from FUNCT_1:sch 2(A7,A15);
  :: define F_E
  set g = (h*G_E)|E1;
  dom h = rng G_E by A1, A18, Def12;
  then A20: dom(h*G_E) = dom G_E & rng(h*G_E) = rng h by RELAT_1:27, 28;
  then A21: dom g = dom G_E /\ E1 by RELAT_1:61
    .= the_Edges_of G1 /\ E1 by A1, Def11
    .= E1 by XBOOLE_1:28;
  now
    let y be object;
    hereby
      assume y in rng g;
      then y in rng h by A20, RELAT_1:70, TARSKI:def 3;
      then consider x being object such that
        A22: x in dom h & y = h.x by FUNCT_1:def 3;
      thus y in E2 by A18, A19, A22;
    end;
    assume A23: y in E2;
    then A24: y in the_Edges_of G2;
    set v1 = (the_Source_of G2).y, v2 = (the_Target_of G2).y;
    A25: y Joins v1,v2,G2 by A24, GLIB_000:def 13;
    then consider e being object such that
      e Joins v1,v2,G2 & e in E2 and
      A26: for e9 being object st e9 Joins v1,v2,G2 & e9 in E2 holds e9 = e
      by GLIB_009:def 5;
    y in rng G_E by A1, A24, Def12;
    then consider x0 being object such that
      A27: x0 in dom G_E & G_E.x0 = y by FUNCT_1:def 3;
    set u1 = (the_Source_of G1).x0, u2 = (the_Target_of G1).x0;
    A28: u1 in dom G_V & u2 in dom G_V by A27, Th5;
    A29: x0 Joins u1,u2,G1 by A27, GLIB_000:def 13;
    then consider x being object such that
      A30: x Joins u1,u2,G1 & x in E1 and
      for e9 being object st e9 Joins u1,u2,G1 & e9 in E1 holds e9 = x
      by GLIB_009:def 5;
    x in the_Edges_of G1 by A30;
    then A31: x in dom G_E by A1, Def11;
    then A32: G_E.x Joins G_V.u1,G_V.u2,G2 by A28, A30, Th4;
    G_E.x0 Joins G_V.u1,G_V.u2,G2 by A27, A28, A29, Th4;
    then G_V.u1 = v1 & G_V.u2 = v2 or G_V.u1 = v2 & G_V.u2 = v1
      by A25, A27, GLIB_000:15;
    then A33: G_E.x Joins v1,v2,G2 by A32, GLIB_000:14;
    A34: G_E.x in the_Edges_of G2 by A33, GLIB_000:def 13;
    then A35: h.(G_E.x) in E2 & [G_E.x,h.(G_E.x)] in EdgeAdjEqRel(G2) by A19;
    then consider w1,w2 being object such that
      A36: G_E.x Joins w1,w2,G2 & h.(G_E.x) Joins w1,w2,G2 by GLIB_009:def 3;
    v1 = w1 & v2 = w2 or v1 = w2 & v2 = w1 by A33, A36, GLIB_000:15;
    then A37: y = e & h.(G_E.x) = e by A23, A25, A26, A35, A36, GLIB_000:14;
    A38: x in dom(h*G_E) by A18, A31, A34, FUNCT_1:11;
    then A39: x in dom g by A30, RELAT_1:57;
    y = (h*G_E).x by A37, A38, FUNCT_1:12
      .= g.x by A30, FUNCT_1:49;
    hence y in rng g by A39, FUNCT_1:def 3;
  end;
  then A40: rng g = E2 by TARSKI:2;
  then reconsider g as PartFunc of the_Edges_of G3, the_Edges_of G4
    by A5, A21, RELSET_1:4;
  :: define F
  now
    hereby
      let e be object;
      set v = (the_Source_of G3).e, w = (the_Target_of G3).e;
      assume e in dom g;
      then e Joins v,w,G3 by GLIB_000:def 13;
      then v in the_Vertices_of G3 & w in the_Vertices_of G3 by GLIB_000:13;
      then v in the_Vertices_of G1 & w in the_Vertices_of G1;
      hence v in dom f & w in dom f by A1, Def11;
    end;
    let e,v,w be object;
    assume A41: e in dom g & v in dom f & w in dom f;
    then A42: e in E1 & e in dom(h*G_E) by RELAT_1:57;
    then A43: e in dom G_E & G_E.e in dom h by FUNCT_1:11;
    assume A44: e Joins v,w,G3;
    v is set & w is set by TARSKI:1;
    then e Joins v,w,G1 by A44, GLIB_000:72;
    then A45: G_E.e Joins f.v,f.w,G2 by A41, A43, Th4;
    A46: h.(G_E.e) in E2 & [G_E.e,h.(G_E.e)] in EdgeAdjEqRel(G2)
      by A18, A19, A43;
    then consider u1,u2 being object such that
      A47: G_E.e Joins u1,u2,G2 & h.(G_E.e) Joins u1,u2,G2 by GLIB_009:def 3;
    h.(G_E.e) Joins f.v,f.w,G2
    proof
      per cases by A45, A47, GLIB_000:15;
      suppose f.v=u1 & f.w=u2;
        hence thesis by A47;
      end;
      suppose f.v=u2 & f.w=u1;
        hence thesis by A47, GLIB_000:14;
      end;
    end;
    then A48: h.(G_E.e) Joins f.v,f.w,G4 by A5, A46, GLIB_000:73;
    g.e = (h*G_E).e by A42, FUNCT_1:49
      .= h.(G_E.e) by A42, FUNCT_1:12;
    hence g.e Joins f.v,f.w,G4 by A48;
  end;
  then reconsider F = [f,g] as PGraphMapping of G3, G4 by Th8;
  :: show that F is isomorphism
  dom f = the_Vertices_of G3 by A1, A6, Def11;
  then A49: F is total by A5, A21;
  rng f = the_Vertices_of G4 by A1, A6, Def12;
  then A50: F is onto by A5, A40;
  now
    let x1,x2 be object;
    assume A51: x1 in dom g & x2 in dom g & g.x1 = g.x2;
    then A52: x1 in E1 & x1 in dom(h*G_E) & x2 in E1 & x2 in dom(h*G_E)
      by RELAT_1:57;
    then A53: x1 in dom G_E & G_E.x1 in dom h & x2 in dom G_E & G_E.x2 in dom h
      by FUNCT_1:11;
    then A54: h.(G_E.x1) in E2 & [G_E.x1,h.(G_E.x1)] in EdgeAdjEqRel(G2) &
      [G_E.x2,h.(G_E.x2)] in EdgeAdjEqRel(G2) by A18, A19;
    then consider v1,v2 being object such that
      A55: G_E.x1 Joins v1,v2,G2 & h.(G_E.x1) Joins v1,v2,G2 by GLIB_009:def 3;
    G_E.x1 in rng G_E by A53, FUNCT_1:3;
    then (the_Source_of G2).(G_E.x1) in rng G_V &
      (the_Target_of G2).(G_E.x1) in rng G_V by Th6;
    then A56: v1 in rng G_V & v2 in rng G_V by A55, GLIB_000:def 13;
    then consider u1 being object such that
      A57: u1 in dom G_V & G_V.u1 = v1 by FUNCT_1:def 3;
    consider u2 being object such that
      A58: u2 in dom G_V & G_V.u2 = v2 by A56, FUNCT_1:def 3;
    A59: x1 Joins u1,u2,G1 by A1, A53, A55, A57, A58, Def15;
    h.(G_E.x1) = (h*G_E).x1 by A52, FUNCT_1:12
      .= g.x2 by A51, A52, FUNCT_1:49
      .= (h*G_E).x2 by A52, FUNCT_1:49
      .= h.(G_E.x2) by A52, FUNCT_1:12;
    then consider w1,w2 being object such that
      A60: G_E.x2 Joins w1,w2,G2 & h.(G_E.x1) Joins w1,w2,G2
      by A54, GLIB_009:def 3;
    G_E.x2 Joins v1,v2,G2
    proof
      per cases by A55, A60, GLIB_000:15;
      suppose v1 = w1 & v2 = w2;
        hence thesis by A60;
      end;
      suppose v1 = w2 & v2 = w1;
        hence thesis by A60, GLIB_000:14;
      end;
    end;
    then A61: x2 Joins u1,u2,G1 by A1, A53, A57, A58, Def15;
    then consider e being object such that
      e Joins u1,u2,G1 & e in E1 and
      A62: for e9 being object st e9 Joins u1,u2,G1 & e9 in E1 holds e9 = e
      by GLIB_009:def 5;
    x1 = e & x2 = e by A52, A59, A61, A62;
    hence x1 = x2;
  end;
  then F is one-to-one by A1, FUNCT_1:def 4;
  hence thesis by A49, A50;
end;

theorem
  for G1 being _Graph, G2, G3 being removeParallelEdges of G1
  holds G3 is G2-isomorphic
proof
  let G1 be _Graph, G2, G3 be removeParallelEdges of G1;
  G1 is G1-isomorphic by Th53;
  hence thesis by Th168;
end;

theorem Th170:
  for G1 being _Graph, G2 being G1-Disomorphic _Graph
  for G3 being removeDParallelEdges of G1
  for G4 being removeDParallelEdges of G2
  holds G4 is G3-Disomorphic
proof
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  let G3 be removeDParallelEdges of G1;
  let G4 be removeDParallelEdges of G2;
  consider G being PGraphMapping of G1, G2 such that
    A1: G is Disomorphism by Def24;
  reconsider G as directed PGraphMapping of G1, G2 by A1;
  consider E1 being RepDEdgeSelection of G1 such that
    A2: G3 is inducedSubgraph of G1, the_Vertices_of G1, E1 by GLIB_009:def 8;
  consider E2 being RepDEdgeSelection of G2 such that
    A3: G4 is inducedSubgraph of G2, the_Vertices_of G2, E2 by GLIB_009:def 8;
  A4: G1.edgesBetween(the_Vertices_of G1) = the_Edges_of G1 &
    G2.edgesBetween(the_Vertices_of G2) = the_Edges_of G2 by GLIB_000:34;
  the_Vertices_of G1 c= the_Vertices_of G1 &
    the_Vertices_of G2 c= the_Vertices_of G2;
  then A5: the_Edges_of G3 = E1 & the_Edges_of G4 = E2
    by A2, A3, A4, GLIB_000:def 37;
  :: define F_V
  A6: the_Vertices_of G3 = the_Vertices_of G1 &
    the_Vertices_of G4 = the_Vertices_of G2 by GLIB_000:def 33;
  then reconsider f=G_V as PartFunc of the_Vertices_of G3, the_Vertices_of G4;
  :: define the surjection h from E(G2) to E2
  defpred P[object,object] means $2 in E2 & [$1,$2] in DEdgeAdjEqRel(G2);
  A7: for x,y1,y2 being object st x in the_Edges_of G2 & P[x,y1] & P[x,y2]
    holds y1 = y2
  proof
    let x,y1,y2 be object;
    set v1=(the_Source_of G2).x, v2=(the_Target_of G2).x;
    assume x in the_Edges_of G2;
    then A8: x DJoins v1,v2,G2 by GLIB_000:def 14;
    then consider e being object such that
      e DJoins v1,v2,G2 & e in E2 and
      A9: for e9 being object st e9 DJoins v1,v2,G2 & e9 in E2 holds e9 = e
      by GLIB_009:def 6;
    assume A10: P[x,y1];
    then consider w1,w2 being object such that
      A11: x DJoins w1,w2,G2 & y1 DJoins w1,w2,G2 by GLIB_009:def 4;
    w1 = v1 & w2 = v2 by A8, A11, GLIB_009:6;
    then A12: y1 = e by A9, A10, A11;
    assume A13: P[x,y2];
    then consider u1,u2 being object such that
      A14: x DJoins u1,u2,G2 & y2 DJoins u1,u2,G2 by GLIB_009:def 4;
    u1 = v1 & u2 = v2 by A8, A14, GLIB_009:6;
    then y2 DJoins v1,v2,G2 by A14;
    hence y1 = y2 by A9, A12, A13;
  end;
  A15: for x being object st x in the_Edges_of G2 ex y being object st P[x,y]
  proof
    let x be object;
    set v1=(the_Source_of G2).x, v2=(the_Target_of G2).x;
    assume x in the_Edges_of G2;
    then A16: x DJoins v1,v2,G2 by GLIB_000:def 14;
    then consider e being object such that
      A17: e DJoins v1,v2,G2 & e in E2 and
      for e9 being object st e9 DJoins v1,v2,G2 & e9 in E2 holds e9 = e
      by GLIB_009:def 6;
    take e;
    thus thesis by A16, A17, GLIB_009:def 4;
  end;
  consider h being Function such that
    A18: dom h = the_Edges_of G2 and
    A19: for x being object st x in the_Edges_of G2 holds P[x,h.x]
    from FUNCT_1:sch 2(A7,A15);
  :: define F_E
  set g = (h*G_E)|E1;
  dom h = rng G_E by A1, A18, Def12;
  then A20: dom(h*G_E) = dom G_E & rng(h*G_E) = rng h by RELAT_1:27, 28;
  then A21: dom g = dom G_E /\ E1 by RELAT_1:61
    .= the_Edges_of G1 /\ E1 by A1, Def11
    .= E1 by XBOOLE_1:28;
  now
    let y be object;
    hereby
      assume y in rng g;
      then y in rng h by A20, RELAT_1:70, TARSKI:def 3;
      then consider x being object such that
        A22: x in dom h & y = h.x by FUNCT_1:def 3;
      thus y in E2 by A18, A19, A22;
    end;
    assume A23: y in E2;
    then A24: y in the_Edges_of G2;
    set v1 = (the_Source_of G2).y, v2 = (the_Target_of G2).y;
    A25: y DJoins v1,v2,G2 by A24, GLIB_000:def 14;
    then consider e being object such that
      e DJoins v1,v2,G2 & e in E2 and
      A26: for e9 being object st e9 DJoins v1,v2,G2 & e9 in E2 holds e9 = e
      by GLIB_009:def 6;
    y in rng G_E by A1, A24, Def12;
    then consider x0 being object such that
      A27: x0 in dom G_E & G_E.x0 = y by FUNCT_1:def 3;
    set u1 = (the_Source_of G1).x0, u2 = (the_Target_of G1).x0;
    A28: u1 in dom G_V & u2 in dom G_V by A27, Th5;
    A29: x0 DJoins u1,u2,G1 by A27, GLIB_000:def 14;
    then consider x being object such that
      A30: x DJoins u1,u2,G1 & x in E1 and
      for e9 being object st e9 DJoins u1,u2,G1 & e9 in E1 holds e9 = x
      by GLIB_009:def 6;
    x in the_Edges_of G1 by A30;
    then A31: x in dom G_E by A1, Def11;
    then A32: G_E.x DJoins G_V.u1,G_V.u2,G2 by A28, A30, Def14;
    G_E.x0 DJoins G_V.u1,G_V.u2,G2 by A27, A28, A29, Def14;
    then G_V.u1 = v1 & G_V.u2 = v2 by A25, A27, GLIB_009:6;
    then A33: G_E.x DJoins v1,v2,G2 by A32;
    A34: G_E.x in the_Edges_of G2 by A33, GLIB_000:def 14;
    then A35: h.(G_E.x) in E2 & [G_E.x,h.(G_E.x)] in DEdgeAdjEqRel(G2) by A19;
    then consider w1,w2 being object such that
      A36: G_E.x DJoins w1,w2,G2 & h.(G_E.x) DJoins w1,w2,G2 by GLIB_009:def 4;
    v1 = w1 & v2 = w2 by A33, A36, GLIB_009:6;
    then A37: y = e & h.(G_E.x) = e by A23, A25, A26, A35, A36;
    A38: x in dom(h*G_E) by A18, A31, A34, FUNCT_1:11;
    then A39: x in dom g by A30, RELAT_1:57;
    y = (h*G_E).x by A37, A38, FUNCT_1:12
      .= g.x by A30, FUNCT_1:49;
    hence y in rng g by A39, FUNCT_1:def 3;
  end;
  then A40: rng g = E2 by TARSKI:2;
  then reconsider g as PartFunc of the_Edges_of G3, the_Edges_of G4
    by A5, A21, RELSET_1:4;
  :: define F
  now
    hereby
      let e be object;
      set v = (the_Source_of G3).e, w = (the_Target_of G3).e;
      assume e in dom g;
      then e Joins v,w,G3 by GLIB_000:def 13;
      then v in the_Vertices_of G3 & w in the_Vertices_of G3 by GLIB_000:13;
      then v in the_Vertices_of G1 & w in the_Vertices_of G1;
      hence v in dom f & w in dom f by A1, Def11;
    end;
    let e,v,w be object;
    assume A41: e in dom g & v in dom f & w in dom f;
    then A42: e in E1 & e in dom(h*G_E) by RELAT_1:57;
    then A43: e in dom G_E & G_E.e in dom h by FUNCT_1:11;
    assume A44: e DJoins v,w,G3;
    v is set & w is set by TARSKI:1;
    then e DJoins v,w,G1 by A44, GLIB_000:72;
    then A45: G_E.e DJoins f.v,f.w,G2 by A41, A43, Def14;
    A46: h.(G_E.e) in E2 & [G_E.e,h.(G_E.e)] in DEdgeAdjEqRel(G2)
      by A18, A19, A43;
    then consider u1,u2 being object such that
      A47: G_E.e DJoins u1,u2,G2 & h.(G_E.e) DJoins u1,u2,G2 by GLIB_009:def 4;
    u1 = f.v & u2 = f.w by A45, A47, GLIB_009:6;
    then h.(G_E.e) DJoins f.v,f.w,G2 by A47;
    then A48: h.(G_E.e) DJoins f.v,f.w,G4 by A5, A46, GLIB_000:73;
    g.e = (h*G_E).e by A42, FUNCT_1:49
      .= h.(G_E.e) by A42, FUNCT_1:12;
    hence g.e DJoins f.v,f.w,G4 by A48;
  end;
  then reconsider F = [f,g] as directed PGraphMapping of G3, G4 by Th30;
  :: show that F is Disomorphism
  dom f = the_Vertices_of G3 by A1, A6, Def11;
  then A49: F is total by A5, A21;
  rng f = the_Vertices_of G4 by A1, A6, Def12;
  then A50: F is onto by A5, A40;
  now
    let x1,x2 be object;
    assume A51: x1 in dom g & x2 in dom g & g.x1 = g.x2;
    then A52: x1 in E1 & x1 in dom(h*G_E) & x2 in E1 & x2 in dom(h*G_E)
      by RELAT_1:57;
    then A53: x1 in dom G_E & G_E.x1 in dom h & x2 in dom G_E & G_E.x2 in dom h
      by FUNCT_1:11;
    then A54: h.(G_E.x1) in E2 & [G_E.x1,h.(G_E.x1)] in DEdgeAdjEqRel(G2) &
      [G_E.x2,h.(G_E.x2)] in DEdgeAdjEqRel(G2) by A18, A19;
    then consider v1,v2 being object such that
      A55: G_E.x1 DJoins v1,v2,G2 & h.(G_E.x1) DJoins v1,v2,G2
      by GLIB_009:def 4;
    G_E.x1 in rng G_E by A53, FUNCT_1:3;
    then (the_Source_of G2).(G_E.x1) in rng G_V &
      (the_Target_of G2).(G_E.x1) in rng G_V by Th6;
    then A56: v1 in rng G_V & v2 in rng G_V by A55, GLIB_000:def 14;
    then consider u1 being object such that
      A57: u1 in dom G_V & G_V.u1 = v1 by FUNCT_1:def 3;
    consider u2 being object such that
      A58: u2 in dom G_V & G_V.u2 = v2 by A56, FUNCT_1:def 3;
    A59: x1 DJoins u1,u2,G1 by A1, A53, A55, A57, A58, Def17;
    h.(G_E.x1) = (h*G_E).x1 by A52, FUNCT_1:12
      .= g.x2 by A51, A52, FUNCT_1:49
      .= (h*G_E).x2 by A52, FUNCT_1:49
      .= h.(G_E.x2) by A52, FUNCT_1:12;
    then consider w1,w2 being object such that
      A60: G_E.x2 DJoins w1,w2,G2 & h.(G_E.x1) DJoins w1,w2,G2
      by A54, GLIB_009:def 4;
    v1 = w1 & v2 = w2 by A55, A60, GLIB_009:6;
    then G_E.x2 DJoins v1,v2,G2 by A60;
    then A61: x2 DJoins u1,u2,G1 by A1, A53, A57, A58, Def17;
    then consider e being object such that
      e DJoins u1,u2,G1 & e in E1 and
      A62: for e9 being object st e9 DJoins u1,u2,G1 & e9 in E1 holds e9 = e
      by GLIB_009:def 6;
    x1 = e & x2 = e by A52, A59, A61, A62;
    hence x1 = x2;
  end;
  then F is one-to-one by A1, FUNCT_1:def 4;
  hence thesis by A49, A50;
end;

theorem
  for G1 being _Graph, G2, G3 being removeDParallelEdges of G1
  holds G3 is G2-Disomorphic
proof
  let G1 be _Graph, G2, G3 be removeDParallelEdges of G1;
  G1 is G1-Disomorphic by Th53;
  hence thesis by Th170;
end;

theorem Th172:
  for G1 being _Graph, G2 being G1-isomorphic _Graph
  for G3 being SimpleGraph of G1, G4 being SimpleGraph of G2
  holds G4 is G3-isomorphic
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  let G3 be SimpleGraph of G1, G4 be SimpleGraph of G2;
  set G5 = the removeLoops of G1, G6 = the removeLoops of G2;
  A1: G6 is G5-isomorphic by Th166;
  G3 is removeParallelEdges of G5 & G4 is removeParallelEdges of G6
    by GLIB_009:121;
  hence thesis by A1, Th168;
end;

theorem
  for G1 being _Graph, G2, G3 being SimpleGraph of G1
  holds G3 is G2-isomorphic
proof
  let G1 be _Graph, G2, G3 be SimpleGraph of G1;
  G1 is G1-isomorphic by Th53;
  hence thesis by Th172;
end;

theorem Th174:
  for G1 being _Graph, G2 being G1-Disomorphic _Graph
  for G3 being DSimpleGraph of G1, G4 being DSimpleGraph of G2
  holds G4 is G3-Disomorphic
proof
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  let G3 be DSimpleGraph of G1, G4 be DSimpleGraph of G2;
  set G5 = the removeLoops of G1, G6 = the removeLoops of G2;
  A1: G6 is G5-Disomorphic by Th167;
  G3 is removeDParallelEdges of G5 & G4 is removeDParallelEdges of G6
    by GLIB_009:122;
  hence thesis by A1, Th170;
end;

theorem
  for G1 being _Graph, G2, G3 being DSimpleGraph of G1
  holds G3 is G2-Disomorphic
proof
  let G1 be _Graph, G2, G3 be DSimpleGraph of G1;
  G1 is G1-Disomorphic by Th53;
  hence thesis by Th174;
end;

theorem
  for G1, G2 being _trivial loopless _Graph
  for F being non empty PGraphMapping of G1, G2
  holds F is Disomorphism &
    F = [ (the Vertex of G1) .--> the Vertex of G2, {} ]
proof
  let G1, G2 be _trivial loopless _Graph;
  let F be non empty PGraphMapping of G1, G2;
  thus F is Disomorphism;
  A1: F_E = {};
  F is total onto;
  then A2: dom F_V = the_Vertices_of G1 & rng F_V = the_Vertices_of G2;
  consider v1 being Vertex of G1 such that
    A3: the_Vertices_of G1 = {v1} by GLIB_000:22;
  consider v2 being Vertex of G2 such that
    A4: the_Vertices_of G2 = {v2} by GLIB_000:22;
  dom F_V = {the Vertex of G1} & rng F_V = {the Vertex of G2}
    by A2, A3, A4, TARSKI:def 1;
  then F_V = (the Vertex of G1) .--> the Vertex of G2 by FUNCT_4:112;
  hence thesis by A1;
end;

theorem
  for G1, G2 being _trivial _Graph st G1.size() = G2.size()
  ex F being PGraphMapping of G1, G2 st F is Disomorphism
proof
  let G1, G2 be _trivial _Graph;
  assume G1.size() = G2.size();
  then G1.size() = card the_Edges_of G2 by GLIB_000:def 25;
  then card the_Edges_of G1 = card the_Edges_of G2 by GLIB_000:def 25;
  then consider g being Function such that
    A1: g is one-to-one & dom g = the_Edges_of G1 & rng g = the_Edges_of G2
    by CARD_1:5, WELLORD2:def 4;
  reconsider g as Function of the_Edges_of G1, the_Edges_of G2
    by A1, FUNCT_2:1;
  consider v being Vertex of G1 such that
    A2: the_Vertices_of G1 = {v} by GLIB_000:22;
  consider w being Vertex of G2 such that
    A3: the_Vertices_of G2 = {w} by GLIB_000:22;
  reconsider V = {v} as Subset of the_Vertices_of G1;
  reconsider f = V --> w as PartFunc of the_Vertices_of G1, the_Vertices_of G2;
  :: show the PGM properties
  now
    A4:
      for e be object st e in dom g
      holds (the_Source_of G1).e in dom f &
        (the_Target_of G1).e in dom f by A2,FUNCT_2:5;
    hence for e being object holds e in dom g implies
      (the_Source_of G1).e in dom f & (the_Target_of G1).e in dom f;
    let e,v1,w1 be object;
    assume A5: e in dom g & v1 in dom f & w1 in dom f;
    then A6: v1 = v & w1 = v by TARSKI:def 1;
    A7: f.v1 = w & f.w1 = w by A5, FUNCOP_1:7;
    (the_Source_of G1).e in dom f &
      (the_Target_of G1).e in dom f by A5, A4;
    then (the_Source_of G1).e = v1 &
      (the_Target_of G1).e = w1 by A6, TARSKI:def 1;
    then A8: e Joins v1,w1,G1 by A5, GLIB_000:def 13;
    A9: g.e in the_Edges_of G2 by A1, A5, FUNCT_1:3;
    then (the_Source_of G2).(g.e) in the_Vertices_of G2 &
      (the_Target_of G2).(g.e) in the_Vertices_of G2 by FUNCT_2:5;
    then (the_Source_of G2).(g.e) = w &
      (the_Target_of G2).(g.e) = w by A3, TARSKI:def 1;
    then g.e Joins f.v1,f.w1,G2 by A7, A9, GLIB_000:def 13;
    hence e Joins v1,w1,G1 iff g.e Joins f.v1,f.w1,G2 by A8;
  end;
  then reconsider F = [f,g] as semi-continuous PGraphMapping of G1, G2 by Th31;
  take F;
  A10: F is total by A1, A2;
  A11: f = v .--> w by FUNCOP_1:def 9;
  then A12: F is onto by A1, A3, FUNCOP_1:88;
  F is one-to-one by A1, A11;
  hence thesis by A10, A12;
end;

:: sadly, the attribute notation is not compatible with the following notation
::registration
::  let G be trivial loopless _Graph;
::  cluster trivial loopless -> G-Disomorphic for _Graph;
::  coherence;
::end;
:: but normal theorems will do

:: Right Now, this is the only class of graphs that can
:: solely be determined by its attributes. More will come in the future.
theorem
  for G1, G2 being _trivial loopless _Graph
  holds G2 is G1-Disomorphic G1-isomorphic
proof
  let G1, G2 be _trivial loopless _Graph;
  set F = the non empty PGraphMapping of G1, G2;
  F is directed isomorphism;
  hence G2 is G1-Disomorphic;
  hence G2 is G1-isomorphic;
end;
