:: Quick Sort on SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000-2022 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SCMPDS_2, SUBSET_1, FSM_1, SCMPDS_4, AMI_1, TURING_1,
      SCMFSA8A, SCMFSA_7, AMI_3, INT_1, SCMFSA8B, CARD_1, ARYTM_3, FUNCT_1,
      XXREAL_0, UNIALG_2, SCMFSA7B, SCMFSA6B, RELAT_1, FUNCT_4, AMI_2,
      SCMFSA_9, ARYTM_1, VALUED_1, TARSKI, GRAPHSP, CIRCUIT2, MSUALG_1, NAT_1,
      FUNCOP_1, CARD_3, FINSEQ_1, GRAPH_2, SCPISORT, SCMP_GCD, CLASSES1,
      SCPQSORT, EXTPRO_1, SCMFSA6C, COMPOS_1, MEMSTR_0;
 notations TARSKI, XBOOLE_0, FUNCT_2, SUBSET_1, CARD_1, ORDINAL1, NUMBERS,
      XXREAL_0, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, PBOOLE, VALUED_1,
      XCMPLX_0, RECDEF_1, INT_1, NAT_1, STRUCT_0, COMPOS_1, MEMSTR_0, EXTPRO_1,
      AMI_2, FUNCT_7, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, CARD_3,
      FINSEQ_1, SCMPDS_8, GRAPH_2, CLASSES1, SCPISORT, FINSEQ_6;
 constructors REAL_1, RECDEF_1, NEWTON, MESFUNC1, SCM_1, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, SCMPDS_8, SCPISORT, CLASSES1, GRAPH_2, VALUED_1,
      AMI_2, SCMPDS_1, PRE_POLY, AMISTD_1, AMISTD_2, SCMPDS_7, PBOOLE,
      AMISTD_5, MEMSTR_0, FINSEQ_6;
 registrations RELSET_1, XXREAL_0, XREAL_0, NAT_1, INT_1, SCMPDS_2, SCMPDS_4,
      SCMPDS_5, SCMPDS_6, SCMPDS_8, ORDINAL1, VALUED_0, COMPOS_1, AFINSQ_1,
      MEMSTR_0, EXTPRO_1, FUNCT_4, FUNCT_7, PRE_POLY, AMI_3, COMPOS_0;
 requirements NUMERALS, REAL, SUBSET, ARITHM;
 definitions SCPISORT;
 equalities SCMPDS_2, SCMP_GCD, COMPOS_1, EXTPRO_1, MEMSTR_0;
 expansions SCPISORT;
 theorems AMI_3, NAT_1, TARSKI, FUNCT_4, SCMPDS_2, FUNCT_7, GRFUNC_1, SCMPDS_4,
      SCMPDS_5, SCMPDS_7, SCMPDS_8, FINSEQ_1, FINSEQ_2, RFINSEQ, SCPISORT,
      XBOOLE_1, XREAL_1, XXREAL_0, GRAPH_2, MEMSTR_0, CLASSES1, SCMPDS_6,
      SCMP_GCD, INT_1, COMPOS_1, AFINSQ_1, EXTPRO_1, FINSEQ_6, PBOOLE;
 schemes NAT_1, SCMPDS_8;

begin :: The Several Properties of "while" Program and Finite Sequence

reserve x for Int_position,
  n,p0 for Nat;

registration
  let I,J be shiftable Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I,J) -> shiftable;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I + 2), G =Goto (card J+1);
    I ';' G ';' J = I ';' Load (goto (card J+1)) ';' J by SCMPDS_6:def 1;
    then reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    if>0(a,k1,I,J) = i ';' I ';' G ';' J by SCMPDS_6:def 5
      .=i ';' (I ';' G) ';' J by SCMPDS_4:14
      .=i ';' IJ by SCMPDS_4:14
      .=Load i ';' IJ by SCMPDS_4:def 2;
    hence thesis;
  end;
end;

reserve P,Q,V for Instruction-Sequence of SCMPDS;

theorem Th1: :: see SCMPDS_6:87
  for s being 0-started State of SCMPDS,I being halt-free shiftable Program
  of SCMPDS, J being shiftable Program of SCMPDS,a,b be Int_position,k1 being
  Integer st s.DataLoc(s.a,k1) > 0 & I is_closed_on s,P & I is_halting_on s,P
   holds
  IExec(if>0(a,k1,I,J),P,s).b = IExec(I,P,s).b
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a,b be Int_position,k1 be Integer;
  assume that
A1: s.DataLoc(s.a,k1)>0 and
A2: I is_closed_on s,P and
A3: I is_halting_on s,P;
A4: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:18;
  IExec(if>0(a,k1,I,J),P,s) = IExec(I,P,s) +*
   Start-At((card I+card J+2),SCMPDS)
   by A1,A2,A3,SCMPDS_6:70;
  hence thesis by A4,FUNCT_4:11;
end;
set A = NAT, D = SCM-Data-Loc;

Lm1: for a be Int_position,i be Integer,I be Program of SCMPDS holds while>0(a
,i,I)= ((a,i)<=0_goto (card I +2)) ';' (I ';' goto -(card I+1))
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +2), i2=goto -(card I+1);
  thus while>0(a,i,I) = i1 ';' I ';' i2 by SCMPDS_8:def 3
    .= i1 ';' (I ';' i2) by SCMPDS_4:15;
end;

Lm2: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,1) c= while>0(a,i,I)
proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A1: while>0(a,i,I) = i1 ';' I ';' i2 by SCMPDS_8:def 3
    .= i1 ';' I ';' Load i2 by SCMPDS_4:def 3
    .= Load i1 ';' I ';' Load i2 by SCMPDS_4:def 2;
  card Load i1=1 by COMPOS_1:54;
  hence thesis by A1,SCMPDS_7:3;
end;

theorem Th2:
  for s,sm be State of SCMPDS,I be halt-free shiftable Program of
  SCMPDS, a be Int_position,i be Integer, m be Nat st
  I is_closed_on s,P & I is_halting_on s,P & s.DataLoc(s.a,i) > 0 &
   m=LifeSpan(P +* stop I,Initialize s)+2 &
 sm=Comput(P +* stop while>0(a,i,I),Initialize s,m)
 holds DataPart sm = DataPart IExec(I,P,Initialize s) &
   Initialize sm=sm
proof
  let s,sm be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a
  be Int_position,i be Integer,m be Nat;
  set b=DataLoc(s.a,i);
  set WH =while>0(a,i,I), iWH= stop WH, IsI= stop I;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
  set s2 = Initialize s, P2 = P +* stop I,
  s3 = Initialize s, P3 = P +* stop WH,
  s4 = Comput(P3,s3,1), P4 = P3;
  assume that
A1: I is_closed_on s,P and
A2: I is_halting_on s,P and
A3: s.b > 0 and
A4: m=LifeSpan(P2,s2)+2 and
A5: sm= Comput(P3,s3,m);
A6: IsI c= P2 by FUNCT_4:25;
A7: iWH c= P3 by FUNCT_4:25;
  WH c= iWH by AFINSQ_1:74;
  then
A8: WH c= P3 by A7,XBOOLE_1:1;
  Shift(I,1) c= WH by Lm2;
  then
A9: Shift(I,1) c= P4 by A8,XBOOLE_1:1;
A10: WH = i1 ';' (I ';' i2) by Lm1;
A11: Comput(P3,s3,0+1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Exec(i1,s3) by A10,SCMPDS_6:11;
  set m2=LifeSpan(P2,s2), s5= Comput(P4, s4,m2), P5 = P4,
  l1=
(card I + 1);
A12: IC s3 = 0 by MEMSTR_0:def 11;
A13:   not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
   not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
   then
A14: s3.DataLoc(s3.a,i)= s3.b by FUNCT_4:11
    .= s.b by A13,FUNCT_4:11;
  set m3=m2 +1;
  set s6= Comput(P3, s3,m3), P6 = P3;
A15: s6=s5 by EXTPRO_1:4;
  set s7= Comput(P3,s3,m3+1);
  card I + 1 < card I + 2 by XREAL_1:6;
  then
A16: l1 in dom WH by SCMPDS_8:18;
A17: I is_closed_on s2,P2 by A1,SCMPDS_6:24;
  for x holds s2.x = s4.x by A11,SCMPDS_2:56;
  then
A18: DataPart s2 = DataPart s4 by SCMPDS_4:8;
A19: P2 halts_on s2 by A2,SCMPDS_6:def 3;
  P2+*stop I halts_on Initialize s2
     by A2,SCMPDS_6:def 3;
  then
A20: I is_halting_on s2,P2 by SCMPDS_6:def 3;
A21: IC s4 = 0+1 by A3,A12,A11,A14,SCMPDS_2:56;
  then DataPart Comput(P2, s2,m2) = DataPart s5 by A6,A20,A17,A18,A9,
SCMPDS_7:18;
  then
A22: DataPart s5 = DataPart(Result(P2,s2)) by A19,EXTPRO_1:23
    .= DataPart IExec(I,P,Initialize s) by SCMPDS_4:def 5;
A23: IC s5=l1 by A6,A20,A17,A21,A18,A9,SCMPDS_7:18;
  then
A24: CurInstr(P6,s6)=P5.l1 by A15,PBOOLE:143
    .=WH.l1 by A16,A8,GRFUNC_1:2
    .=i2 by SCMPDS_8:19;
A25: s7 = Following(P3,s6) by EXTPRO_1:3
    .= Exec(i2,s6) by A24;
  now
    let x;
    thus sm.x=s6.x by A4,A5,A25,SCMPDS_2:54
      .=s5.x by EXTPRO_1:4;
  end;
  hence DataPart sm = DataPart IExec(I,P,Initialize s) by A22,SCMPDS_4:8;
  IC s7 =ICplusConst(s6,0-(card I+1)) by A25,SCMPDS_2:54
    .= 0 by A23,A15,SCMPDS_7:1;
  hence thesis by A4,A5,MEMSTR_0:46;
end;

theorem Th3:
  for s be State of SCMPDS,I be Program of SCMPDS st
   for t be 0-started State of SCMPDS, Q st DataPart t = DataPart s
    holds I is_halting_on t,Q
  holds I is_closed_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: for t be 0-started State of SCMPDS,Q st DataPart t = DataPart s holds I
  is_halting_on t,Q;
  set pI=stop I, sI=Initialize s, PI = P +* pI;
  defpred X[Nat] means not IC Comput(PI,sI,$1) in dom pI;
A2: for a be Int_position holds s.a = sI.a
   proof let a be Int_position;
      not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
    hence thesis by FUNCT_4:11;
   end;
  assume not I is_closed_on s,P;
  then ex k be Nat st X[k] by SCMPDS_6:def 2;
  then
A3: ex k be Nat st X[k];
  consider n be Nat such that
A4: X[n] and
A5: for m be Nat st X[m] holds n <= m from NAT_1:sch 5(A3);
  reconsider n as Nat;
  set s2 = Comput(PI,sI,n), P2 = PI,
  Ig = ((IC s2,IC s2 + 1) --> (goto 1,goto -1));
  reconsider P0 = PI +* Ig as Instruction-Sequence of SCMPDS;
  reconsider P1 = P2 +* Ig as Instruction-Sequence of SCMPDS;
  reconsider P3 = PI +* (IC s2,goto 1) as Instruction-Sequence of SCMPDS;
    reconsider P4 = P3 +* (IC s2 + 1,goto -1)
         as Instruction-Sequence of SCMPDS;
A6:   P0 = P4 by FUNCT_7:139;
A7: for m be Nat st m < n holds IC( Comput(PI, sI,m))
   in dom pI by A5;
A8: stop I c= PI by FUNCT_4:25;
  pI c= P3 by A4,FUNCT_4:25,FUNCT_7:89;
  then
A9: stop I c= P0 by A6,A4,AFINSQ_1:73,FUNCT_7:89;
  then
A10:  Comput(P0,sI,n) =  s2 by A8,A7,SCMPDS_4:21;
  DataPart sI = DataPart s by A2,SCMPDS_4:8;
  then I is_halting_on sI,P0 by A1;
  then
A11: P0+*pI halts_on Initialize sI
   by SCMPDS_6:def 3;
A12: not P0 halts_on s2 by SCMPDS_4:20;
   P0 +* pI=P0 by A9,FUNCT_4:98;
  hence contradiction by A12,A10,A11,EXTPRO_1:22;
end;

theorem Th4:
  for i1,i2,i3,i4 be Instruction of SCMPDS holds
  card (i1 ';' i2 ';' i3 ';' i4) = 4
proof
  let x1,x2,x3,x4 be Instruction of SCMPDS;
  thus card (x1 ';' x2 ';' x3 ';' x4)=card (x1 ';' x2 ';' x3)+1 by SCMP_GCD:4
    .=card (x1 ';' x2 )+1+1 by SCMP_GCD:4
    .=2+1+1 by SCMP_GCD:5
    .=4;
end;

theorem Th5:
  for s being 0-started State of SCMPDS,I being halt-free shiftable Program
  of SCMPDS, a,x,y be Int_position, i,c be Integer st s.x >= c+s.
DataLoc(s.a,i) &
(for t be 0-started State of SCMPDS,Q st t.x >= c+t.DataLoc(s.a,i) & t.y=s
.y & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I,Q,t).a=t.a & I is_closed_on t,Q &
I is_halting_on t,Q & IExec(I,Q,t).DataLoc(s.a,i) < t.DataLoc(s.a,i)
 & IExec(I,Q,t).x
  >= c+IExec(I,Q,t).DataLoc(s.a,i) & IExec(I,Q,t).y=t.y)
 holds while>0(a,i,I) is_closed_on s,P & while>0(a,i,I) is_halting_on s,P &
 (s.DataLoc(s.a,i) > 0 implies
  IExec(while>0(a,i,I),P,s)
   =IExec(while>0(a,i,I),P,Initialize IExec(I,P,s)))
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,x1,
  y1 be Int_position, i,c be Integer;
  set b=DataLoc(s.a,i);
  assume s.x1 >= c+s.b;
  then
A1: for x st x in {x1} holds s.x >= c+s.b by TARSKI:def 1;
  assume
A2: for t be 0-started State of SCMPDS,Q st t.x1 >= c+t.b &
 t.y1=s.y1 & t.a=s.a & t.b > 0
  holds IExec(I,Q,t).a=t.a & I is_closed_on t,Q & I is_halting_on t,Q
 & IExec(I,Q,t).b < t.b & IExec(I,Q,t).x1 >= c+IExec(I,Q,t).b &
  IExec(I,Q,t).y1=t.y1;
  now
    let t be 0-started State of SCMPDS, Q;
    assume that
A3: for x st x in {x1} holds t.x >= c+t.b and
A4: for x st x in {y1} holds t.x=s.x and
A5: t.a=s.a and
A6: t.b > 0;
    y1 in {y1} by TARSKI:def 1;
    then
A7: t.y1=s.y1 by A4;
    x1 in {x1} by TARSKI:def 1;
    then
A8: t.x1 >= c+t.b by A3;
    hence
    IExec(I,Q,t).a=t.a & I is_closed_on t,Q
     & I is_halting_on t,Q & IExec(I,Q,t).
    b < t.b by A2,A5,A6,A7;
    hereby
      let x;
      assume
A9:  x in {x1};
      IExec(I,Q,t).x1 >= c+IExec(I,Q,t).b
       by A2,A5,A6,A8,A7;
      hence IExec(I,Q,t).x >= c+IExec(I,Q,t).b
       by A9,TARSKI:def 1;
    end;
      let x;
      assume
A10:  x in {y1};
      hence IExec(I,Q,t).x=IExec(I,Q,t).y1
       by TARSKI:def 1
        .=t.y1 by A2,A5,A6,A8,A7
        .=t.x by A10,TARSKI:def 1;
  end;
  hence thesis by A1,SCMPDS_8:27;
end;

theorem Th6:
  for s being 0-started State of SCMPDS,I being halt-free shiftable Program
  of SCMPDS, a,x,y be Int_position, i,c be Integer st s.x >= c & (
for t be 0-started State of SCMPDS,Q
 st t.x >= c & t.y=s.y & t.a=s.a & t.DataLoc(s.a,i) > 0
  holds IExec(I,Q,t).a=t.a & I is_closed_on t,Q
   & I is_halting_on t,Q & IExec(I,Q,t).
DataLoc(s.a,i) < t.DataLoc(s.a,i) & IExec(I,Q,t).x >= c
 & IExec(I,Q,t).y=t.y) holds
while>0(a,i,I) is_closed_on s,P & while>0(a,i,I) is_halting_on s,P
 & ( s.DataLoc(s.a,i) > 0
   implies IExec(while>0(a,i,I),P,s)
   =IExec(while>0(a,i,I),P,Initialize IExec(I,P,s)))
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,x,y
  be Int_position, i,c be Integer;
  set b=DataLoc(s.a,i);
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x >= c & t.y=s.y;
  consider f be Function of product the_Values_of SCMPDS,NAT such that
A1: for s be State of SCMPDS holds (s.b <= 0 implies f.s =0) & (s.b > 0
  implies f.s=s.b) by SCMPDS_8:5;
  deffunc F(State of SCMPDS) = f.$1;
A2: for t be 0-started State of SCMPDS st P[t] & F(t)=0 holds t.b <= 0 by A1;
  assume
A3: s.x >= c;
A4: P[s] by A3;
  assume
A5: for t be 0-started State of SCMPDS,Q
      st t.x >= c & t.y=s.y & t.a=s.a & t.b > 0
holds IExec(I,Q,t).a=t.a & I is_closed_on t,Q & I is_halting_on t,Q
 & IExec(I,Q,t).b <
  t.b & IExec(I,Q,t).x >= c & IExec(I,Q,t).y=t.y;
A6: now
    let t be 0-started State of SCMPDS, Q;
    assume that
A7: P[t] and
A8: t.a=s.a and
A9: t.b > 0;
    set It=IExec(I,Q,t), t2=Initialize It;
    thus
    IExec(I,Q,t).a=t.a & I is_closed_on t,Q & I is_halting_on t,Q
     by A5,A8,A9,A7;
    thus F(t2) < F(t)
    proof
A10:  F(t)=t.b by A1,A9;
      assume
A11:  F(t2) >= F(t);
      then t2.b > 0 by A1,A9,A10;
      then F(t2)=t2.b by A1
        .=It.b by SCMPDS_5:15;
      hence contradiction by A5,A8,A9,A7,A11,A10;
    end;
    thus P[Initialize It]
    proof
      take v=Initialize It;
      thus v=Initialize It;
      It.x >= c by A5,A8,A9,A7;
      hence v.x >= c by SCMPDS_5:15;
      It.y=t.y by A5,A8,A9,A7;
      hence thesis by A7,SCMPDS_5:15;
    end;
  end;
  while>0(a,i,I) is_closed_on s,P & while>0(a,i,I)
  is_halting_on s,P from SCMPDS_8:sch 3(A2,A4,A6);
  hence while>0(a,i,I) is_closed_on s,P & while>0(a,i,I) is_halting_on s,P;
  assume
A12: s.b > 0;
  IExec(while>0(a,i,I),P,s)
   = IExec(while>0(a,i,I),P,Initialize IExec(I,P,s))
    from SCMPDS_8:sch 4(A12,A2,A4,A6);
  hence thesis;
end;

theorem Th7:
  for s being 0-started State of SCMPDS,I being halt-free shiftable Program
of SCMPDS, a,x1,x2,x3,x4 be Int_position, i,c,md be Integer st s.
x4=s.x3-c+s.x1 & md <= s.x3-c &
 (for t be 0-started State of SCMPDS,Q st t.x4=t.x3-c+t.x1 &
md <= t.x3-c & t.x2=s.x2 & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I,Q,t).a=t.
  a & I is_closed_on t,Q & I is_halting_on t,Q
   & IExec(I,Q,t).DataLoc(s.a,i) < t.
DataLoc(s.a,i) & IExec(I,Q,t).x4=
IExec(I,Q,t).x3-c+IExec(I,Q,t).x1
 & md <= IExec(I,Q,t)
.x3-c & IExec(I,Q,t).x2=t.x2) holds while>0(a,i,I) is_closed_on s,P
 & while>0(a,i,I) is_halting_on s,P & ( s.DataLoc(s.a,i) > 0
   implies IExec(while>0(a,i,I),P,s) =
  IExec(while>0(a,i,I),P,Initialize IExec(I,P,s)) )
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,x1,
  x2,x3,x4 be Int_position, i,c,md be Integer;
  set b=DataLoc(s.a,i);
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.x4=t.x3-c+t.x1 & md
  <= t.x3-c & t.x2=s.x2;
  assume that
A1: s.x4=s.x3-c+s.x1 and
A2: md <= s.x3-c;
  consider f be Function of product the_Values_of SCMPDS,NAT such that
A3: for s be State of SCMPDS holds (s.b <= 0 implies f.s =0) & (s.b > 0
  implies f.s=s.b) by SCMPDS_8:5;
  deffunc F(State of SCMPDS) = f.$1;
A4: for t be 0-started State of SCMPDS st P[t] & F(t)=0 holds t.b <= 0 by A3;
  assume
A5: for t be 0-started State of SCMPDS,Q
   st t.x4=t.x3-c+t.x1 & md <= t.x3-c & t.x2=s
.x2 & t.a=s.a & t.DataLoc(s.a,i) > 0 holds IExec(I,Q,t).a=t.a
 & I is_closed_on t,Q
& I is_halting_on t,Q & IExec(I,Q,t).DataLoc(s.a,i) <
t.DataLoc(s.a,i)
 & IExec(I,Q,t).x4=IExec(I,Q,t).x3-c+IExec(I,Q,t).x1
  & md <= IExec(I,Q,t).x3-c & IExec(I,Q,t).x2=t.x2;
A6: now
    let t be 0-started State of SCMPDS, Q;
    assume that
A7: P[t] and
A8: t.a=s.a and
A9: t.b > 0;
    set It=IExec(I,Q,t), t2=Initialize It;
    consider v be State of SCMPDS such that
A10: v=t and
A11: v.x4=v.x3-c+v.x1 and
A12: md <= v.x3-c and
A13: v.x2=s.x2 by A7;
A14: t.x2=s.x2 by A10,A13;
A15: t.x4=t.x3-c+t.x1 by A10,A11;
A16: md <= t.x3-c by A10,A12;
    thus IExec(I,Q,t).a=t.a & I is_closed_on t,Q & I is_halting_on t,Q
     by A5,A8,A9,A15,A13,A10,A12;
    thus F(t2) < F(t)
    proof
A17:  F(t)=t.b by A3,A9;
      assume
A18:  F(t2) >= F(t);
      then t2.b > 0 by A3,A9,A17;
      then F(t2)=t2.b by A3
        .=It.b by SCMPDS_5:15;
      hence contradiction by A5,A8,A9,A15,A16,A10,A13,A18,A17;
    end;
    thus P[Initialize It]
    proof
      take v=Initialize It;
      thus v=Initialize It;
      It.x4=It.x3-c+It.x1 by A5,A8,A9,A15,A16,A14;
      then v.x4=It.x3-c+It.x1 by SCMPDS_5:15;
      then v.x4=v.x3-c+It.x1 by SCMPDS_5:15;
      hence v.x4=v.x3-c+v.x1 by SCMPDS_5:15;
      md <= It.x3-c by A5,A8,A9,A15,A16,A14;
      hence md <= v.x3-c by SCMPDS_5:15;
      It.x2=t.x2 by A5,A8,A9,A15,A16,A10,A13;
      hence thesis by A10,A13,SCMPDS_5:15;
    end;
  end;
A19: P[s] by A1,A2;
  while>0(a,i,I) is_closed_on s,P & while>0(a,i,I)
  is_halting_on s,P from SCMPDS_8:sch 3(A4,A19,A6);
  hence while>0(a,i,I) is_closed_on s,P & while>0(a,i,I) is_halting_on s,P;
  assume
A20: s.b > 0;
  IExec(while>0(a,i,I),P,s) = IExec(while>0(a,i,I),P,
  Initialize IExec(I,P,s)) from SCMPDS_8:sch 4(A20,A4,A19,A6);
  hence thesis;
end;

theorem Th8:
  for f being FinSequence of INT,m,k1,k,n be Nat st k1=k
  -1 & f is_non_decreasing_on m,k1 & f is_non_decreasing_on k+1,n & (for i be
  Nat st m <= i & i < k holds f.i <= f.k) & (for i be Nat
  st k < i & i <= n holds f.k <= f.i) holds f is_non_decreasing_on m,n
proof
  let f be FinSequence of INT,m,k1,k,n be Nat;
  assume that
A1: k1=k-1;
  assume
A2: f is_non_decreasing_on m,k1;
  assume
A3: f is_non_decreasing_on k+1,n;
  assume
A4: for i be Nat st m <= i & i < k holds f.i <= f.k;
  assume
A5: for i be Nat st k < i & i <= n holds f.k <= f.i;
  now
    let i,j be Nat;
    assume that
A6: m <= i and
A7: i <= j and
A8: j <= n;
    per cases by XXREAL_0:1;
    suppose
      j < k;
      then j+1 <= k by INT_1:7;
      then j <= k1 by A1,XREAL_1:19;
      hence f.i <= f.j by A2,A6,A7,FINSEQ_6:def 9;
    end;
    suppose
A9:   j = k;
        per cases;
        suppose
          i=j;
          hence f.i <= f.j;
        end;
        suppose
          i<>j;
          then i<j by A7,XXREAL_0:1;
          hence f.i <= f.j by A4,A6,A9;
        end;
    end;
    suppose
A10:  j > k;
        per cases by XXREAL_0:1;
        suppose
          i < k;
          then
A11:      f.k >= f.i by A4,A6;
          f.j >= f.k by A5,A8,A10;
          hence f.i <= f.j by A11,XXREAL_0:2;
        end;
        suppose
A12:      i = k;
            per cases;
            suppose
              i=j;
              hence f.i <= f.j;
            end;
            suppose
              i<>j;
              then i<j by A7,XXREAL_0:1;
              hence f.i <= f.j by A5,A8,A12;
          end;
        end;
        suppose
          i > k;
          then i >= k+1 by INT_1:7;
          hence f.i <= f.j by A3,A7,A8,FINSEQ_6:def 9;
        end;
    end;
  end;
  hence thesis by FINSEQ_6:def 9;
end;

Lm3: for s be 0-started State of SCMPDS,
  I be halt-free shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,f,g be FinSequence of INT,
  m,n,m1 be Nat st s.a=c & len f=n & len g=n & f is_FinSequence_on s,m & g
is_FinSequence_on IExec(while>0(a,i,I),P,s),m & 1=s.DataLoc(c,i)
 & m1=m+n+1 & m+1
=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be 0-started State of SCMPDS,Q
 for f1,f2 be
FinSequence of INT,k1,k2,y1, yn be Nat st t.a=c & 2*k1+1=t.DataLoc(c
,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & (1 <= y1 & yn <=
n or y1 >= yn) holds I is_closed_on t,Q & I is_halting_on t,Q
 & IExec(I,Q,t).a=t.a &
(for j be Nat st (1<=j & j<2*k1+1)
 holds IExec(I,Q,t).intpos(m+n+j)=t.
intpos(m+n+j)) & (y1>=yn implies IExec(I,Q,t).DataLoc(c,i)=2*k1-1
 & (for j be
Nat st (1<=j & j <= n)
 holds IExec(I,Q,t).intpos (m+j) = t.intpos (m+j
))) & (y1<yn implies IExec(I,Q,t).DataLoc(c,i)=2*k1+3
 & (for j be Nat
st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos(m+j) = t.intpos (m+
j)) & (ex ym be Nat st y1 <= ym & ym <= yn
 & m+y1=IExec(I,Q,t).intpos
k2 & m+ym-1=IExec(I,Q,t).intpos (k2+1) &
m+ym+1=IExec(I,Q,t).intpos (k2+2)
 & m+yn=
IExec(I,Q,t).intpos (k2+3) &
 (for j be Nat st y1 <= j & j < ym holds
IExec(I,Q,t).intpos (m+j) <=
IExec(I,Q,t).intpos (m+ym)) &
 (for j be Nat
st ym < j & j <= yn holds IExec(I,Q,t).intpos (m+j)
 >= IExec(I,Q,t).intpos (m+ym)))
) & (f1 is_FinSequence_on t,m
 & f2 is_FinSequence_on IExec(I,Q,t),m & len f1=n &
len f2=n implies f1,f2 are_fiberwise_equipotent)) holds while>0(a,i,I)
is_halting_on s,P & f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,f,g be FinSequence of INT,
   m,n,m1 be Nat;
A1: Initialize s = s by MEMSTR_0:44;
  set b=DataLoc(c,i);
  assume that
A2: s.a=c and
A3: len f=n and
A4: len g=n;
  set WH =while>0(a,i,I), sWH=stop WH;
  assume
A5: f is_FinSequence_on s,m;
  defpred P[Nat] means
   for t be 0-started State of SCMPDS,Q
   for f1 be FinSequence of INT, k1,k2,y1,yn be Nat
    st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 &
     (1 <= y1 & yn <= n or y1 >= yn) &
     m+y1=t.intpos k2 & m+yn=t.intpos(k2+1) & yn-y1<=$1 &
     f1 is_FinSequence_on t,m & len f1=n
   ex k be Nat,f2 be FinSequence of INT
    st Initialize Comput(Q+*sWH,t,k)
          = Comput(Q+*sWH,t,k) &
    f2 is_FinSequence_on
     Comput(Q+*sWH,t,k),m & len f2=n &
    f1,f2 are_fiberwise_equipotent &
    f2 is_non_decreasing_on y1,yn &
    (for j be Nat st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
      holds f2.j= t.intpos(m+j)) &
    (for j be Nat st y1>=yn & 1<=j & j<= n
     holds f2.j= t.intpos(m+j)) &
    (for j be Nat st 1<=j & j<2*k1+1
     holds Comput(Q+*sWH,t,k).intpos(m+n+j)=t.intpos(m+n+j)) &
    Comput(Q+*sWH,t,k).b=t.b-2 & Comput(Q+*sWH,t,k).a=c;
  assume
A6: g is_FinSequence_on IExec(while>0(a,i,I),P,s),m;
  assume
A7: 1=s.b;
  assume that
A8: m1=m+n+1 and
A9: m+1=s.intpos m1 and
A10: m+n=s.intpos(m1+1);
A11: m1=m+n+2*0+1 by A8;
  assume
A12: for t be 0-started State of SCMPDS,Q
 for f1,f2 be FinSequence of INT, k1,k2,y1,yn
be Nat st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+
yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
 holds I is_closed_on t,Q & I is_halting_on t,Q & IExec(I,Q,t).a=t.a &
  (for j be Nat st (1<=j & j<2*k1+1)
  holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j)) &
  (y1>=yn implies IExec(I,Q,t).b=2*k1-1 &
    for j be Nat
  st 1<=j & j <= n
 holds IExec(I,Q,t).intpos (m+j) = t.intpos (m+j) ) &
  (y1<yn implies IExec(I,Q,t).b=2*k1+3 &
   (for j be
Nat st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos (m+j) = t.intpos (m+j)) &
   ex ym be Nat st y1 <= ym & ym <= yn & m+y1=
  IExec(I,Q,t).intpos k2 & m+ym-1=
  IExec(I,Q,t).intpos (k2+1)
   & m+ym+1=IExec(I,Q,t).intpos (k2+2) & m+yn=IExec(I,Q,t).intpos (k2+3) &
 (for j be Nat st y1<= j & j < ym holds IExec(I,Q,t).intpos(m+j) <=
IExec(I,Q,t).intpos(m+ym))
 & for j be Nat st ym < j & j <= yn
 holds IExec(I,Q,t).intpos(m+j) >=
 IExec(I,Q,t).intpos(m+ym) )
 & (f1 is_FinSequence_on t,m
 & f2 is_FinSequence_on IExec(I,Q,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);
A13: P[0]
  proof
    let t be 0-started State of SCMPDS,Q;
    let f1 be FinSequence of INT,k1,k2,y1,yn be Nat;
A14: Initialize t = t by MEMSTR_0:44;
    assume that
A15: t.a=c and
A16: 2*k1+1=t.b and
A17: k2=m+n+2*k1+1 and
A18: 1 <= y1 & yn <= n or y1 >= yn and
A19: m+y1=t.intpos k2 and
A20: m+yn=t.intpos(k2+1) and
A21: yn-y1<=0 and
A22: f1 is_FinSequence_on t,m and
A23: len f1=n;
A24: I is_halting_on t,Q by A12,A15,A16,A17,A18,A19,A20;
    take k=LifeSpan(Q+*stop I,t)+2;
    set tk= Comput(Q+*sWH,t,k);
A25: I is_closed_on t,Q by A12,A15,A16,A17,A18,A19,A20;
    then
A26: DataPart tk = DataPart IExec(I,Q,t) by A15,A16,A24,Th2,A14;
    consider f2 be FinSequence of INT such that
A27: len f2=n and
A28: for i be Nat st 1<=i & i <= len f2
 holds f2.i=IExec(I,Q,t) .intpos(m+i) by SCPISORT:1;
    take f2;
    thus Initialize tk =tk by A15,A16,A25,A24,Th2,A14;
    now
      let i be Nat;
      assume that
A29:  1<=i and
A30:  i <= len f2;
      thus f2.i=IExec(I,Q,t).intpos(m+i) by A28,A29,A30
        .=tk.intpos(m+i) by A26,SCMPDS_4:8;
    end;
    hence f2 is_FinSequence_on tk,m;
    thus len f2=n by A27;
    f2 is_FinSequence_on IExec(I,Q,t),m by A28;
    hence
    f1,f2 are_fiberwise_equipotent by A12,A15,A16,A17,A18,A19,A20,A22,A23,A27;
    thus f2 is_non_decreasing_on y1,yn by A21,FINSEQ_6:165,XREAL_1:50;
    thus for j be Nat st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
    holds f2.j= t.intpos(m+j) by A21,XREAL_1:50;
    hereby
      let j be Nat;
      assume that
A31:  y1>=yn and
A32:  1<=j and
A33:  j<= n;
      thus f2.j=IExec(I,Q,t).intpos (m+j) by A27,A28,A32,A33
        .=t.intpos(m+j) by A12,A15,A16,A17,A19,A20,A31,A32,A33;
    end;
    hereby
      let j be Nat;
      assume that
A34:  1<=j and
A35:  j<2*k1+1;
      thus tk.intpos(m+n+j)=IExec(I,Q,t).intpos(m+n+j)
       by A26,SCMPDS_4:8
        .=t.intpos(m+n+j) by A12,A15,A16,A17,A18,A19,A20,A34,A35;
    end;
    y1>=yn implies IExec(I,Q,t).b=2*k1-1 &
    for j be Nat st 1<=j & j <= n
     holds IExec(I,Q,t).intpos (m+j) = t.intpos (m+j)
      by A12,A15,A16,A17,A19,A20;
    hence tk.b=t.b-2 by A16,A21,A26,SCMPDS_4:8,XREAL_1:50;
    IExec(I,Q,t).a=t.a by A12,A15,A16,A17,A18,A19,A20;
    hence thesis by A15,A26,SCMPDS_4:8;
  end;
A36: now
    let k be Nat;
    assume
A37: P[k];
    P[k+1]
    proof
      let t be 0-started State of SCMPDS,Q;
      let f1 be FinSequence of INT, k1,k2,y1,yn be Nat;
A38: Initialize t = t by MEMSTR_0:44;
      assume that
A39:  t.a=c and
A40:  2*k1+1=t.b and
A41:  k2=m+n+2*k1+1 and
A42:  1 <= y1 & yn <= n or y1 >= yn and
A43:  m+y1=t.intpos k2 and
A44:  m+yn=t.intpos(k2+1) and
A45:  yn-y1<=k+1 and
A46:  f1 is_FinSequence_on t,m and
A47:  len f1=n;
      per cases;
      suppose
        yn-y1<=0;
        hence ex kk be Nat,f2 be FinSequence of INT st
         Initialize Comput(Q+*sWH,t,kk)
    = Comput(Q+*sWH,t,kk) &
    f2 is_FinSequence_on
     Comput(Q+*sWH,t,kk),m &
    len f2=n & f1,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on
y1,yn & (for j be Nat st y1<yn & (1<=j & j<y1 or yn<j & j<= n) holds
f2.j= t.intpos(m+j)) & (for j be Nat st y1>=yn & 1<=j & j<= n holds
f2.j= t.intpos(m+j)) & (for j be Nat st (1<=j & j<2*k1+1) holds
Comput(Q+*sWH,t,kk).intpos(m+n+j)
=t.intpos(m+n+j)) &
 Comput(Q+*sWH,t,kk).b=
 t.b-2 & Comput(Q+*sWH,t,kk).a=c
  by A13,A39,A40,A41,A42,A43,A44,A46,A47;
      end;
      suppose
A48:    yn-y1>0;
        set m1=LifeSpan(Q+*stop I,t)+2;
        set t1= Comput(Q+*sWH,t,m1),
            Q1 = Q+*sWH;
A49:    I is_halting_on t,Q by A12,A39,A40,A41,A42,A43,A44;
        y1-1 >= 0 by A42,A48,XREAL_1:47,48;
        then reconsider y0=y1-1 as Element of NAT by INT_1:3;
        set jj=2*k1+1;
A50:    yn-y1-1 <= k+1-1 by A45,XREAL_1:9;
A51:    yn <= y1+(k+1) by A45,XREAL_1:20;
        consider f2 be FinSequence of INT such that
A52:    len f2=n and
A53:    for i be Nat st 1<=i & i <= len f2 holds f2.i=t1.
        intpos( m+i) by SCPISORT:1;
        set It=IExec(I,Q,t);
A54:    y1<yn implies It.b=2*k1+3 & (for j be Nat st 1<=j & j
<y1 or yn<j & j <= n holds IExec(I,Q,t).intpos (m+j)
 = t.intpos (m+j))
 & ex ym
be Nat st y1 <= ym & ym <= yn & m+y1=It.intpos k2 & m+ym-1=It.intpos
(k2+1) & m+ym+1=It.intpos (k2+2) & m+yn=It.intpos (k2+3) &
  (for j be Nat st y1 <= j & j < ym
 holds IExec(I,Q,t).intpos(m+j) <=
 IExec(I,Q,t).intpos(m+ym)
) & for j be Nat st ym < j & j <= yn
 holds IExec(I,Q,t).intpos(m+j) >=
        IExec(I,Q,t).intpos(m+ym) by A12,A39,A40,A41,A42,A43,A44;
        then consider ym be Nat such that
A55:    y1 <= ym and
A56:    ym <= yn and
A57:    m+y1=It.intpos k2 and
A58:    m+ym-1=It.intpos (k2+1) and
A59:    m+ym+1=It.intpos (k2+2) and
A60:    m+yn=It.intpos (k2+3) and
A61:    for j be Nat st y1 <= j & j < ym
 holds IExec(I,Q,t).
        intpos(m+j) <= IExec(I,Q,t).intpos(m+ym) and
A62:    for j be Nat st ym < j & j <= yn
holds IExec(I,Q,t).
        intpos(m+j) >= IExec(I,Q,t).intpos(m+ym) by A48,XREAL_1:47;
A63:    I is_closed_on t,Q by A12,A39,A40,A41,A42,A43,A44;
        then
A64:    DataPart t1 = DataPart IExec(I,Q,t) by A39,A40,A49,Th2,A38;
        then
A65:    t1.b=2*k1+3 by A48,A54,SCMPDS_4:8,XREAL_1:47;
A66:    ym >= 1 by A42,A48,A55,XREAL_1:47,XXREAL_0:2;
        then reconsider yc=ym-1 as Element of NAT by INT_1:3,XREAL_1:48;
A67:    yc <= yn by A56,XREAL_1:146,XXREAL_0:2;
        then
A68:    yc <= n by A42,A48,XREAL_1:47,XXREAL_0:2;
A69:    t1.b=2*(k1+1)+1 by A48,A54,A64,SCMPDS_4:8,XREAL_1:47;
        IExec(I,Q,t).a=t.a by A12,A39,A40,A41,A42,A43,A44;
        then
A70:    t1.a=c by A39,A64,SCMPDS_4:8;
        set k3=m+n+2*(k1+1)+1, yd=ym+1;
A71:    yd > ym by XREAL_1:29;
        then
A72:    yd >= y1 by A55,XXREAL_0:2;
        then
A73:    yd >= 1 by A42,A48,XREAL_1:47,XXREAL_0:2;
A74:    t1.intpos(k3+1)=m+yn by A41,A64,A60,SCMPDS_4:8;
        ym+(1+k) >= y1+(1+k) by A55,XREAL_1:6;
        then yn <= yd+k by A51,XXREAL_0:2;
        then
A75:    yn-yd<=k by XREAL_1:20;
A76:     t1.intpos k3=m+yd by A41,A64,A59,SCMPDS_4:8;
A77: (Initialize t1).a = t1.a by SCMPDS_5:15;
A78: (Initialize t1).b = t1.b by SCMPDS_5:15;
A79: (Initialize t1).intpos k3 = t1.intpos k3 by SCMPDS_5:15;
A80: (Initialize t1).intpos(k3+1) = t1.intpos(k3+1) by SCMPDS_5:15;
  f2 is_FinSequence_on (Initialize t1),m
   proof let i be Nat;
    assume 1 <= i & i <= len f2;
     then f2.i=t1.intpos(m+i) by A53;
    hence thesis by SCMPDS_5:15;
   end;
   then consider kl be Nat,f3 be FinSequence of INT such that
A81:   Initialize Comput(Q1+*sWH,(Initialize t1),kl)
          = Comput(Q1+*sWH,(Initialize t1),kl) and
A82: f3 is_FinSequence_on
     Comput(Q1+*sWH,(Initialize t1),kl),m and
A83: len f3=n and
A84: f2,f3 are_fiberwise_equipotent and
A85: f3 is_non_decreasing_on yd,yn and
A86: for j be Nat st yd<yn & (1<=j & j<yd or yn<j & j<= n)
      holds f3.j= (Initialize t1).intpos(m+j) and
A87: for j be Nat st yd>=yn & 1<=j & j<= n
     holds f3.j= (Initialize t1).intpos(m+j) and
A88: for j be Nat st 1<=j & j<2*(k1+1)+1
     holds Comput(Q1+*sWH,(Initialize t1),kl).intpos(m+n+j)
     =(Initialize t1).intpos(m+n+j) and
A89:  Comput(Q1+*sWH,(Initialize t1),kl).b=(Initialize t1).b-2 and
A90:  Comput(Q1+*sWH,(Initialize t1),kl).a=c
         by A37,A73,A75,A52,A42,A48,A70,A77,A69,A78,A76,A79,A74,A80,XREAL_1:47;
A91:    Initialize Comput(Q1+*sWH,Initialize t1,kl)
        = Comput(Q1+*sWH,Initialize t1,kl) by A81;
A92:    f3 is_FinSequence_on Comput(Q1+*sWH,Initialize t1,kl),m by A82;
A93:    len f3=n by A83;
A94:    f2,f3 are_fiberwise_equipotent by A84;
A95:    f3 is_non_decreasing_on yd,yn by A85;
A96:    for j be Nat st yd<yn & (1<=j & j<yd or yn<j & j<=n)
         holds f3.j= t1.intpos(m+j)
         proof let j be Nat;
          assume yd<yn & (1<=j & j<yd or yn<j & j<=n);
           then f3.j= (Initialize t1).intpos(m+j) by A86;
          hence thesis by SCMPDS_5:15;
         end;
A97:    for j be Nat st yd>=yn & 1<=j & j<= n
         holds f3.j=t1. intpos(m+j)
         proof let j be Nat;
          assume yd>=yn & 1<=j & j<= n;
           then f3.j= (Initialize t1).intpos(m+j) by A87;
          hence thesis by SCMPDS_5:15;
         end;
A98:    for j be Nat st 1<=j & j<2*(k1+1)+1
         holds Comput(Q1+*sWH,Initialize t1,kl).intpos(m+n+j)
                =t1.intpos(m+n+j)
        proof let j be Nat;
         assume 1<=j & j<2*(k1+1)+1;
          then Comput(Q1+*sWH,Initialize t1,kl).intpos(m+n+j)
                = (Initialize t1).intpos(m+n+j) by A88;
         hence thesis by SCMPDS_5:15;
        end;
        set t2= Comput(Q1+*sWH,Initialize t1,kl),
            Q2 = Q1+*sWH;
A99:    t2.b=t1.b-2 by A89,A78;
A100:    t2.a = c by A90;
A101:    2*k1+3=2*(k1+1)+1;
        then jj < 2*(k1+1)+1 by XREAL_1:6;
        then
A102:    t2.intpos k2=t1.intpos(m+n+jj) by A41,A98,NAT_1:11
          .=m+y1 by A41,A64,A57,SCMPDS_4:8;
A103:    ym <= n by A42,A48,A56,XREAL_1:47,XXREAL_0:2;
A104:    now
          per cases;
          suppose
            yd<yn;
            hence f3.ym= t1.intpos(m+ym) by A71,A96,A66;
          end;
          suppose
            yd>=yn;
            hence f3.ym= t1.intpos(m+ym) by A97,A66,A103;
          end;
        end;
A105:    now
          let i be Nat;
          assume that
A106:      1<=i and
A107:      i<=ym;
A108:      i<=n by A103,A107,XXREAL_0:2;
A109:      i<yd by A71,A107,XXREAL_0:2;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.i= t1.intpos(m+i) by A96,A106,A109;
            end;
            suppose
              yd>=yn;
              hence f3.i= t1.intpos(m+i) by A97,A106,A108;
            end;
          end;
          hence f3.i=f2.i by A52,A53,A106,A108;
        end;
        yc <= yn-1 by A56,XREAL_1:9;
        then yc-y1 <= yn-1-y1 by XREAL_1:9;
        then
A110:    yc-y1<=k by A50,XXREAL_0:2;
A111:    yc < yd by A71,XREAL_1:146,XXREAL_0:2;
        set jj=2*k1+2;
        jj >= 2 by NAT_1:11;
        then
A112:    jj >= 1 by XXREAL_0:2;
        jj < 2*(k1+1)+1 by A101,XREAL_1:6;
        then
A113:      t2.intpos (k2+1)=t1.intpos(m+n+jj) by A41,A98,A112
          .=m+yc by A41,A64,A58,SCMPDS_4:8;
A114:  1 <= y1 & yc <= n or y1 >= yc by A48,A68,A42,XREAL_1:47;
A115: (Initialize t2).a = t2.a by SCMPDS_5:15;
A116: (Initialize t2).b = t2.b by SCMPDS_5:15;
A117: (Initialize t2).intpos k2 = t2.intpos k2 by SCMPDS_5:15;
A118: (Initialize t2).intpos(k2+1) = t2.intpos(k2+1) by SCMPDS_5:15;
   f3 is_FinSequence_on (Initialize t2),m
    proof let i be Nat;
     assume 1 <= i & i <= len f3;
      then f3.i= t2.intpos(m+i) by A92;
    hence thesis by SCMPDS_5:15;
    end;
   then consider km be Nat,f4 be FinSequence of INT such that
A119:  Initialize Comput(Q2+*sWH,(Initialize t2),km)
          = Comput(Q2+*sWH,(Initialize t2),km) and
A120:  f4 is_FinSequence_on
     Comput(Q2+*sWH,(Initialize t2),km),m and
A121: len f4=n and
A122:    f3,f4 are_fiberwise_equipotent and
A123:   f4 is_non_decreasing_on y1,yc and
A124:  for j be Nat st y1<yc & (1<=j & j<y1 or yc<j & j<= n)
      holds f4.j= (Initialize t2).intpos(m+j) and
A125:  for j be Nat st y1>=yc & 1<=j & j<= n
      holds f4.j= (Initialize t2).intpos(m+j) and
A126:  for j be Nat st 1<=j & j<2*k1+1
     holds Comput(Q2+*sWH,(Initialize t2),km).intpos(m+n+j)
     =(Initialize t2).intpos(m+n+j) and
A127:  Comput(Q2+*sWH,(Initialize t2),km).b=(Initialize t2).b-2 and
A128:  Comput(Q2+*sWH,(Initialize t2),km).a=c
         by A37,A110,A93,A114,A41,A115,A100,A116,A65,A99,A117,A102,A118,A113;
A129:    Initialize Comput(Q2+*sWH,Initialize t2,km)
          = Comput(Q2+*sWH,Initialize t2,km) by A119;
A130:    f4 is_FinSequence_on Comput(Q2+*sWH,Initialize t2,km),m by A120;
A131:    len f4=n by A121;
A132:   f3,f4 are_fiberwise_equipotent by A122;
A133:   f4 is_non_decreasing_on y1,yc by A123;
A134:   for j be Nat st y1<yc & (1<=j & j<y1 or yc<j & j
        <= n) holds f4.j= t2.intpos(m+j)
          proof let j be Nat;
           assume y1<yc & (1<=j & j<y1 or yc<j & j <= n);
            then f4.j= (Initialize t2).intpos(m+j) by A124;
           hence thesis by SCMPDS_5:15;
          end;
A135:   for j be Nat st y1>=yc & 1<=j & j<= n
           holds f4.j= t2. intpos(m+j)
         proof let j be Nat;
          assume y1>=yc & 1<=j & j<= n;
           then f4.j= (Initialize t2).intpos(m+j) by A125;
           hence thesis by SCMPDS_5:15;
         end;
A136:   for j be Nat st 1<=j & j<2*k1+1 holds
         Comput(Q2+*sWH,Initialize t2,km).intpos(m+n+j)=t2.intpos(m+n+j)
         proof let j be Nat;
          assume 1<=j & j<2*k1+1;
           then Comput(Q2+*sWH,Initialize t2,km).intpos(m+n+j)
             =(Initialize t2).intpos(m+n+j) by A126;
           hence thesis by SCMPDS_5:15;
         end;
A137:   Comput(Q2+*sWH,Initialize t2,km).b=t2.b-2 by A127,A116;
A138:   Comput(Q2+*sWH,Initialize t2,km).a = c by A128;
A139:   now
          let i be Nat;
          assume that
A140:     yc<i and
A141:     i<=len f4;
A142:     1+0 <= i by A140,INT_1:7;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.i= t2.intpos(m+i) by A131,A134,A140,A141;
            end;
            suppose
              y1>=yc;
              hence f4.i= t2.intpos(m+i) by A131,A135,A141,A142;
            end;
          end;
          hence f4.i=f3.i by A92,A93,A131,A141,A142;
        end;
        then f4.ym=f3.ym by A131,A103,XREAL_1:146;
        then
A143:   f4.ym=IExec(I,Q,t).intpos(m+ym) by A64,A104,SCMPDS_4:8;
A144:   now
          let i be Nat;
          assume that
A145:     yn<i and
A146:     i<=len f3;
A147:     1+0<=i by A145,INT_1:7;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.i= t1.intpos(m+i) by A93,A96,A145,A146;
            end;
            suppose
              yd>=yn;
              hence f3.i= t1.intpos(m+i) by A93,A97,A146,A147;
            end;
          end;
          hence f3.i=f2.i by A52,A53,A93,A146,A147;
        end;
A148:   now
          let i be Nat;
          assume that
A149:     ym < i and
A150:     i <= yn;
          consider j be Nat such that
A151:     ym<j and
A152:     j<=yn and
A153:     f3.i=f2.j by A42,A48,A56,A93,A94,A105,A144,A149,A150,RFINSEQ:32
,XREAL_1:47;
A154:     yc < i by A149,XREAL_1:146,XXREAL_0:2;
A155:     1<=j by A66,A151,XXREAL_0:2;
A156:     j<=len f2 by A42,A48,A52,A152,XREAL_1:47,XXREAL_0:2;
          i<=len f4 by A42,A48,A131,A150,XREAL_1:47,XXREAL_0:2;
          then f4.i=f2.j by A139,A154,A153
            .=t1.intpos(m+j) by A53,A155,A156
            .=IExec(I,Q,t).intpos(m+j) by A64,SCMPDS_4:8;
          hence f4.ym <= f4.i by A62,A143,A151,A152;
        end;
A157:   yn>y1 by A48,XREAL_1:47;
A158:   now
          let i be Nat;
          assume that
A159:     1<=i and
A160:     i<=y0;
          i-1 < y1-1 by A160,XREAL_1:146,XXREAL_0:2;
          then
A161:     i<y1 by XREAL_1:9;
          y1 <= n by A42,A157,XXREAL_0:2;
          then
A162:     i<=n by A161,XXREAL_0:2;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.i= t2.intpos(m+i) by A134,A159,A161;
            end;
            suppose
              y1>=yc;
              hence f4.i= t2.intpos(m+i) by A135,A159,A162;
            end;
          end;
          hence f4.i=f3.i by A92,A93,A159,A162;
        end;
A163:   y0 <= yc by A55,XREAL_1:9;
A164:   now
          let i be Nat;
          assume that
A165:     y1 <= i and
A166:     i < ym;
          i+1 <= ym by A166,INT_1:7;
          then
A167:     i<=yc by XREAL_1:19;
          y0 < i by A165,XREAL_1:146,XXREAL_0:2;
          then consider j be Nat such that
A168:     y0<j and
A169:     j<=yc and
A170:     f4.i=f3.j by A68,A131,A132,A163,A158,A139,A167,RFINSEQ:32;
A171:     1+0 <= j by A168,INT_1:7;
A172:     j<= n by A68,A169,XXREAL_0:2;
A173:     j<yd by A111,A169,XXREAL_0:2;
          now
            per cases;
            suppose
              yd<yn;
              hence f3.j= t1.intpos(m+j) by A96,A171,A173;
            end;
            suppose
              yd>=yn;
              hence f3.j= t1.intpos(m+j) by A97,A171,A172;
            end;
          end;
          then
A174:     f4.i=IExec(I,Q,t).intpos(m+j) by A64,A170,SCMPDS_4:8;
A175:     j < ym by A169,XREAL_1:146,XXREAL_0:2;
          y1-1+1 <= j by A168,INT_1:7;
          hence f4.i <= f4.ym by A61,A143,A175,A174;
        end;
        take mm=m1+(kl+km);
        set tm=Comput(Q+*sWH,t,mm);
        take f4;
        Initialize t1 =t1 by A39,A40,A63,A49,Th2,A38;
        then
A176:   tm = Comput(Q+*sWH,Initialize t1,kl+km) by EXTPRO_1:4
          .= Comput(Q2+*sWH,Initialize t2,km)
          by A91,EXTPRO_1:4;
        hence Initialize tm =tm by A129;
        thus f4 is_FinSequence_on tm,m by A130,A176;
        thus len f4=n by A131;
        now
          let i be Nat;
          assume that
A177:     1<=i and
A178:     i <= len f2;
          thus f2.i=t1.intpos(m+i) by A53,A177,A178
            .=IExec(I,Q,t).intpos(m+i) by A64,SCMPDS_4:8;
        end;
        then f2 is_FinSequence_on IExec(I,Q,t),m;
        then f1,f2 are_fiberwise_equipotent by A12,A39,A40,A41,A42,A43,A44,A46
,A47,A52;
        then f1,f3 are_fiberwise_equipotent by A94,CLASSES1:76;
        hence f1,f4 are_fiberwise_equipotent by A132,CLASSES1:76;
A179:   now
          let j be Nat;
          assume that
A180:     yd<=j and
A181:     j<=yn;
A182:     1<=j by A73,A180,XXREAL_0:2;
A183:     j <= n by A42,A48,A181,XREAL_1:47,XXREAL_0:2;
A184:     yc < j by A111,A180,XXREAL_0:2;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.j=t2.intpos(m+j) by A134,A183,A184;
            end;
            suppose
              y1>=yc;
              hence f4.j=t2.intpos(m+j) by A135,A183,A182;
            end;
          end;
          hence f4.j=f3.j by A92,A93,A183,A182;
        end;
        now
          let i,j be Nat;
          assume that
A185:     yd <= i and
A186:     i <= j and
A187:     j <= yn;
          yd <= j by A185,A186,XXREAL_0:2;
          then
A188:     f4.j=f3.j by A179,A187;
          i <= yn by A186,A187,XXREAL_0:2;
          then f4.i=f3.i by A179,A185;
          hence f4.i <= f4.j by A95,A185,A186,A187,A188,FINSEQ_6:def 9;
        end;
        then f4 is_non_decreasing_on yd,yn by FINSEQ_6:def 9;
        hence f4 is_non_decreasing_on y1,yn by A133,A164,A148,Th8;
        thus for j be Nat st y1<yn & (1<=j & j<y1 or yn<j & j<= n)
        holds f4.j= t.intpos(m+j)
        proof
          let j be Nat;
          assume that
A189:     y1<yn and
A190:     1<=j & j<y1 or yn<j & j<= n;
A191:     1<=j & j<= n
          proof
            per cases by A190;
            suppose
A192:         1<=j & j<y1;
              then j<yn by A189,XXREAL_0:2;
              hence thesis by A42,A48,A192,XREAL_1:47,XXREAL_0:2;
            end;
            suppose
A193:         yn<j & j<=n;
              then y1 < j by A189,XXREAL_0:2;
              hence thesis by A42,A48,A193,XREAL_1:47,XXREAL_0:2;
            end;
          end;
A194:     1<=j & j<yd or yn<j & j<= n
          proof
            per cases by A190;
            suppose
              1<=j & j<y1;
              hence thesis by A72,XXREAL_0:2;
            end;
            suppose
              yn<j & j<=n;
              hence thesis;
            end;
          end;
A195:     now
            per cases;
            suppose
              yd<yn;
              hence f3.j=t1.intpos(m+j) by A96,A194;
            end;
            suppose
              yd>=yn;
              hence f3.j=t1.intpos(m+j) by A97,A191;
            end;
          end;
A196:     1<=j & j<y1 or yc<j & j<= n
          proof
            per cases by A190;
            suppose
              1<=j & j<y1;
              hence thesis;
            end;
            suppose
              yn<j & j<=n;
              hence thesis by A67,XXREAL_0:2;
            end;
          end;
          now
            per cases;
            suppose
              y1<yc;
              hence f4.j=t2.intpos(m+j) by A134,A196;
            end;
            suppose
              y1>=yc;
              hence f4.j=t2.intpos(m+j) by A135,A191;
            end;
          end;
          hence f4.j=f3.j by A92,A93,A191
            .=IExec(I,Q,t).intpos(m+j) by A64,A195,SCMPDS_4:8
            .=t.intpos(m+j) by A12,A39,A40,A41,A42,A43,A44,A189,A190;
        end;
        thus for j be Nat st y1>=yn & 1<=j & j<= n holds f4.j=t.
        intpos(m+j) by A48,XREAL_1:47;
        hereby
          let j be Nat;
          assume that
A197:     1<=j and
A198:     j<2*k1+1;
          2*k1+1 < 2*(k1+1)+1 by A101,XREAL_1:6;
          then
A199:     j < 2*(k1+1)+1 by A198,XXREAL_0:2;
          thus tm.intpos(m+n+j)=t2.intpos(m+n+j) by A136,A176,A197,A198
            .=t1.intpos(m+n+j) by A98,A197,A199
            .=IExec(I,Q,t).intpos(m+n+j) by A64,SCMPDS_4:8
            .=t.intpos(m+n+j) by A12,A39,A40,A41,A42,A43,A44,A197,A198;
        end;
        thus tm.b=t.b-2 by A40,A65,A99,A137,A176;
        thus tm.a=c by A138,A176;
      end;
    end;
    hence P[k+1];
  end;
A200: for k being Nat holds P[k] from NAT_1:sch 2(A13,A36);
  ex k be Nat,f2 be FinSequence of INT st
   Initialize Comput(P+*sWH,s,k)
   = Comput(P+*sWH,s,k) &
   f2 is_FinSequence_on Comput(P+*sWH,s,k),m &
len f2=n & f,f2 are_fiberwise_equipotent & f2 is_non_decreasing_on 1,n & (for j
be Nat st 1<n & (1<=j & j<1 or n<j & j<= n) holds f2.j= s.intpos(m+j
)) & (for j be Nat st 1>=n & 1<=j & j<= n holds f2.j= s.intpos(m+j))
  & (for j be Nat st (1<=j & j<2*0+1) holds
   Comput(P+*sWH,s,k).
intpos(m+n+j)=s.intpos(m+n+j)) &
Comput(P+*sWH,s,k).b=s.b-2 &
Comput(P+*sWH,s,k).a=c
  proof
    per cases;
    suppose
      n-1<=0;
      hence thesis by A2,A3,A5,A7,A9,A10,A13,A11;
    end;
    suppose
      n-1>0;
      then reconsider nn=n-1 as Element of NAT by INT_1:3;
      P[nn] by A200;
      hence thesis by A2,A3,A5,A7,A9,A10,A11;
    end;
  end;
  then consider k be Nat,f2 be FinSequence of INT such that
A201: Initialize Comput(P+*sWH,s,k)
= Comput(P+*sWH,s,k) and
A202: f2 is_FinSequence_on
    Comput(P+*sWH,s,k),m and
A203: len f2=n and
A204: f,f2 are_fiberwise_equipotent and
A205: f2 is_non_decreasing_on 1,n and
A206: Comput(P+*sWH,s,k).b=s.b-2 and
A207: Comput(P+*sWH,s,k).a=c;
  set sk= Comput(P+*sWH,s,k),
      s1 = Initialize sk, P1 = P+*sWH+*sWH,
      s2 = Comput(P1,s1,1), P2 = P1;
A208: IC s1 = 0 by MEMSTR_0:def 11;
  set i1=(a,i)<=0_goto (card I+2), i2=goto -(card I+1);
A209: card WH=card I+2 by SCMPDS_8:17;
  then
A210: (card I+2) in dom sWH by COMPOS_1:64;
A211: dom g = Seg n by A4,FINSEQ_1:def 3;
  sWH c= P2 by FUNCT_4:25;
  then
A212: P2.(card I+2) = sWH.(card I+2) by A210,GRFUNC_1:2
    .=halt SCMPDS by A209,COMPOS_1:64;
A213: WH = i1 ';' (I ';' i2 ) by Lm1;
A214: Comput(P1,s1,0+1) = Following(P1,Comput(P1,s1,0)) by EXTPRO_1:3
    .= Exec(i1,s1) by A213,SCMPDS_6:11;
  IC s2 = ICplusConst(s1,(card I+2)) by A7,A201,A206,A207,A214,SCMPDS_2:56
    .= 0+(card I+2) by A208,SCMPDS_6:12;
  then
A215: CurInstr(P2,s2) = halt SCMPDS by A212,PBOOLE:143;
A216: s2= Comput(P+*sWH,s,k+1) by A201,EXTPRO_1:4;
A217: P+*sWH halts_on s
 by A215,A216,EXTPRO_1:29;
  hence WH is_halting_on s,P by A1,SCMPDS_6:def 3;
A218: Result(P+*sWH,s)=s2
 by A215,A216,A217,EXTPRO_1:def 9;
  now
    let i be Nat;
    reconsider a = i as Nat;
    set xi=intpos (m+a);
    assume
A219: i in dom g;
    then
A220: 1 <= i by A211,FINSEQ_1:1;
A221: i <= n by A211,A219,FINSEQ_1:1;
    IExec(WH,P,s)=s2 by A218,SCMPDS_4:def 5;
    hence g.i = s2.xi by A4,A6,A220,A221
      .=s1.xi by A214,SCMPDS_2:56
      .=f2.i by A201,A202,A203,A220,A221;
  end;
  hence thesis by A4,A203,A204,A205,FINSEQ_2:9;
end;

Lm4: for s be 0-started State of SCMPDS,
         I be halt-free shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,m,n,m1 be Nat st s.a=c &
1=s.DataLoc(c,i) & m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be 0-started State of SCMPDS,Q
  for f1,f2 be FinSequence of INT, k1,k2,y1,yn be Nat st t
.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=t.intpos
(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t,Q & I
is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Nat
 st (1<=j & j<2*k1
+1) holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j)) & (y1>=yn
 implies IExec(I,Q,t).DataLoc(c,i)=2*k1-1
  & (for j be Nat st (1<=j & j <= n) holds IExec
(I,Q,t).intpos (m+j) = t.intpos (m+j))) & (y1<yn
 implies IExec(I,Q,t).DataLoc(c,i)=
2*k1+3 & (for j be Nat st 1<=j & j<y1 or yn<j & j <= n holds
IExec(I,Q,t).intpos(m+j) = t.intpos (m+j))
 & (ex ym be Nat st y1 <= ym
& ym <= yn & m+y1=IExec(I,Q,t).intpos k2
 & m+ym-1=IExec(I,Q,t).intpos (k2+1) & m+ym
+1=IExec(I,Q,t).intpos (k2+2) & m+yn=
IExec(I,Q,t).intpos (k2+3)
 & (for j be Nat st y1 <= j & j < ym
 holds IExec(I,Q,t).intpos (m+j) <= IExec(I,Q,t).intpos (
m+ym)) & (for j be Nat st ym < j & j <= yn
 holds IExec(I,Q,t).intpos (
m+j) >= IExec(I,Q,t).intpos (m+ym)))) & (f1 is_FinSequence_on t,m
 & f2
is_FinSequence_on IExec(I,Q,t),m & len f1=n & len f2=n implies f1,f2
are_fiberwise_equipotent)) holds while>0(a,i,I) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,m,n,m1 be Nat;
  set b=DataLoc(c,i);
  assume
A1: s.a=c;
  consider f be FinSequence of INT such that
A2: len f=n and
A3: for i be Nat st 1<=i & i <= len f holds f.i=s.intpos(m+i)
  by SCPISORT:1;
A4: f is_FinSequence_on s,m by A3;
  set ss=IExec(while>0(a,i,I),P,s);
  assume
A5: 1=s.b;
  consider g be FinSequence of INT such that
A6: len g=n and
A7: for i be Nat st 1<=i & i <= len g holds g.i=ss.intpos(m+
  i ) by SCPISORT:1;
A8: g is_FinSequence_on ss,m by A7;
  assume that
A9: m1=m+n+1 and
A10: m+1=s.intpos m1 and
A11: m+n=s.intpos(m1+1);
  assume
  for t be 0-started State of SCMPDS,Q
  for f1,f2 be FinSequence of INT, k1,k2,y1,yn be
Nat st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=
  t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t,Q & I
is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Nat
 st (1<=j & j<2*k1
+1) holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j))
 & (y1>=yn implies IExec(I,Q,t).b=2*k1-1
  & for j be Nat st 1<=j & j <= n
 holds IExec(I,Q,t).intpos (
  m+j) = t.intpos (m+j) ) & (y1<yn implies IExec(I,Q,t).b=2*k1+3
   & (for j be Nat st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos (m+j
  ) = t.intpos (m+j)) & ex ym be Nat st y1 <= ym & ym <= yn & m+y1=
  IExec(I,Q,t).intpos k2 & m+ym-1=
  IExec(I,Q,t).intpos (k2+1)
   & m+ym+1=IExec(I,Q,t).
intpos (k2+2) & m+yn=IExec(I,Q,t).intpos (k2+3)
 & (for j be Nat st y1 <= j & j < ym
 holds IExec(I,Q,t).intpos(m+j) <=
 IExec(I,Q,t).intpos(m+ym)) & for j be Nat st ym < j & j <= yn
 holds IExec(I,Q,t).intpos(m+j) >=
 IExec(I,Q,t).intpos(m+ym) )
  & (f1 is_FinSequence_on t,m
 & f2 is_FinSequence_on IExec(I,Q,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);
  hence thesis by A1,A5,A9,A10,A11,A2,A4,A6,A8,Lm3;
end;

Lm5: for s be 0-started State of SCMPDS,
         I be halt-free shiftable Program of SCMPDS, a
be Int_position, i,c be Integer,m,n,m1 be Nat st s.a=c &
1=s.DataLoc(c,i) & m1=m+n+1 & m+1=s.intpos m1 & m+n=s.intpos(m1+1) &
 (for t be 0-started State of SCMPDS,Q
  for f1,f2 be FinSequence of INT, k1,k2,y1,yn be Nat st t
.a=c & 2*k1+1=t.DataLoc(c,i) & k2=m+n+2*k1+1 & m+y1=t.intpos k2 &
  m+yn=t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn)
   holds I is_closed_on t,Q & I
is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Nat
 st (1<=j & j<2*k1
+1) holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j))
 & (y1>=yn implies IExec(I,Q,t).DataLoc(c,i)=2*k1-1
  & (for j be Nat st (1<=j & j <= n) holds IExec
(I,Q,t).intpos (m+j) = t.intpos (m+j)))
 & (y1<yn implies IExec(I,Q,t).DataLoc(c,i)=
2*k1+3 & (for j be Nat st 1<=j & j<y1 or yn<j & j <= n holds
IExec(I,Q,t).intpos(m+j) = t.intpos (m+j))
 & (ex ym be Nat st y1 <= ym
& ym <= yn & m+y1=IExec(I,Q,t).intpos k2
 & m+ym-1=IExec(I,Q,t).intpos (k2+1) & m+ym
+1=IExec(I,Q,t).intpos (k2+2) &
m+yn=IExec(I,Q,t).intpos (k2+3)
 & (for j be Nat st y1 <= j & j < ym
 holds IExec(I,Q,t).intpos (m+j) <= IExec(I,Q,t).intpos (
m+ym)) & (for j be Nat st ym < j & j <= yn
 holds IExec(I,Q,t).intpos (
m+j) >= IExec(I,Q,t).intpos (m+ym)))) & (f1 is_FinSequence_on t,m
 & f2
is_FinSequence_on IExec(I,Q,t),m & len f1=n & len f2=n implies f1,f2
are_fiberwise_equipotent))
 holds while>0(a,i,I) is_halting_on s,P & while>0(a,i,I) is_closed_on s,P
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i,c be Integer,m,n,m1 be Nat;
  set b=DataLoc(c,i);
  assume
A1: s.a=c;
  assume
A2: 1=s.b;
  assume that
A3: m1=m+n+1 and
A4: m+1=s.intpos m1 and
A5: m+n=s.intpos(m1+1);
  assume
A6: for t be 0-started State of SCMPDS,Q
   for f1,f2 be FinSequence of INT, k1,k2,y1,yn be
Nat st t.a=c & 2*k1+1=t.b & k2=m+n+2*k1+1 & m+y1=t.intpos k2 & m+yn=
  t.intpos(k2+1) & (1 <= y1 & yn <= n or y1 >= yn) holds I is_closed_on t,Q & I
is_halting_on t,Q & IExec(I,Q,t).a=t.a & (for j be Nat
 st (1<=j & j<2*k1
+1) holds IExec(I,Q,t).intpos(m+n+j)=t.intpos(m+n+j))
 & (y1>=yn implies IExec(I,Q,t).b=2*k1-1
  & for j be Nat st 1<=j & j <= n
 holds IExec(I,Q,t).intpos (
  m+j) = t.intpos (m+j) ) & (y1<yn implies IExec(I,Q,t).b=2*k1+3
   & (for j be
Nat st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos (m+j
  ) = t.intpos (m+j)) & ex ym be Nat st y1 <= ym & ym <= yn & m+y1=
  IExec(I,Q,t).intpos k2 & m+ym-1=
  IExec(I,Q,t).intpos (k2+1)
   & m+ym+1=IExec(I,Q,t).
intpos (k2+2) & m+yn=IExec(I,Q,t).intpos (k2+3)
 & (for j be Nat st y1
<= j & j < ym holds IExec(I,Q,t).intpos(m+j) <=
IExec(I,Q,t).intpos(m+ym))
 & for j
be Nat st ym < j & j <= yn
 holds IExec(I,Q,t).intpos(m+j) >=
 IExec(I,Q,t).intpos(m+ym) )
  & (f1 is_FinSequence_on t,m & f2 is_FinSequence_on IExec(I,Q,t),
  m & len f1=n & len f2=n implies f1,f2 are_fiberwise_equipotent);
A7: now
    let v be 0-started State of SCMPDS;
    let V;
    assume
A8: DataPart v = DataPart s;
    then
A9: 1 =v.b by A2,SCMPDS_4:8;
A10: m+n =v.intpos (m1+1) by A5,A8,SCMPDS_4:8;
A11: m+1 =v.intpos m1 by A4,A8,SCMPDS_4:8;
    v.a =c by A1,A8,SCMPDS_4:8;
    hence while>0(a,i,I) is_halting_on v,V by A3,A6,A9,A11,A10,Lm4;
  end;
  hence while>0(a,i,I) is_halting_on s,P;
  thus thesis by A7,Th3;
end;

begin :: Program Partition is to split a sequence into a "smaller" and

::       a "larger" subsequence
:: a5=a7=length  a2=mid(x[1]), a3=x[2], a4=x[n], a6=save

definition
  func Partition -> Program of SCMPDS equals
  ((GBP,5):=(GBP,4) ';' SubFrom(GBP
,5,GBP,2) ';' (GBP,3):=(GBP,2) ';' AddTo(GBP,3,1)) ';' while>0(GBP,5, while>0(
  GBP,5, (GBP,7):=(GBP,5) ';' AddTo(GBP,5,-1) ';' (GBP,6):=(intpos 4,0) ';'
SubFrom(GBP,6,intpos 2,0) ';' if>0(GBP,6, AddTo(GBP,4,-1) ';' AddTo(GBP,7,-1),
Load (GBP,5):=0 ) ) ';' while>0(GBP,7, (GBP,5):=(GBP,7) ';' AddTo(GBP,7,-1) ';'
(GBP,6):=(intpos 2,0) ';' SubFrom(GBP,6,intpos 3,0) ';' if>0(GBP,6, AddTo(GBP,3
,1) ';' AddTo(GBP,5,-1), Load (GBP,7):=0 ) ) ';' if>0(GBP,5,((GBP,6):=(intpos 4
,0) ';' (intpos 4,0):=(intpos 3,0) ';' (intpos 3,0):=(GBP,6) ';' AddTo(GBP,5,-2
  ) ';' AddTo(GBP,3,1)) ';' AddTo(GBP,4,-1) ) ) ';' (GBP,6):=(intpos 4,0) ';' (
  intpos 4,0):=(intpos 2,0) ';' (intpos 2,0):=(GBP,6);
  coherence;
end;

begin :: The Construction of Quick Sort

:: a0=global, a1=stack, a2=stack depth

definition
  let n,p0 be Nat;
  func QuickSort(n,p0) -> Program of SCMPDS equals
  ((GBP:=0) ';' (SBP:=1) ';'
(SBP,p0+n):=(p0+1) ';' (SBP,p0+n+1):=(p0+n)) ';' while>0(GBP,1, (GBP,2):=(SBP,
  p0+n+1) ';' SubFrom(GBP,2,SBP,p0+n) ';' if>0(GBP,2, (GBP,2):=(SBP,p0+n) ';' (
GBP,4):=(SBP,p0+n+1) ';' Partition ';' (((SBP,p0+n+3):=(SBP,p0+n+1) ';' (SBP,p0
  +n+1):=(GBP,4) ';' (SBP,p0+n+2):=(GBP,4) ';' AddTo(SBP,p0+n+1,-1)) ';' AddTo(
  SBP,p0+n+2,1) ';' AddTo(GBP,1,2)), Load AddTo(GBP,1,-2) ) );
  coherence;
end;

set i1= (GBP,7):=(GBP,5), i2= AddTo(GBP,5,-1), i3= (GBP,6):=(intpos 4,0), i4=
SubFrom(GBP,6,intpos 2,0), i5= AddTo(GBP,4,-1), i6= AddTo(GBP,7,-1), i7= Load (
GBP,5):=0, IF1= if>0(GBP,6,i5 ';' i6,i7), WB1= i1 ';' i2 ';' i3 ';' i4 ';' IF1,
WH1= while>0(GBP,5,WB1), j1= (GBP,5):=(GBP,7), j2= AddTo(GBP,7,-1), j3= (GBP,6)
:=(intpos 2,0), j4= SubFrom(GBP,6,intpos 3,0), j5= AddTo(GBP,3,1), j6= AddTo(
GBP,5,-1), j7= Load (GBP,7):=0, IF2= if>0(GBP,6,j5 ';' j6, j7), WB2= j1 ';' j2
';' j3 ';' j4 ';' IF2,
WH2= while>0(GBP,7,WB2),
k1 = (GBP,5):=(GBP,4), k2 =
SubFrom(GBP,5,GBP,2), k3 = (GBP,3):=(GBP,2), k4 = AddTo(GBP,3,1), K4 = k1 ';'
k2 ';' k3 ';' k4, k5 = (GBP,6):=(intpos 4,0), k6 = (intpos 4,0):=(intpos 3,0),
k7 = (intpos 3,0):=(GBP,6), k8 = AddTo(GBP,5,-2), k9 = AddTo(GBP,3,1), k0 =
AddTo(GBP,4,-1), IF3= if>0(GBP,5, k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0), WB3=
WH1 ';' WH2 ';' IF3, WH3= while>0(GBP,5,WB3), j8 = (GBP,6):=(intpos 4,0), j9 =
(intpos 4,0):=(intpos 2,0), j0 = (intpos 2,0):=(GBP,6);

set a1=intpos 1, a2=intpos 2, a3=intpos 3, a4=intpos 4, a5=intpos 5, a6=intpos
6, a7=intpos 7;

Lm6: card WB1=9
proof
  thus card WB1= card (i1 ';' i2 ';' i3 ';' i4) + card IF1 by AFINSQ_1:17
    .= 4+card IF1 by Th4
    .= 4+(card (i5 ';' i6)+card i7+2) by SCMPDS_6:65
    .= 4+(2+card i7+2) by SCMP_GCD:5
    .= 4+(2+1+2) by COMPOS_1:54
    .= 9;
end;

Lm7:
 for s being 0-started State of SCMPDS,
md,me be Nat st s.a2=md & s.a4=me
& md >= 8 & me >= 8 & s.GBP=0
 holds IExec(WB1,P,s).GBP=0 &
  IExec(WB1,P,s).a1=s.a1 &
  IExec(WB1,P,s).a2=s.a2 &
  IExec(WB1,P,s).a3=s.a3 &
  (for i be Nat st i >= 8
   holds IExec(WB1,P,s).intpos i=s.intpos i) &
    (s.intpos md < s.intpos me implies
      IExec(WB1,P,s).a5=s.a5-1 &
      IExec(WB1,P,s).a4=s.a4-1 &
      IExec(WB1,P,s).a7=s.a5-1) &
    (s.intpos md >= s.intpos me implies
      IExec(WB1,P,s).a5=0 &
      IExec(WB1,P,s).a4=s.a4 &
      IExec(WB1,P,s).a7=s.a5)
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,md,me be Nat;
  assume that
A1: s.a2=md and
A2: s.a4=me and
A3: md >= 8 and
A4: me >= 8 and
A5: s.a=0;
  set t0=s, Q0 = P,
  t1=IExec(i1 ';' i2 ';' i3 ';' i4,P,s),
      Q1 = P,
      t2=IExec(i1 ';' i2 ';' i3,P,s),
      t3=IExec(i1 ';' i2,P,s),
      Q2 = P,
      t4=Exec(i1, t0), Q4 = Q0;

A6: t0.a=0 by A5;
A7: DataLoc(t0.a,7)=intpos (0+7) by A5,SCMP_GCD:1;
  then
A8: t4.a =0 by A6,AMI_3:10,SCMPDS_2:47;
  then
A9: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:1;
A10: t4.a4 =me by A7,A2,AMI_3:10,SCMPDS_2:47;
A11: t3.a4 =Exec(i2, t4).a4 by SCMPDS_5:42
    .=me by A10,A9,AMI_3:10,SCMPDS_2:48;
  then
A12: DataLoc(t3.a4,0)=intpos (me+0) by SCMP_GCD:1;
A13: t3.a =Exec(i2, t4).a by SCMPDS_5:42
    .=0 by A8,A9,AMI_3:10,SCMPDS_2:48;
  then
A14: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:1;
A15: t4.a2 =md by A7,A1,AMI_3:10,SCMPDS_2:47;
A16: t3.a2 =Exec(i2, t4).a2 by SCMPDS_5:42
    .=md by A15,A9,AMI_3:10,SCMPDS_2:48;
A17: t4.a5 =s.a5 by A7,AMI_3:10,SCMPDS_2:47;
  set t01=Initialize Initialize t1, ii7= (GBP,5):=0, t5=Exec(i5,t01);
A18: t2.a2 =Exec(i3, t3).a2 by SCMPDS_5:41
    .=md by A16,A14,AMI_3:10,SCMPDS_2:47;
A19: t2.a =Exec(i3, t3).a by SCMPDS_5:41
    .=0 by A13,A14,AMI_3:10,SCMPDS_2:47;
  then
A20: DataLoc(t2.a,6)=intpos (0+6) by SCMP_GCD:1;
  DataLoc(t0.a,5)=intpos (0+5) by A6,SCMP_GCD:1;
  then
A21: t4.a7 =s.a5 by A7,SCMPDS_2:47;
A22: t3.a7 =Exec(i2, t4).a7 by SCMPDS_5:42
    .=s.a5 by A21,A9,AMI_3:10,SCMPDS_2:48;
A23: t2.a7 =Exec(i3, t3).a7 by SCMPDS_5:41
    .=s.a5 by A22,A14,AMI_3:10,SCMPDS_2:47;
  t1.a7 =Exec(i4, t2).a7 by SCMPDS_5:41
    .=s.a5 by A23,A20,AMI_3:10,SCMPDS_2:50;
  then
A24: t01.a7=s.a5 by SCMPDS_5:15;
  t1.a2 =Exec(i4, t2).a2 by SCMPDS_5:41
    .=md by A18,A20,AMI_3:10,SCMPDS_2:50;
  then
A25: t01.a2=s.a2 by A1,SCMPDS_5:15;
A26: now
    let i be Nat;
    assume i>=8;
    then i > 7 by XXREAL_0:2;
    hence t4.intpos i = s.intpos i by A7,AMI_3:10,SCMPDS_2:47;
  end;
A27: now
    let i be Nat;
    assume
A28: i>=8;
    then
A29: i > 5 by XXREAL_0:2;
    thus t3.intpos i =Exec(i2, t4).intpos i by SCMPDS_5:42
      .=t4.intpos i by A9,A29,AMI_3:10,SCMPDS_2:48
      .=s.intpos i by A26,A28;
  end;
A30: now
    let i be Nat;
    assume
A31: i>=8;
    then
A32: i > 6 by XXREAL_0:2;
    thus t2.intpos i=Exec(i3, t3).intpos i by SCMPDS_5:41
      .=t3.intpos i by A14,A32,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by A27,A31;
  end;
A33: now
    let i be Nat;
    assume
A34: i>=8;
    then
A35: i > 6 by XXREAL_0:2;
    thus t1.intpos i=Exec(i4, t2).intpos i by SCMPDS_5:41
      .=t2.intpos i by A20,A35,AMI_3:10,SCMPDS_2:50
      .=s.intpos i by A30,A34;
  end;
A36: t4.a3 =s.a3 by A7,AMI_3:10,SCMPDS_2:47;
A37: t3.a3 =Exec(i2, t4).a3 by SCMPDS_5:42
    .=s.a3 by A36,A9,AMI_3:10,SCMPDS_2:48;
A38: t4.a1 =s.a1 by A7,AMI_3:10,SCMPDS_2:47;
A39: t3.a1 =Exec(i2, t4).a1 by SCMPDS_5:42
    .=s.a1 by A38,A9,AMI_3:10,SCMPDS_2:48;
A40: t2.a1 =Exec(i3, t3).a1 by SCMPDS_5:41
    .=s.a1 by A39,A14,AMI_3:10,SCMPDS_2:47;
  t1.a1 =Exec(i4, t2).a1 by SCMPDS_5:41
    .=s.a1 by A40,A20,AMI_3:10,SCMPDS_2:50;
  then
A41: t01.a1=s.a1 by SCMPDS_5:15;
A42: t2.a3 =Exec(i3, t3).a3 by SCMPDS_5:41
    .=s.a3 by A37,A14,AMI_3:10,SCMPDS_2:47;
  t1.a3 =Exec(i4, t2).a3 by SCMPDS_5:41
    .=s.a3 by A42,A20,AMI_3:10,SCMPDS_2:50;
  then
A43: t01.a3=s.a3 by SCMPDS_5:15;
A44: t1.a =Exec(i4, t2).a by SCMPDS_5:41
    .=0 by A19,A20,AMI_3:10,SCMPDS_2:50;
  then
A45: t01.a=0 by SCMPDS_5:15;
  then
A46: DataLoc(t01.a,5)=intpos(0+5) by SCMP_GCD:1;
  a3<>DataLoc(t01.a,4) by A45,AMI_3:10,SCMP_GCD:1;
  then
A47: t5.a3=s.a3 by A43,SCMPDS_2:48;
  a2<>DataLoc(t01.a,4) by A45,AMI_3:10,SCMP_GCD:1;
  then
A48: t5.a2=s.a2 by A25,SCMPDS_2:48;
  a<>DataLoc(t01.a,4) by A45,AMI_3:10,SCMP_GCD:1;
  then
A49: t5.a=0 by A45,SCMPDS_2:48;
  then
A50: DataLoc(t5.a,7)=intpos(0+7) by SCMP_GCD:1;
A51: t2.a6 =Exec(i3, t3).a6 by SCMPDS_5:41
    .=t3.intpos me by A14,A12,SCMPDS_2:47
    .=s.intpos me by A4,A27;
  t1.a6 =Exec(i4, t2).a6 by SCMPDS_5:41
    .=t2.a6-t2.DataLoc(t2.a2,0) by A20,SCMPDS_2:50
    .=t2.a6-t2.intpos(md+0) by A18,SCMP_GCD:1
    .=s.intpos me - s.intpos md by A3,A51,A30;
  then
A52: t1.DataLoc(t1.a,6)=s.intpos me - s.intpos md by A44,SCMP_GCD:1;
  a1<>DataLoc(t01.a,4) by A45,AMI_3:10,SCMP_GCD:1;
  then
A53: t5.a1=s.a1 by A41,SCMPDS_2:48;
A54: now
    per cases;
    suppose
A55:  t01.DataLoc(t01.a,6) <= 0;
      hence IExec(IF1,Q1,Initialize t1).a
      =IExec(i7,Q1,Initialize t1).a by SCMPDS_6:74
        .=Exec(ii7,t01).a by SCMPDS_5:40
        .=0 by A45,A46,AMI_3:10,SCMPDS_2:46;
      thus IExec(IF1,Q1,Initialize t1).a1
      =IExec(i7,Q1,Initialize t1).a1 by A55,SCMPDS_6:74
        .=Exec(ii7,t01).a1 by SCMPDS_5:40
        .=s.a1 by A41,A46,AMI_3:10,SCMPDS_2:46;
      thus IExec(IF1,Q1,Initialize t1).a2
      =IExec(i7,Q1,Initialize t1).a2 by A55,SCMPDS_6:74
        .=Exec(ii7,t01).a2 by SCMPDS_5:40
        .=s.a2 by A25,A46,AMI_3:10,SCMPDS_2:46;
      thus IExec(IF1,Q1,Initialize t1).a3
      =IExec(i7,Q1,Initialize t1).a3 by A55,SCMPDS_6:74
        .=Exec(ii7,t01).a3 by SCMPDS_5:40
        .=s.a3 by A43,A46,AMI_3:10,SCMPDS_2:46;
        let i be Nat;
        assume
A56:    i>=8;
        then
A57:    i > 5 by XXREAL_0:2;
        thus IExec(WB1,P,s).intpos i=
        IExec(IF1,Q1,Initialize t1).intpos i by SCMPDS_5:35
          .=IExec(i7,Q1,Initialize t1).intpos i by A55,SCMPDS_6:74
          .=Exec(ii7,t01).intpos i by SCMPDS_5:40
          .=t01.intpos i by A46,A57,AMI_3:10,SCMPDS_2:46
          .=t1.intpos i by SCMPDS_5:15
          .=s.intpos i by A33,A56;
    end;
    suppose
A58:  t01.DataLoc(t01.a,6) > 0;
      thus IExec(IF1,Q1,Initialize t1).a
      =IExec(i5 ';' i6,Q1,Initialize t1).a
       by A58,SCMPDS_6:73
        .=Exec(i6,t5).a by SCMPDS_5:42
        .=0 by A49,A50,AMI_3:10,SCMPDS_2:48;
      thus IExec(IF1,Q1,Initialize t1).a1
      =IExec(i5 ';' i6,Q1,Initialize t1).a1
       by A58,SCMPDS_6:73
        .=Exec(i6,t5).a1 by SCMPDS_5:42
        .=s.a1 by A53,A50,AMI_3:10,SCMPDS_2:48;
      thus IExec(IF1,Q1,Initialize t1).a2
      =IExec(i5 ';' i6,Q1,Initialize t1).a2
       by A58,SCMPDS_6:73
        .=Exec(i6,t5).a2 by SCMPDS_5:42
        .=s.a2 by A48,A50,AMI_3:10,SCMPDS_2:48;
      thus IExec(IF1,Q1,Initialize t1).a3
      =IExec(i5 ';' i6,Q1,Initialize t1).a3
       by A58,SCMPDS_6:73
        .=Exec(i6,t5).a3 by SCMPDS_5:42
        .=s.a3 by A47,A50,AMI_3:10,SCMPDS_2:48;
        let i be Nat;
        assume
A59:    i>=8;
        then
A60:    i > 7 by XXREAL_0:2;
        i > 4 by A59,XXREAL_0:2;
        then
A61:    intpos i<>DataLoc(t01.a,4) by A45,AMI_3:10,SCMP_GCD:1;
        thus IExec(WB1,P,s).intpos i=
        IExec(IF1,Q1,Initialize t1).intpos i by SCMPDS_5:35
          .=IExec(i5 ';' i6,Q1,Initialize t1).intpos i by A58,SCMPDS_6:73
          .=Exec(i6,t5).intpos i by SCMPDS_5:42
          .=t5.intpos i by A50,A60,AMI_3:10,SCMPDS_2:48
          .=t01.intpos i by A61,SCMPDS_2:48
          .=t1.intpos i by SCMPDS_5:15
          .=s.intpos i by A33,A59;
    end;
  end;
  hence IExec(WB1,P,s).a=0 & IExec(WB1,P,s).a1=s.a1
   & IExec(WB1,P,s).a2=s.a2 & IExec(WB1,P,s).a3=s.a3
    by SCMPDS_5:35;
  thus for i be Nat st i >= 8
  holds IExec(WB1,P,s).intpos i=s.intpos i by A54;
A62: t3.a5 =Exec(i2, t4).a5 by SCMPDS_5:42
    .=t4.a5+ -1 by A9,SCMPDS_2:48
    .=s.a5-1 by A17;
A63: t2.a5 =Exec(i3, t3).a5 by SCMPDS_5:41
    .=s.a5-1 by A62,A14,AMI_3:10,SCMPDS_2:47;
  t1.a5 =Exec(i4, t2).a5 by SCMPDS_5:41
    .=s.a5-1 by A63,A20,AMI_3:10,SCMPDS_2:50;
  then
A64: t01.a5=s.a5-1 by SCMPDS_5:15;
A65: t2.a4 =Exec(i3, t3).a4 by SCMPDS_5:41
    .=me by A11,A14,AMI_3:10,SCMPDS_2:47;
  t1.a4 =Exec(i4, t2).a4 by SCMPDS_5:41
    .=me by A65,A20,AMI_3:10,SCMPDS_2:50;
  then
A66: t01.a4=s.a4 by A2,SCMPDS_5:15;
A67: DataLoc(t01.a,4)=intpos(0+4) by A45,SCMP_GCD:1;
A68: t01.DataLoc(t01.GBP,6) = t01.DataLoc(t1.GBP,6) by SCMPDS_5:15
          .= t1.DataLoc(t1.GBP,6) by SCMPDS_5:15;
  hereby
A69: a5<>DataLoc(t01.a,4) by A45,AMI_3:10,SCMP_GCD:1;
    assume s.intpos md < s.intpos me; then
A70: 0<s.intpos me - s.intpos md by XREAL_1:50;
A71: t01.DataLoc(t01.GBP,6) = t01.DataLoc(t1.GBP,6) by SCMPDS_5:15
          .= t1.DataLoc(t1.GBP,6) by SCMPDS_5:15;
    thus IExec(WB1,P,s).a5=IExec(IF1,Q1,t01).a5 by SCMPDS_5:35
      .=IExec(i5 ';' i6,Q1,t01).a5 by A52,A70,A71,SCMPDS_6:73
      .=Exec(i6,t5).a5 by SCMPDS_5:42
      .=t5.a5 by A50,AMI_3:10,SCMPDS_2:48
      .=s.a5-1 by A64,A69,SCMPDS_2:48;
    thus IExec(WB1,P,s).a4=IExec(IF1,Q1,Initialize t01).a4
     by SCMPDS_5:35
      .=IExec(i5 ';' i6,Q1,Initialize t01).a4 by A52,A71,A70,SCMPDS_6:73
      .=Exec(i6,t5).a4 by SCMPDS_5:42
      .=t5.a4 by A50,AMI_3:10,SCMPDS_2:48
      .=t01.a4+-1 by A67,SCMPDS_2:48
      .=s.a4-1 by A66;
A72: a7<>DataLoc(t01.a,4) by A45,AMI_3:10,SCMP_GCD:1;
    thus IExec(WB1,P,s).a7=IExec(IF1,Q1,Initialize t1).a7
     by SCMPDS_5:35
      .=IExec(i5 ';' i6,Q1,Initialize t1).a7 by A52,A71,A70,SCMPDS_6:73
      .=Exec(i6,t5).a7 by SCMPDS_5:42
      .=t5.a7+ -1 by A50,SCMPDS_2:48
      .=t5.a7-1
      .=s.a5-1 by A24,A72,SCMPDS_2:48;
  end;
    assume s.intpos md >= s.intpos me;
   then
A73: s.intpos me - s.intpos md <= 0 by XREAL_1:47;
    thus IExec(WB1,P,s).a5=IExec(IF1,Q1,Initialize t1).a5
     by SCMPDS_5:35
      .=IExec(i7,Q1,Initialize t1).a5 by A52,A68,A73,SCMPDS_6:74
      .=Exec(ii7,t01).a5 by SCMPDS_5:40
      .=0 by A46,SCMPDS_2:46;
    thus IExec(WB1,P,s).a4
    =IExec(IF1,Q1,Initialize t1).a4
     by SCMPDS_5:35
      .=IExec(i7,Q1,Initialize t1).a4 by A52,A68,A73,SCMPDS_6:74
      .=Exec(ii7,t01).a4 by SCMPDS_5:40
      .=s.a4 by A46,A66,AMI_3:10,SCMPDS_2:46;
    thus IExec(WB1,P,s).a7=IExec(IF1,Q1,Initialize t1).a7
     by SCMPDS_5:35
      .=IExec(i7,Q1,Initialize t1).a7 by A52,A68,A73,SCMPDS_6:74
      .=Exec(ii7,t01).a7 by SCMPDS_5:40
      .=s.a5 by A24,A46,AMI_3:10,SCMPDS_2:46;
end;

Lm8: for s being 0-started State of SCMPDS,
m4,md be Nat st s.GBP=0 & s.a5 > 0
& s.a4=m4+s.a5 & m4>=8 & s.a2=md & md >= 8
 holds IExec(WH1,P,s).GBP=0 & IExec(WH1,P,s).a1=s.a1
  & IExec(WH1,P,s).a5=0 & IExec(WH1,P,s).a2=s.a2 &
  IExec(WH1,P,s).a3=s.a3 &
(for i be Nat st i >= 8
 holds IExec(WH1,P,s).intpos i=s.intpos i)
 & ex mE be Nat st mE=IExec(WH1,P,s).a7
 & IExec(WH1,P,s).a4=m4+mE & mE <= s.a5
& (for i be Nat st m4+mE < i & i <=s.a4
 holds IExec(WH1,P,s).intpos md
< IExec(WH1,P,s).intpos i) &
 (mE = 0 or IExec(WH1,P,s).intpos md >= IExec(WH1,P,s).intpos(m4+mE))
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m4,md be Nat;
  assume that
A1: s.GBP=0 and
A2: s.a5 > 0 and
A3: s.a4=m4+s.a5 and
A4: m4>=8 and
A5: s.a2=md and
A6: md >= 8;
  s.a5 >=1+0 by A2,INT_1:7;
  then reconsider m5=s.a5-1 as Element of NAT by INT_1:3,XREAL_1:48;
A7: s.a5=m5+1;
  defpred P[Nat] means
   for t being 0-started State of SCMPDS,Q st t.a=0 & t.a5 =$1+1 &
    t.a4=m4+t.a5 & t.a2=md holds IExec(WH1,Q,t).a=0
 & IExec(WH1,Q,t).a1=t.a1 &
  IExec(WH1,Q,t).a5=0 & IExec(WH1,Q,t).a2=t.a2 &
  IExec(WH1,Q,t).a3=t.a3
   & (for i be Nat st i >= 8
   holds IExec(WH1,Q,t).intpos i=t.intpos i) &
   ex mE be Nat st mE=IExec(WH1,Q,t).a7
   & IExec(WH1,Q,t).a4=m4+mE & mE <= t.a5 &
   (for i be Nat st m4+mE < i & i <=t.a4
  holds IExec(WH1,Q,t).intpos md < IExec(WH1,Q,t).intpos i) &
 (mE=0 or IExec(WH1,Q,t).intpos md >= IExec(WH1,Q,t).intpos(m4+mE));
A8: now
    let k be Nat;
    assume
A9: P[k];
    thus P[k+1]
    proof
      set me=m4+(k+1+1);
      let t be 0-started State of SCMPDS;
      let Q;
      set b=DataLoc(t.a,5);
      assume that
A10:  t.a=0 and
A11:  t.a5 =(k+1)+1 and
A12:  t.a4=m4+t.a5 and
A13:  t.a2=md;
      set It= IExec(WB1,Q,t), IT = Q, It0 = Initialize It;
A14:  me>=m4 by NAT_1:11;
      then
A15:  me>=8 by A4,XXREAL_0:2;
      then
A16:  It.a1=t.a1 by A6,A10,A11,A12,A13,Lm7;
A17:  t.intpos md >= t.intpos me implies
      It.a5=0 & It.a4=t.a4 & It.a7=t.a5
       by A6,A10,A11,A12,A13,A15,Lm7;
A18:  b=intpos (0+5) by A10,SCMP_GCD:1;
A19: now let v be 0-started State of SCMPDS;
        let V;
        assume that
A20:    v.a4 >= m4+v.b and
A21:    v.a2=t.a2 and
A22:    v.a=t.a and
A23:    v.b > 0;
A24:    m4+v.b>m4+0 by A23,XREAL_1:6;
        then reconsider ME=v.a4 as Element of NAT by A20,INT_1:3;
        v.a4 >=m4 by A20,A24,XXREAL_0:2;
        then
A25:    ME >= 8 by A4,XXREAL_0:2;
        then
A26:    v.intpos md < v.intpos ME implies IExec(WB1,V,v).a5=v.a5-1 &
        IExec(WB1,V,v).a4=v.a4-1 &
        IExec(WB1,V,v).a7=v.a5-1
        by A6,A10,A13,A21,A22,Lm7;
        thus IExec(WB1,V,v).a=v.a
        by A6,A10,A13,A21,A22,A25,Lm7;
        thus WB1 is_closed_on v,V & WB1 is_halting_on v,V by SCMPDS_6:20,21;
A27:    v.intpos md >= v.intpos ME implies IExec(WB1,V,v).a5=0 &
        IExec(WB1,V,v).a4 =v.a4 & IExec(WB1,V,v).a7=v.a5
        by A6,A10,A13,A21,A22,A25,Lm7;
        hereby
          per cases;
          suppose
A28:        v.intpos md < v.intpos ME;
            hence IExec(WB1,V,v).b < v.b by A18,A26,XREAL_1:146;
            m4+v.b-1=m4+IExec(WB1,V,v).b by A18,A26,A28;
            hence IExec(WB1,V,v).a4 >=
            m4+IExec(WB1,V,v).b by A20,A26,A28,XREAL_1:9;
          end;
          suppose
A29:        v.intpos md >= v.intpos ME;
            hence IExec(WB1,V,v).b < v.b
            by A6,A10,A13,A18,A21,A22,A23,A25,Lm7;
            m4+IExec(WB1,V,v).b < m4+v.b
             by A18,A23,A27,A29,XREAL_1:6;
            hence IExec(WB1,V,v).a4 >=
            m4+IExec(WB1,V,v).b by A20,A27,A29,XXREAL_0:2;
          end;
        end;
        thus IExec(WB1,V,v).a2=v.a2 by A6,A10,A13,A21,A22,A25,Lm7;
      end;
A30:  It.a3=t.a3 by A6,A10,A11,A12,A13,A15,Lm7;
A31:  t.intpos md < t.intpos me implies It.a5=t.a5-1 & It.a4=t.a4-1 & It.
      a7= t.a5-1 by A6,A10,A11,A12,A13,A15,Lm7;
A32:  It.a=0 by A6,A10,A11,A12,A13,A15,Lm7;
      then
A33:  It0.a=0 by SCMPDS_5:15;
A34:  DataLoc(It.a,5)=intpos(0+5) by A32,SCMP_GCD:1;
A35:  It.a2=t.a2 by A6,A10,A11,A12,A13,A15,Lm7;
      then
A36:  It0.a2=t.a2 by SCMPDS_5:15;
      per cases;
      suppose
A37:    t.intpos md < t.intpos me;
        then
A38:    It.a4=m4+It.a5 by A12,A31;
A39:    It0.a4=m4+It.a5 by A12,A31,A37,SCMPDS_5:15
       .= m4+It0.a5 by SCMPDS_5:15;
A40:   It0.a5 = It.a5 by SCMPDS_5:15;
A41:   It0.a1 = It.a1 by SCMPDS_5:15;
A42:   It0.a3 = It.a3 by SCMPDS_5:15;
A43:   It0.a4 = It.a4 by SCMPDS_5:15;
      It.a5 =k+1 by A11,A31,A37;
        then consider mE be Nat such that
A44:    mE=IExec(WH1,IT,Initialize It).a7 and
A45:    IExec(WH1,IT,Initialize It).a4=m4+mE and
A46:    mE <= It.a5 and
A47:    for i be Nat st m4+mE < i & i <=It.a4
        holds IExec(WH1,IT,Initialize It).intpos md <
             IExec(WH1,IT,Initialize It).intpos i and
A48:    mE=0 or IExec(WH1,IT,Initialize It).intpos md >=
         IExec(WH1,IT,Initialize It).intpos (m4+mE)
          by A9,A12,A13,A31,A17,A33,A36,A39,A40;
A49:    IExec(WH1,Q,t)=IExec(WH1,IT,Initialize It)
          by A11,A12,A18,A19,Th5;
        hence IExec(WH1,Q,t).a=0
         by A9,A11,A12,A13,A31,A17,A38,A40,A36,A33,A43;
        thus IExec(WH1,Q,t).a1=t.a1
         by A9,A11,A12,A13,A16,A31,A17,A38,A49,A40,A36,A33,A41,A43;
        thus IExec(WH1,Q,t).a5=0
         by A9,A11,A12,A13,A31,A17,A38,A49,A40,A36,A33,A43;
        thus IExec(WH1,Q,t).a2=t.a2
         by A9,A11,A12,A13,A31,A17,A38,A49,A40,A36,A33,A43;
        thus IExec(WH1,Q,t).a3=t.a3
         by A9,A11,A12,A13,A30,A31,A17,A38,A49,A40,A36,A33,A42,A43;
A50:    now
          let i be Nat;
          assume
A51:      i >= 8;
          hence IExec(WH1,Q,t).intpos i=It0.intpos i
           by A9,A11,A12,A13,A31,A17,A38,A49,A40,A36,A33,A43
            .= It.intpos i by SCMPDS_5:15
            .=t.intpos i by A6,A10,A11,A12,A13,A15,A51,Lm7;
        end;
        hence for i be Nat st i >= 8
         holds IExec(WH1,Q,t).intpos i=t.intpos i;
        take mE;
        thus mE=IExec(WH1,Q,t).a7 by A11,A12,A18,A19,A44,Th5;
        thus IExec(WH1,Q,t).a4=m4+mE by A11,A12,A18,A19,A45,Th5;
        thus mE <= t.a5 by A31,A37,A46,XREAL_1:146,XXREAL_0:2;
A52:    It.a4=t.a4-1 by A6,A10,A11,A12,A13,A15,A37,Lm7;
        hereby
          let i be Nat;
          assume that
A53:      m4+mE < i and
A54:      i <=t.a4;
          per cases;
          suppose
A55:        i=t.a4;
            IExec(WH1,Q,t).intpos me =t.intpos me
             by A4,A14,A50,XXREAL_0:2;
            hence IExec(WH1,Q,t).intpos md < IExec(WH1,Q,t).intpos i
             by A6,A11,A12,A37,A50,A55;
          end;
          suppose
            i<>t.a4;
            then i < t.a4 by A54,XXREAL_0:1;
            then i+1 <= t.a4 by INT_1:7;
            then i <= It.a4 by A52,XREAL_1:19;
            hence IExec(WH1,Q,t).intpos md < IExec(WH1,Q,t).intpos i
             by A49,A47,A53;
          end;
        end;
        thus mE=0 or IExec(WH1,Q,t).intpos md >=
        IExec(WH1,Q,t).intpos (m4+mE) by A49,A48;
      end;
      suppose
A56:    t.intpos md >= t.intpos me;
A57:    now
A58: (Initialize It).GBP = It.GBP by SCMPDS_5:15;
A59: (Initialize It).DataLoc(It.GBP,5) = It.DataLoc(It.GBP,5) by SCMPDS_5:15;
          let x;
          thus IExec(WH1,Q,t).x =IExec(WH1,IT,Initialize It).x
           by A11,A12,A18,A19,Th5
            .=(Initialize It).x by A17,A34,A56,A58,A59,SCMPDS_8:23
           .=It.x by SCMPDS_5:15;
        end;
        hence IExec(WH1,Q,t).a=0 by A32;
        thus IExec(WH1,Q,t).a1=t.a1 by A16,A57;
        thus IExec(WH1,Q,t).a5=0 by A17,A56,A57;
        thus IExec(WH1,Q,t).a2=t.a2 by A35,A57;
        thus IExec(WH1,Q,t).a3=t.a3 by A30,A57;
A60:    now
          let i be Nat;
          assume
A61:      i >= 8;
          thus IExec(WH1,Q,t).intpos i=It.intpos i by A57
            .=t.intpos i by A6,A10,A11,A12,A13,A15,A61,Lm7;
        end;
        hence for i be Nat st i >= 8
         holds IExec(WH1,Q,t).intpos i=t.intpos i;
        take ME=k+1+1;
        thus IExec(WH1,Q,t).a7=ME by A11,A17,A56,A57;
        thus IExec(WH1,Q,t).a4=m4+ME by A11,A12,A17,A56,A57;
        thus ME <= t.a5 by A11;
        thus for i be Nat st m4+ME < i & i <=t.a4
         & not IExec(WH1,Q,t).intpos md < IExec(WH1,Q,t).intpos i
         holds contradiction by A11,A12;
        IExec(WH1,Q,t).intpos me=t.intpos me
        by A4,A14,A60,XXREAL_0:2;
        hence ME=0 or IExec(WH1,Q,t).intpos md
         >= IExec(WH1,Q,t).intpos (m4+ME) by A6,A56,A60;
      end;
    end;
  end;
  A62: P[0]
  proof
    set me=m4+1;
    let t be 0-started State of SCMPDS;
    let Q;
    set It=IExec(WB1,Q,t), IT = Q;
    set b=DataLoc(t.a,5);
    assume that
A63: t.a=0 and
A64: t.a5 =0+1 and
A65: t.a4=m4+t.a5 and
A66: t.a2=md;
A67: me>=m4 by NAT_1:11;
    then
A68: me>=8 by A4,XXREAL_0:2;
    then
A69: t.intpos md < t.intpos me implies It.a5=t.a5-1 & It.a4=t.a4-1 & It.a7
    = t.a5-1 by A6,A63,A64,A65,A66,Lm7;
A70: t.intpos md >= t.intpos me implies It.a5=0 & It.a4=t.a4 & It.a7=t.a5
    by A6,A63,A64,A65,A66,A68,Lm7;
A71: b=intpos (0+5) by A63,SCMP_GCD:1;
A72: now
      let v be 0-started State of SCMPDS,V;
      assume that
A73:  v.a4 >= m4+v.b and
A74:  v.a2=t.a2 and
A75:  v.a=t.a and
A76:  v.b > 0;
A77:  m4+v.b>m4+0 by A76,XREAL_1:6;
      then reconsider ME=v.a4 as Element of NAT by A73,INT_1:3;
      v.a4 >=m4 by A73,A77,XXREAL_0:2;
      then
A78:  ME >= 8 by A4,XXREAL_0:2;
      then
A79:  v.intpos md < v.intpos ME implies IExec(WB1,V,v).a5=v.a5-1 &
     IExec(WB1,V,v).a4=v.a4-1 &
     IExec(WB1,V,v).a7=v.a5-1 by A6,A63,A66,A74,A75,Lm7;
      thus IExec(WB1,V,v).a=v.a by A6,A63,A66,A74,A75,A78,Lm7;
      thus WB1 is_closed_on v,V & WB1 is_halting_on v,V by SCMPDS_6:20,21;
A80:  v.intpos md >= v.intpos ME implies IExec(WB1,V,v).a5=0 &
           IExec(WB1,V,v)
      .a4 =v.a4 & IExec(WB1,V,v).a7=v.a5
       by A6,A63,A66,A74,A75,A78,Lm7;
      hereby
        per cases;
        suppose
A81:      v.intpos md < v.intpos ME;
          hence IExec(WB1,V,v).b < v.b by A71,A79,XREAL_1:146;
          m4+v.b-1=m4+IExec(WB1,V,v).b by A71,A79,A81;
          hence IExec(WB1,V,v).a4 >=
          m4+IExec(WB1,V,v).b by A73,A79,A81,XREAL_1:9;
        end;
        suppose
A82:      v.intpos md >= v.intpos ME;
          hence IExec(WB1,V,v).b < v.b
           by A6,A63,A66,A71,A74,A75,A76,A78,Lm7;
          m4+IExec(WB1,V,v).b < m4+v.b
          by A71,A76,A80,A82,XREAL_1:6;
          hence IExec(WB1,V,v).a4 >=
          m4+IExec(WB1,V,v).b by A73,A80,A82,XXREAL_0:2;
        end;
      end;
      thus IExec(WB1,V,v).a2=v.a2 by A6,A63,A66,A74,A75,A78,Lm7;
    end;
A83: It.a=0 by A6,A63,A64,A65,A66,A68,Lm7;
    then
A84: It.DataLoc(It.a,5)=0 by A64,A69,A70,SCMP_GCD:1;
A85: now
A86: (Initialize It).GBP = It.GBP by SCMPDS_5:15;
A87: (Initialize It).DataLoc(It.GBP,5) = It.DataLoc(It.GBP,5) by SCMPDS_5:15;
      let x;
      thus IExec(WH1,Q,t).x
        = IExec(WH1,Q,Initialize It).x by A64,A65,A71,A72,Th5
        .=(Initialize It).x by A84,A86,A87,SCMPDS_8:23
        .=It.x by SCMPDS_5:15;
    end;
    hence IExec(WH1,Q,t).a=0 by A83;
    It.a1=t.a1 by A6,A63,A64,A65,A66,A68,Lm7;
    hence IExec(WH1,Q,t).a1=t.a1 by A85;
    thus IExec(WH1,Q,t).a5=0 by A64,A69,A70,A85;
    It.a2=t.a2 by A6,A63,A64,A65,A66,A68,Lm7;
    hence IExec(WH1,Q,t).a2=t.a2 by A85;
    It.a3=t.a3 by A6,A63,A64,A65,A66,A68,Lm7;
    hence IExec(WH1,Q,t).a3=t.a3 by A85;
A88: now
      let i be Nat;
      assume
A89:  i >= 8;
      thus IExec(WH1,Q,t).intpos i=It.intpos i by A85
        .=t.intpos i by A6,A63,A64,A65,A66,A68,A89,Lm7;
    end;
    hence for i be Nat st i >= 8
     holds IExec(WH1,Q,t).intpos i=t.intpos i;
A90: IExec(WH1,Q,t).intpos me=t.intpos me by A4,A67,A88,XXREAL_0:2;
      per cases;
      suppose
A91:    t.intpos md < t.intpos me;
        take ME=0;
        thus IExec(WH1,Q,t).a7=ME by A64,A69,A85,A91;
        thus IExec(WH1,Q,t).a4=m4+ME by A64,A65,A69,A85,A91;
        thus ME <= t.a5 by A64;
        hereby
          let i be Nat;
          assume that
A92:      m4+ME < i and
A93:      i <=t.a4;
          m4+1 <= i by A92,INT_1:7;
          then i=m4+1 by A64,A65,A93,XXREAL_0:1;
          hence IExec(WH1,Q,t).intpos md
           < IExec(WH1,Q,t).intpos i by A6,A88,A90,A91;
        end;
        thus ME=0 or IExec(WH1,Q,t).intpos md
          >= IExec(WH1,Q,t).intpos (m4+ ME );
      end;
      suppose
A94:    t.intpos md >= t.intpos me;
        take ME=1;
        thus IExec(WH1,Q,t).a7=ME by A64,A70,A85,A94;
        thus IExec(WH1,Q,t).a4=m4+ME by A64,A65,A70,A85,A94;
        thus ME <= t.a5 by A64;
        thus for i be Nat st m4+ME < i & i <=t.a4
         holds IExec(WH1,Q,t).intpos md < IExec(WH1,Q,t).intpos i by A64,A65;
        thus ME=0 or IExec(WH1,Q,t).intpos md
         >= IExec(WH1,Q,t).intpos (m4+ME) by A6,A88,A90,A94;
      end;
  end;
  for k be Nat holds P[k] from NAT_1:sch 2(A62,A8);
  hence thesis by A1,A3,A5,A7;
end;

Lm9: for s being 0-started State of SCMPDS,
 m4,md be Nat st s.GBP=0 & s.a4=m4
+s.a5 & m4>=8 & s.a2=md & md >= 8
 holds WH1 is_closed_on s,P & WH1 is_halting_on s,P
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m4,md be Nat;
  assume that
A1: s.GBP=0 and
A2: s.a4=m4+s.a5 and
A3: m4>=8 and
A4: s.a2=md and
A5: md >= 8;
  set b=DataLoc(s.a,5);
A6: b=intpos (0+5) by A1,SCMP_GCD:1;
  now
    let v be 0-started State of SCMPDS, V;
    assume that
A7: v.a4 >= m4+v.b and
A8: v.a2=s.a2 and
A9: v.a=s.a and
A10: v.b > 0;
A11: m4+v.b>m4+0 by A10,XREAL_1:6;
    then reconsider ME=v.a4 as Element of NAT by A7,INT_1:3;
    v.a4 >=m4 by A7,A11,XXREAL_0:2;
    then
A12: ME >= 8 by A3,XXREAL_0:2;
    then
A13: v.intpos md < v.intpos ME implies IExec(WB1,V,v).a5=v.a5-1
 & IExec(WB1,V,v) .a4=v.a4-1 & IExec(WB1,V,v).a7=v.a5-1
     by A1,A4,A5,A8,A9,Lm7;
    thus IExec(WB1,V,v).a=v.a
    by A1,A4,A5,A8,A9,A12,Lm7;
    thus WB1 is_closed_on v,V & WB1 is_halting_on v,V by SCMPDS_6:20,21;
A14: v.intpos md >= v.intpos ME implies IExec(WB1,V,v).a5=0
 & IExec(WB1,V,v).
    a4= v.a4 & IExec(WB1,V,v).a7=v.a5
    by A1,A4,A5,A8,A9,A12,Lm7;
    hereby
      per cases;
      suppose
A15:    v.intpos md < v.intpos ME;
        hence IExec(WB1,V,v).b < v.b by A6,A13,XREAL_1:146;
        m4+v.b-1=m4+IExec(WB1,V,v).b by A6,A13,A15;
        hence IExec(WB1,V,v).a4 >= m4+IExec(WB1,V,v).b
         by A7,A13,A15,XREAL_1:9;
      end;
      suppose
A16:    v.intpos md >= v.intpos ME;
        hence IExec(WB1,V,v).b < v.b
         by A1,A4,A5,A6,A8,A9,A10,A12,Lm7;
        m4+IExec(WB1,V,v).b < m4+v.b by A6,A10,A14,A16,XREAL_1:6;
        hence IExec(WB1,V,v).a4 >= m4+IExec(WB1,V,v).b
         by A7,A14,A16,XXREAL_0:2;
      end;
    end;
    thus IExec(WB1,V,v).a2=v.a2 by A1,A4,A5,A8,A9,A12,Lm7;
  end;
  hence thesis by A2,A6,Th5;
end;

Lm10: card WH1=11
proof
  thus card WH1=9+2 by Lm6,SCMPDS_8:17
    .=11;
end;

Lm11: card WB2=9
proof
  thus card WB2= card (j1 ';' j2 ';' j3 ';' j4) + card IF2 by AFINSQ_1:17
    .= 4+card IF2 by Th4
    .= 4+(card (j5 ';' j6) +card j7+2) by SCMPDS_6:65
    .= 4+(2+card j7+2) by SCMP_GCD:5
    .= 4+(2+1+2) by COMPOS_1:54
    .= 9;
end;

Lm12: card WH2=11
proof
  thus card WH2= 9+2 by Lm11,SCMPDS_8:17
    .=11;
end;

Lm13: for s being 0-started State of SCMPDS,
md,me be Nat st s.a2=md & s.a3=me
& md >= 8 & me >= 8 & s.GBP=0 holds IExec(WB2,P,s).GBP=0
 & IExec(WB2,P,s).a1=s.a1 &
IExec(WB2,P,s).a2=s.a2 & IExec(WB2,P,s).a4=s.a4
 & (for i be Nat st i >=
8 holds IExec(WB2,P,s).intpos i=s.intpos i)
 & (s.intpos md > s.intpos me implies
IExec(WB2,P,s).a7=s.a7-1 & IExec(WB2,P,s).a3=s.a3+1
 & IExec(WB2,P,s).a5=s.a7-1) & (s.
intpos md <= s.intpos me implies IExec(WB2,P,s).a7=0 &
IExec(WB2,P,s).a3=s.a3 &
IExec(WB2,P,s).a5=s.a7)
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,md,me be Nat;
  assume that
A1: s.a2=md and
A2: s.a3=me and
A3: md >= 8 and
A4: me >= 8 and
A5: s.a=0;
  set t0= s, t1=IExec(j1 ';' j2 ';' j3 ';' j4,P,s),
     Q1 = P,
     t2=IExec(j1 ';' j2 ';' j3,P,s),
     t3=IExec(j1 ';' j2,P,s),
     t4=Exec(j1, t0);
A6: t0.a=0 by A5;
A7: DataLoc(t0.a,5)=intpos (0+5) by A5,SCMP_GCD:1; then
A8: t4.a =0 by A5,AMI_3:10,SCMPDS_2:47; then
A9: DataLoc(t4.a,7)=intpos (0+7) by SCMP_GCD:1;
A10: t4.a2 =md by A7,A1,AMI_3:10,SCMPDS_2:47;
A11: t3.a2 =Exec(j2, t4).a2 by SCMPDS_5:42
    .=md by A10,A9,AMI_3:10,SCMPDS_2:48; then
A12: DataLoc(t3.a2,0)=intpos (md+0) by SCMP_GCD:1;
A13: t3.a =Exec(j2, t4).a by SCMPDS_5:42
    .=0 by A8,A9,AMI_3:10,SCMPDS_2:48;
  then
A14: DataLoc(t3.a,6)=intpos (0+6) by SCMP_GCD:1;
A15: t4.a3 =me by A7,A2,AMI_3:10,SCMPDS_2:47;
A16: t3.a3 =Exec(j2, t4).a3 by SCMPDS_5:42
    .=me by A15,A9,AMI_3:10,SCMPDS_2:48;
A17: t4.a7 =s.a7 by A7,AMI_3:10,SCMPDS_2:47;
  set t01=Initialize t1, jj7= (GBP,7):=0, t5=Exec(j5,t01);
A18: t2.a3 =Exec(j3, t3).a3 by SCMPDS_5:41
    .=me by A16,A14,AMI_3:10,SCMPDS_2:47;
A19: t2.a =Exec(j3, t3).a by SCMPDS_5:41
    .=0 by A13,A14,AMI_3:10,SCMPDS_2:47;
  then
A20: DataLoc(t2.a,6)=intpos (0+6) by SCMP_GCD:1;
A21: t4.a4 =s.a4 by A7,AMI_3:10,SCMPDS_2:47;
A22: t3.a4 =Exec(j2, t4).a4 by SCMPDS_5:42
    .=s.a4 by A21,A9,AMI_3:10,SCMPDS_2:48;
A23: t4.a1 =s.a1 by A7,AMI_3:10,SCMPDS_2:47;
A24: t3.a1 =Exec(j2, t4).a1 by SCMPDS_5:42
    .=s.a1 by A23,A9,AMI_3:10,SCMPDS_2:48;
A25: t2.a1 =Exec(j3, t3).a1 by SCMPDS_5:41
    .=s.a1 by A24,A14,AMI_3:10,SCMPDS_2:47;
  t1.a1 =Exec(j4, t2).a1 by SCMPDS_5:41
    .=s.a1 by A25,A20,AMI_3:10,SCMPDS_2:50;
  then
A26: t01.a1=s.a1 by SCMPDS_5:15;
A27: t2.a4 =Exec(j3, t3).a4 by SCMPDS_5:41
    .=s.a4 by A22,A14,AMI_3:10,SCMPDS_2:47;
  t1.a4 =Exec(j4, t2).a4 by SCMPDS_5:41
    .=s.a4 by A27,A20,AMI_3:10,SCMPDS_2:50;
  then
A28: t01.a4=s.a4 by SCMPDS_5:15;
A29: t1.a =Exec(j4, t2).a by SCMPDS_5:41
    .=0 by A19,A20,AMI_3:10,SCMPDS_2:50;
  then
A30: t01.a=0 by SCMPDS_5:15;
  then
A31: DataLoc(t01.a,7)=intpos(0+7) by SCMP_GCD:1;
  DataLoc(t0.a,7)=intpos (0+7) by A6,SCMP_GCD:1;
  then
A32: t4.a5 =s.a7 by A7,SCMPDS_2:47;
A33: t3.a5 =Exec(j2, t4).a5 by SCMPDS_5:42
    .=s.a7 by A32,A9,AMI_3:10,SCMPDS_2:48;
A34: t2.a5 =Exec(j3, t3).a5 by SCMPDS_5:41
    .=s.a7 by A33,A14,AMI_3:10,SCMPDS_2:47;
  t1.a5 =Exec(j4, t2).a5 by SCMPDS_5:41
    .=s.a7 by A34,A20,AMI_3:10,SCMPDS_2:50;
  then
A35: t01.a5=s.a7 by SCMPDS_5:15;
A36: t2.a2 =Exec(j3, t3).a2 by SCMPDS_5:41
    .=md by A11,A14,AMI_3:10,SCMPDS_2:47;
  t1.a2 =Exec(j4, t2).a2 by SCMPDS_5:41
    .=md by A36,A20,AMI_3:10,SCMPDS_2:50;
  then
A37: t01.a2=s.a2 by A1,SCMPDS_5:15;
  a4<>DataLoc(t01.a,3) by A30,AMI_3:10,SCMP_GCD:1;
  then
A38: t5.a4=s.a4 by A28,SCMPDS_2:48;
  a2<>DataLoc(t01.a,3) by A30,AMI_3:10,SCMP_GCD:1;
  then
A39: t5.a2=s.a2 by A37,SCMPDS_2:48;
  a<>DataLoc(t01.a,3) by A30,AMI_3:10,SCMP_GCD:1;
  then
A40: t5.a=0 by A30,SCMPDS_2:48;
  then
A41: DataLoc(t5.a,5)=intpos(0+5) by SCMP_GCD:1;
A42: now
    let i be Nat;
    assume i>=8;
    then i > 5 by XXREAL_0:2;
    hence t4.intpos i = s.intpos i by A7,AMI_3:10,SCMPDS_2:47;
  end;
A43: now
    let i be Nat;
    assume
A44: i>=8;
    then
A45: i > 7 by XXREAL_0:2;
    thus t3.intpos i =Exec(j2, t4).intpos i by SCMPDS_5:42
      .=t4.intpos i by A9,A45,AMI_3:10,SCMPDS_2:48
      .=s.intpos i by A42,A44;
  end;
A46: now
    let i be Nat;
    assume
A47: i>=8;
    then
A48: i > 6 by XXREAL_0:2;
    thus t2.intpos i=Exec(j3, t3).intpos i by SCMPDS_5:41
      .=t3.intpos i by A14,A48,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by A43,A47;
  end;
A49: now
    let i be Nat;
    assume
A50: i>=8;
    then
A51: i > 6 by XXREAL_0:2;
    thus t1.intpos i=Exec(j4, t2).intpos i by SCMPDS_5:41
      .=t2.intpos i by A20,A51,AMI_3:10,SCMPDS_2:50
      .=s.intpos i by A46,A50;
  end;
A52: t2.a6 =Exec(j3, t3).a6 by SCMPDS_5:41
    .=t3.intpos md by A14,A12,SCMPDS_2:47
    .=s.intpos md by A3,A43;
  t1.a6 =Exec(j4, t2).a6 by SCMPDS_5:41
    .=t2.a6-t2.DataLoc(t2.a3,0) by A20,SCMPDS_2:50
    .=t2.a6-t2.intpos(me+0) by A18,SCMP_GCD:1
    .=s.intpos md - s.intpos me by A4,A52,A46;
  then
A53: t1.DataLoc(t1.a,6)=s.intpos md - s.intpos me by A29,SCMP_GCD:1;
  a1<>DataLoc(t01.a,3) by A30,AMI_3:10,SCMP_GCD:1;
  then
A54: t5.a1=s.a1 by A26,SCMPDS_2:48;
A55: now
    per cases;
    suppose
A56:  t01.DataLoc(t01.a,6) <= 0;
      hence IExec(IF2,Q1,Initialize t1).a
      =IExec(j7,Q1,Initialize t1).a by SCMPDS_6:74
        .=Exec(jj7,t01).a by SCMPDS_5:40
        .=0 by A30,A31,AMI_3:10,SCMPDS_2:46;
      thus IExec(IF2,Q1,Initialize t1).a1=IExec(j7,Q1,Initialize t1).a1
       by A56,SCMPDS_6:74
        .=Exec(jj7,t01).a1 by SCMPDS_5:40
        .=s.a1 by A26,A31,AMI_3:10,SCMPDS_2:46;
      thus IExec(IF2,Q1,Initialize t1).a2=IExec(j7,Q1,Initialize t1).a2
       by A56,SCMPDS_6:74
        .=Exec(jj7,t01).a2 by SCMPDS_5:40
        .=s.a2 by A37,A31,AMI_3:10,SCMPDS_2:46;
      thus IExec(IF2,Q1,Initialize t1).a4=IExec(j7,Q1,Initialize t1).a4
       by A56,SCMPDS_6:74
        .=Exec(jj7,t01).a4 by SCMPDS_5:40
        .=s.a4 by A28,A31,AMI_3:10,SCMPDS_2:46;
        let i be Nat;
        assume
A57:    i>=8;
        then
A58:    i > 7 by XXREAL_0:2;
        thus IExec(WB2,P,s).intpos i
         =IExec(IF2,Q1,Initialize t1).intpos i
         by SCMPDS_5:35
          .=IExec(j7,Q1,Initialize t1).intpos i by A56,SCMPDS_6:74
          .=Exec(jj7,t01).intpos i by SCMPDS_5:40
          .=t01.intpos i by A31,A58,AMI_3:10,SCMPDS_2:46
          .=t1.intpos i by SCMPDS_5:15
          .=s.intpos i by A49,A57;
    end;
    suppose
A59:  t01.DataLoc(t01.a,6) > 0;
      hence IExec(IF2,Q1,Initialize t1).a=IExec(j5 ';' j6,Q1,Initialize t1).a
       by SCMPDS_6:73
        .=Exec(j6,t5).a
         by SCMPDS_5:42
        .=0 by A40,A41,AMI_3:10,SCMPDS_2:48;
      thus IExec(IF2,Q1,Initialize t1).a1=IExec(j5 ';' j6,Q1,Initialize t1).a1
       by A59,SCMPDS_6:73
        .=Exec(j6,t5).a1 by SCMPDS_5:42
        .=s.a1 by A54,A41,AMI_3:10,SCMPDS_2:48;
      thus IExec(IF2,Q1,Initialize t1).a2=IExec(j5 ';' j6,Q1,Initialize t1).a2
       by A59,SCMPDS_6:73
        .=Exec(j6,t5).a2 by SCMPDS_5:42
        .=s.a2 by A39,A41,AMI_3:10,SCMPDS_2:48;
      thus IExec(IF2,Q1,Initialize t1).a4=IExec(j5 ';' j6,Q1,Initialize t1).a4
       by A59,SCMPDS_6:73
        .=Exec(j6,t5).a4 by SCMPDS_5:42
        .=s.a4 by A38,A41,AMI_3:10,SCMPDS_2:48;
        let i be Nat;
        assume
A60:    i>=8;
        then
A61:    i > 5 by XXREAL_0:2;
        i > 3 by A60,XXREAL_0:2;
        then
A62:    intpos i<>DataLoc(t01.a,3) by A30,AMI_3:10,SCMP_GCD:1;
        thus IExec(WB2,P,s).intpos i=
        IExec(IF2,Q1,Initialize t1).intpos i by SCMPDS_5:35
          .=IExec(j5 ';' j6,Q1,Initialize t1).intpos i by A59,SCMPDS_6:73
          .=Exec(j6,t5).intpos i by SCMPDS_5:42
          .=t5.intpos i by A41,A61,AMI_3:10,SCMPDS_2:48
          .=t01.intpos i by A62,SCMPDS_2:48
          .=t1.intpos i by SCMPDS_5:15
          .=s.intpos i by A49,A60;
    end;
  end;
  hence IExec(WB2,P,s).a=0 & IExec(WB2,P,s).a1=s.a1 &
   IExec(WB2,P,s).a2=s.a2 & IExec(WB2,P,s).a4=s.a4 by SCMPDS_5:35;
  thus for i be Nat st i >= 8
  holds IExec(WB2,P,s).intpos i=s.intpos i by A55;
A63: t3.a7 =Exec(j2, t4).a7 by SCMPDS_5:42
    .=t4.a7+ -1 by A9,SCMPDS_2:48
    .=s.a7-1 by A17;
A64: t2.a7 =Exec(j3, t3).a7 by SCMPDS_5:41
    .=s.a7-1 by A63,A14,AMI_3:10,SCMPDS_2:47;
  t1.a7 =Exec(j4, t2).a7 by SCMPDS_5:41
    .=s.a7-1 by A64,A20,AMI_3:10,SCMPDS_2:50;
  then
A65: t01.a7=s.a7-1 by SCMPDS_5:15;
  t1.a3 =Exec(j4, t2).a3 by SCMPDS_5:41
    .=me by A18,A20,AMI_3:10,SCMPDS_2:50;
  then
A66: t01.a3=s.a3 by A2,SCMPDS_5:15;
A67: DataLoc(t01.a,3)=intpos(0+3) by A30,SCMP_GCD:1;
A68: t01.DataLoc(t01.a,6) =  t1.DataLoc(t01.a,6) by SCMPDS_5:15
         .= t1.DataLoc(t1.a,6) by SCMPDS_5:15;
  hereby
A69: a7<>DataLoc(t01.a,3) by A30,AMI_3:10,SCMP_GCD:1;
    assume
 s.intpos md > s.intpos me;
    then
A70: s.intpos md - s.intpos me > 0 by XREAL_1:50;
    thus IExec(WB2,P,s).a7=IExec(IF2,Q1,Initialize t1).a7
     by SCMPDS_5:35
      .=IExec(j5 ';' j6,Q1,Initialize t1).a7 by A53,A68,A70,SCMPDS_6:73
      .=Exec(j6,t5).a7 by SCMPDS_5:42
      .=t5.a7 by A41,AMI_3:10,SCMPDS_2:48
      .=s.a7-1 by A65,A69,SCMPDS_2:48;
    thus IExec(WB2,P,s).a3=IExec(IF2,Q1,Initialize t1).a3
     by SCMPDS_5:35
      .=IExec(j5 ';' j6,Q1,Initialize t1).a3 by A53,A68,A70,SCMPDS_6:73
      .=Exec(j6,t5).a3 by SCMPDS_5:42
      .=t5.a3 by A41,AMI_3:10,SCMPDS_2:48
      .=s.a3+1 by A67,A66,SCMPDS_2:48;
A71: a5<>DataLoc(t01.a,3) by A30,AMI_3:10,SCMP_GCD:1;
    thus IExec(WB2,P,s).a5=IExec(IF2,Q1,Initialize t1).a5
     by SCMPDS_5:35
      .=IExec(j5 ';' j6,Q1,Initialize t1).a5 by A53,A68,A70,SCMPDS_6:73
      .=Exec(j6,t5).a5 by SCMPDS_5:42
      .=t5.a5+ -1 by A41,SCMPDS_2:48
      .=t5.a5-1
      .=s.a7-1 by A35,A71,SCMPDS_2:48;
  end;
  hereby
    assume
 s.intpos md <= s.intpos me;
    then
A72:  0 >= s.intpos md - s.intpos me by XREAL_1:47;
    thus IExec(WB2,P,s).a7=IExec(IF2,Q1,Initialize t1).a7
     by SCMPDS_5:35
      .=IExec(j7,Q1,Initialize t1).a7 by A53,A68,A72,SCMPDS_6:74
      .=Exec(jj7,t01).a7 by SCMPDS_5:40
      .=0 by A31,SCMPDS_2:46;
    thus IExec(WB2,P,s).a3=IExec(IF2,Q1,Initialize t1).a3
     by SCMPDS_5:35
      .=IExec(j7,Q1,Initialize t1).a3 by A53,A68,A72,SCMPDS_6:74
      .=Exec(jj7,t01).a3 by SCMPDS_5:40
      .=s.a3 by A31,A66,AMI_3:10,SCMPDS_2:46;
    thus IExec(WB2,P,s).a5=IExec(IF2,Q1,Initialize t1).a5
     by SCMPDS_5:35
      .=IExec(j7,Q1,Initialize t1).a5 by A53,A68,A72,SCMPDS_6:74
      .=Exec(jj7,t01).a5 by SCMPDS_5:40
      .=s.a7 by A35,A31,AMI_3:10,SCMPDS_2:46;
  end;
end;

Lm14: for s being 0-started State of SCMPDS,
m3,md be Nat st s.GBP=0 & s.a7 >
0 & s.a3+s.a7=m3 & s.a3>=8 & s.a2=md & md >= 8
 holds IExec(WH2,P,s).GBP=0 & IExec(WH2,P,s).a1=s.a1 &
 IExec(WH2,P,s).a7=0 & IExec(WH2,P,s).a2=s.a2 &
 IExec(WH2,P,s).a4=s.a4 &
 (for i be Nat st i >= 8
 holds IExec(WH2,P,s).intpos i=s.intpos i)
& ex m5,mE3 be Nat st m5=IExec(WH2,P,s).a5
 & IExec(WH2,P,s).a3=mE3 & mE3
+m5=m3 & m5 <= s.a7 & (for i be Nat st s.a3 <= i & i < mE3 holds
IExec(WH2,P,s).intpos md > IExec(WH2,P,s).intpos i)
 & (m5 = 0 or IExec(WH2,P,s).intpos md <= IExec(WH2,P,s).intpos mE3)
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m3,md be Nat;
  assume that
A1: s.a=0 and
A2: s.a7 > 0 and
A3: s.a3+s.a7=m3 and
A4: s.a3>=8 and
A5: s.a2=md and
A6: md >= 8;
  s.a7 >=1+0 by A2,INT_1:7;
  then reconsider m7=s.a7-1 as Element of NAT by INT_1:3,XREAL_1:48;
A7: s.a7=m7+1;
  defpred P[Nat] means
   for t being 0-started State of SCMPDS,Q st t.a=0 & t.a7 =$1+1 &
    t.a3+t.a7=m3 & t.a3>=8 & t.a2=md
 holds IExec(WH2,Q,t).a=0 & IExec(WH2,Q,t).
  a1=t.a1 & IExec(WH2,Q,t).a7=0 & IExec(WH2,Q,t).a2=t.a2
   & IExec(WH2,Q,t).a4=t.a4 &
  (for i be Nat st i >= 8
 holds IExec(WH2,Q,t).intpos i=t.intpos i) &
 ex m5,mE3 be Nat st m5=IExec(WH2,Q,t).a5
 & IExec(WH2,Q,t).a3=mE3 & mE3+m5= m3 & m5 <= t.a7 &
  (for i be Nat st t.a3 <= i & i < mE3
 holds IExec(WH2,Q,t).intpos md >
 IExec(WH2,Q,t).intpos i)
 & (m5=0 or IExec(WH2,Q,t).intpos md <=
  IExec(WH2,Q,t).intpos mE3);
A8: now
    let k be Nat;
    assume
A9: P[k];
    P[k+1]
    proof
      let t be 0-started State of SCMPDS;
      let Q;
      set b=DataLoc(t.a,7);
      assume that
A10:  t.a=0 and
A11:  t.a7 =(k+1)+1 and
A12:  t.a3+t.a7=m3 and
A13:  t.a3>=8 and
A14:  t.a2=md;
      reconsider me=t.a3 as Element of NAT by A13,INT_1:3;
      set It=IExec(WB2,Q,t), IT = Q;
A15:  t.intpos md > t.intpos me implies It.a7=t.a7-1 & It.a3=t.a3+1 & It.
      a5= t.a7-1 by A6,A10,A13,A14,Lm13;
A16:  b=intpos (0+7) by A10,SCMP_GCD:1;
A17:  now
        let v be 0-started State of SCMPDS;
        let V;
        assume that
A18:    v.a3 >= 8 and
A19:    v.a2=t.a2 and
A20:    v.a=t.a and
A21:    v.b > 0;
        reconsider ME=v.a3 as Element of NAT by A18,INT_1:3;
A22:    ME=v.a3;
        hence IExec(WB2,V,v).a=v.a
         by A6,A10,A14,A18,A19,A20,Lm13;
        thus WB2 is_closed_on v,V & WB2 is_halting_on v,V by SCMPDS_6:20,21;
A23:    v.intpos md > v.intpos ME implies IExec(WB2,V,v).a7=v.a7-1
 & IExec(WB2,V,v).a3=v.a3+1
  & IExec(WB2,V,v).a5=v.a7-1
   by A6,A10,A14,A18,A19,A20,Lm13;
        hereby
          per cases;
          suppose
A24:        v.intpos md > v.intpos ME;
            hence IExec(WB2,V,v).b < v.b by A16,A23,XREAL_1:146;
A25:        v.a3 +1 > v.a3 by XREAL_1:29;
            IExec(WB2,V,v).a3=v.a3+1
             by A6,A10,A14,A18,A19,A20,A24,Lm13;
            hence IExec(WB2,V,v).a3 >= 8 by A18,A25,XXREAL_0:2;
          end;
          suppose
A26:        v.intpos md <= v.intpos ME;
            hence IExec(WB2,V,v).b < v.b
             by A6,A10,A14,A16,A18,A19,A20,A21,Lm13;
            thus IExec(WB2,V,v).a3 >= 8
             by A6,A10,A14,A18,A19,A20,A26,Lm13;
          end;
        end;
        thus IExec(WB2,V,v).a2=v.a2
         by A6,A10,A14,A18,A19,A20,A22,Lm13;
      end;
A27:  t.intpos md <= t.intpos me implies It.a7=0 & It.a3=t.a3 & It.a5=t.
      a7 by A6,A10,A13,A14,Lm13;
A28:  me=t.a3;
      then
A29:  It.a=0 by A6,A10,A13,A14,Lm13;
      then
A30:  DataLoc(It.a,7)=intpos(0+7) by SCMP_GCD:1;
A31:  It.a1=t.a1 by A6,A10,A13,A14,A28,Lm13;
A32:  It.a4=t.a4 by A6,A10,A13,A14,A28,Lm13;
A33:  It.a2=t.a2 by A6,A10,A13,A14,A28,Lm13;
A34:  (Initialize It).a1 = It.a1 by SCMPDS_5:15;
A35:  (Initialize It).a4 = It.a4 by SCMPDS_5:15;
A36:  (Initialize It).a2 = It.a2 by SCMPDS_5:15;
      per cases;
      suppose
A37:    t.intpos md > t.intpos me;
        then t.a3 < It.a3 by A15,XREAL_1:29;
        then
A38:    It.a3 >= 8 by A13,XXREAL_0:2;
A39:    It.a3+It.a7=m3 by A12,A15,A37;
A40: (Initialize It).a = It.a by SCMPDS_5:15;
A41: (Initialize It).a3 = It.a3 by SCMPDS_5:15;
A42: (Initialize It).a7 = It.a7 by SCMPDS_5:15;
        consider m5,mE3 be Nat such that
A43:    m5=IExec(WH2,IT,Initialize It).a5 and
A44:    IExec(WH2,IT,Initialize It).a3=mE3 and
A45:    mE3+m5=m3 and
A46:    m5 <= It.a7 and
A47:    for i be Nat st It.a3 <= i & i < mE3 holds
        IExec(WH2,IT,Initialize It).intpos md >
        IExec(WH2,IT,Initialize It).intpos i and
A48:    m5=0 or IExec(WH2,IT,Initialize It).intpos md <=
         IExec(WH2,IT,Initialize It).intpos mE3
        by A9,A11,A12,A14,A29,A33,A36,A15,A27,A38,A39,A40,A41,A42;
A49:    IExec(WH2,Q,t)=IExec(WH2,IT,Initialize It) by A11,A13,A16,A17,Th6;
        hence IExec(WH2,Q,t).a=0
         by A9,A11,A12,A14,A29,A33,A36,A15,A27,A38,A39,A40,A41,A42;
        thus IExec(WH2,Q,t).a1=t.a1
         by A9,A11,A12,A14,A29,A31,A34,A33,A36,A15,A27,A38,A39,A49,A40,A41,A42;
        thus IExec(WH2,Q,t).a7=0
         by A9,A11,A12,A14,A29,A33,A36,A15,A27,A38,A39,A49,A40,A41,A42;
        thus IExec(WH2,Q,t).a2=t.a2
         by A9,A11,A12,A14,A29,A33,A36,A15,A27,A38,A39,A49,A40,A41,A42;
        thus IExec(WH2,Q,t).a4=t.a4
         by A9,A11,A12,A14,A29,A33,A36,A32,A35,A15,A27,A38,A39,A49,A40,A41,A42;
A50:    now
          let i be Nat;
          assume
A51:      i >= 8;
           (Initialize It).intpos i = It.intpos i by SCMPDS_5:15;
          hence IExec(WH2,Q,t).intpos i=It.intpos i
           by A9,A11,A12,A14,A29,A33,A36,A15,A27,A38,A39,A49,A40,A41,A42,A51
            .=t.intpos i by A6,A10,A13,A14,A28,A51,Lm13;
        end;
        hence for i be Nat st i >= 8
         holds IExec(WH2,Q,t).intpos i=t.intpos i;
        take m5;
        take mE3;
        thus m5=IExec(WH2,Q,t).a5 by A11,A13,A16,A17,A43,Th6;
        thus IExec(WH2,Q,t).a3=mE3 by A11,A13,A16,A17,A44,Th6;
        thus mE3+m5=m3 by A45;
        thus m5 <= t.a7 by A15,A37,A46,XREAL_1:146,XXREAL_0:2;
A52:    It.a3=t.a3+1 by A6,A10,A13,A14,A37,Lm13;
        hereby
          let i be Nat;
          assume that
A53:      t.a3 <= i and
A54:      i < mE3;
          per cases;
          suppose
A55:        i=t.a3;
            IExec(WH2,Q,t).intpos me =t.intpos me by A13,A50;
            hence IExec(WH2,Q,t).intpos md
             > IExec(WH2,Q,t).intpos i by A6,A37,A50,A55;
          end;
          suppose
            i<>t.a3;
            then t.a3 < i by A53,XXREAL_0:1;
            then It.a3 <= i by A52,INT_1:7;
            hence
            IExec(WH2,Q,t).intpos md >
            IExec(WH2,Q,t).intpos i by A49,A47,A54;
          end;
        end;
        thus m5=0 or IExec(WH2,Q,t).intpos md
         <= IExec(WH2,Q,t).intpos mE3 by A49,A48;
      end;
      suppose
A56:    t.intpos md <= t.intpos me;
A57:    now
          let x;
A58: (Initialize It).GBP = It.GBP by SCMPDS_5:15;
A59: (Initialize It).DataLoc(It.GBP,7) = It.DataLoc(It.GBP,7) by SCMPDS_5:15;
          thus IExec(WH2,Q,t).x =IExec(WH2,IT,Initialize It).x
           by A11,A13,A16,A17,Th6
            .=(Initialize It).x by A27,A30,A56,A58,A59,SCMPDS_8:23
            .=It.x by SCMPDS_5:15;
        end;
        hence IExec(WH2,Q,t).a=0 by A29;
        thus IExec(WH2,Q,t).a1=t.a1 by A31,A57;
        thus IExec(WH2,Q,t).a7=0 by A27,A56,A57;
        thus IExec(WH2,Q,t).a2=t.a2 by A33,A57;
        thus IExec(WH2,Q,t).a4=t.a4 by A32,A57;
A60:    now
          let i be Nat;
          assume
A61:      i >= 8;
          thus IExec(WH2,Q,t).intpos i=It.intpos i by A57
            .=t.intpos i by A6,A10,A13,A14,A28,A61,Lm13;
        end;
        hence for i be Nat st i >= 8
         holds IExec(WH2,Q,t).intpos i=t.intpos i;
         reconsider m5=k+1+1 as Nat;
        take m5;
        take mE3=me;
        thus IExec(WH2,Q,t).a5=m5 by A11,A27,A56,A57;
        thus IExec(WH2,Q,t).a3=mE3 by A27,A56,A57;
        thus mE3+m5=m3 by A11,A12;
        thus m5 <= t.a7 by A11;
        thus for i be Nat st t.a3 <= i & i < mE3
         holds IExec(WH2,Q,t).intpos md > IExec(WH2,Q,t).intpos i;
        IExec(WH2,Q,t).intpos me=t.intpos me by A13,A60;
        hence m5=0 or IExec(WH2,Q,t).intpos md
         <= IExec(WH2,Q,t).intpos mE3 by A6,A56,A60;
      end;
    end;
    hence P[k+1];
  end;
  P[0]
  proof
    let t be 0-started State of SCMPDS;
    let Q;
    set b=DataLoc(t.a,7);
    assume that
A62: t.a=0 and
A63: t.a7 =0+1 and
A64: t.a3+t.a7=m3 and
A65: t.a3>=8 and
A66: t.a2=md;
    reconsider me=t.a3 as Element of NAT by A65,INT_1:3;
    set It=IExec(WB2,Q,t), IT = Q;
A67: t.intpos md > t.intpos me implies It.a7=t.a7-1 & It.a3=t.a3+1 & It.a5
    = t.a7-1 by A6,A62,A65,A66,Lm13;
A68: b=intpos (0+7) by A62,SCMP_GCD:1;
A69: now
      let v be 0-started State of SCMPDS, V;
      assume that
A70:  v.a3 >= 8 and
A71:  v.a2=t.a2 and
A72:  v.a=t.a and
A73:  v.b > 0;
      reconsider ME=v.a3 as Element of NAT by A70,INT_1:3;
A74:  ME=v.a3;
A75:     v.intpos ME = (v).intpos ME;
      thus IExec(WB2,V,v).a=v.a
       by A6,A62,A66,A70,A71,A72,Lm13,A75;
      thus WB2 is_closed_on v,V & WB2 is_halting_on v,V by SCMPDS_6:20,21;
A76:  v.intpos md > v.intpos ME implies IExec(WB2,V,v).a7=v.a7-1
 & IExec(WB2,V,v) .a3=v.a3+1
 & IExec(WB2,V,v).a5=v.a7-1
  by A6,A62,A66,A70,A71,A72,Lm13;
      hereby
        per cases;
        suppose
A77:      v.intpos md > v.intpos ME;
          hence IExec(WB2,V,v).b < v.b by A68,A76,XREAL_1:146;
A78:      v.a3 +1 > v.a3 by XREAL_1:29;
          IExec(WB2,V,v).a3=v.a3+1
           by A6,A62,A66,A70,A71,A72,A77,Lm13;
          hence IExec(WB2,V,v).a3 >= 8 by A70,A78,XXREAL_0:2;
        end;
        suppose
A79:      v.intpos md <= v.intpos ME;
          hence IExec(WB2,V,v).b < v.b
           by A6,A62,A66,A68,A70,A71,A72,A73,Lm13;
          thus IExec(WB2,V,v).a3 >= 8
           by A6,A62,A66,A70,A71,A72,A79,Lm13;
        end;
      end;
      thus IExec(WB2,V,v).a2=v.a2
       by A6,A62,A66,A70,A71,A72,A74,Lm13;
    end;
A80: t.intpos md <= t.intpos me implies It.a7=0 & It.a3=t.a3 & It.a5=t.a7
    by A6,A62,A65,A66,Lm13;
A81: me=t.a3;
    then
A82: It.a=0 by A6,A62,A65,A66,Lm13;
    then
A83: It.DataLoc(It.a,7)=0 by A63,A67,A80,SCMP_GCD:1;
A84: now
      let x;
A85: (Initialize It).GBP = It.GBP by SCMPDS_5:15;
A86: (Initialize It).DataLoc(It.GBP,7) = It.DataLoc(It.GBP,7) by SCMPDS_5:15;
      thus IExec(WH2,Q,t).x =IExec(WH2,IT,Initialize It).x
       by A63,A65,A68,A69,Th6
        .=(Initialize It).x by A83,A85,A86,SCMPDS_8:23
        .=It.x by SCMPDS_5:15;
    end;
    hence IExec(WH2,Q,t).a=0 by A82;
    It.a1=t.a1 by A6,A62,A65,A66,A81,Lm13;
    hence IExec(WH2,Q,t).a1=t.a1 by A84;
    thus IExec(WH2,Q,t).a7=0 by A63,A67,A80,A84;
    It.a2=t.a2 by A6,A62,A65,A66,A81,Lm13;
    hence IExec(WH2,Q,t).a2=t.a2 by A84;
    It.a4=t.a4 by A6,A62,A65,A66,A81,Lm13;
    hence IExec(WH2,Q,t).a4=t.a4 by A84;
A87: now
      let i be Nat;
      assume
A88:  i >= 8;
      thus IExec(WH2,Q,t).intpos i=It.intpos i by A84
        .=t.intpos i by A6,A62,A65,A66,A81,A88,Lm13;
    end;
    hence for i be Nat st i >= 8
    holds IExec(WH2,Q,t).intpos i=t.intpos i;
A89: IExec(WH2,Q,t).intpos me=t.intpos me by A65,A87;
      per cases;
      suppose
A90:    t.intpos md > t.intpos me;
         reconsider m5=0 as Nat;
        take m5;
        take mE3=m3;
        thus IExec(WH2,Q,t).a5=m5 by A63,A67,A84,A90;
        thus IExec(WH2,Q,t).a3 =mE3 by A63,A64,A67,A84,A90;
        thus mE3+m5=m3;
        thus m5 <= t.a7 by A63;
        hereby
          let i be Nat;
          assume that
A91:      t.a3 <= i and
A92:      i < mE3;
          i <= me by A63,A64,A92,NAT_1:13;
          then i=t.a3 by A91,XXREAL_0:1;
          hence IExec(WH2,Q,t).intpos md
           > IExec(WH2,Q,t).intpos i by A6,A87,A89,A90;
        end;
        thus m5=0 or IExec(WH2,Q,t).intpos md <=
        IExec(WH2,Q,t).intpos mE3;
      end;
      suppose
A93:    t.intpos md <= t.intpos me;
         reconsider m5=1 as Nat;
        take m5;
        take mE3=me;
        thus IExec(WH2,Q,t).a5=m5 by A63,A80,A84,A93;
        thus IExec(WH2,Q,t).a3=mE3 by A80,A84,A93;
        thus mE3+m5=m3 by A63,A64;
        thus m5 <= t.a7 by A63;
        thus for i be Nat st t.a3 <= i
         & i < mE3 holds IExec(WH2,Q,t).intpos md > IExec(WH2,Q,t).intpos i;
        thus m5=0 or IExec(WH2,Q,t).intpos md
         <= IExec(WH2,Q,t).intpos mE3 by A6,A87,A89,A93;
      end;
  end;
  then
A94: P[0];
  for k be Nat holds P[k] from NAT_1:sch 2(A94,A8);
  hence thesis by A1,A3,A4,A5,A7;
end;

Lm15: for s being 0-started State of SCMPDS,md be Nat
 st s.GBP=0 & s.a3>=8 &
s.a2=md & md >= 8 holds WH2 is_closed_on s,P & WH2 is_halting_on s,P
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,md be Nat;
  set b=DataLoc(s.a,7);
  assume that
A1: s.a=0 and
A2: s.a3>=8 and
A3: s.a2=md and
A4: md >= 8;
A5: b=intpos (0+7) by A1,SCMP_GCD:1;
  now
    let v be 0-started State of SCMPDS, V;
    assume that
A6: v.a3 >= 8 and
A7: v.a2=s.a2 and
A8: v.a=s.a and
A9: v.b > 0;
    reconsider ME=v.a3 as Element of NAT by A6,INT_1:3;
A10: ME=v.a3;
    hence IExec(WB2,V,v).a=v.a
     by A1,A3,A4,A6,A7,A8,Lm13;
    thus WB2 is_closed_on v,V & WB2 is_halting_on v,V by SCMPDS_6:20,21;
A11: v.intpos md > v.intpos ME implies IExec(WB2,V,v).a7=v.a7-1
 & IExec(WB2,V,v) .a3=v.a3+1
     & IExec(WB2,V,v).a5=v.a7-1 by A1,A3,A4,A6,A7,A8,Lm13;
    hereby
      per cases;
      suppose
A12:    v.intpos md > v.intpos ME;
        hence IExec(WB2,V,v).b < v.b by A5,A11,XREAL_1:146;
A13:    v.a3 +1 > v.a3 by XREAL_1:29;
        IExec(WB2,V,v).a3=v.a3+1
        by A1,A3,A4,A6,A7,A8,A12,Lm13;
        hence IExec(WB2,V,v).a3 >= 8 by A6,A13,XXREAL_0:2;
      end;
      suppose
A14:    v.intpos md <= v.intpos ME;
        hence IExec(WB2,V,v).b < v.b
         by A1,A3,A4,A5,A6,A7,A8,A9,Lm13;
        thus IExec(WB2,V,v).a3 >= 8
         by A1,A3,A4,A6,A7,A8,A14,Lm13;
      end;
    end;
    thus IExec(WB2,V,v).a2=v.a2 by A1,A3,A4,A6,A7,A8,A10,Lm13;
  end;
  hence thesis by A2,Th6;
end;

Lm16: card WB3=29
proof
  thus card WB3=card (WH1 ';' WH2 )+card IF3 by AFINSQ_1:17
    .=11+ 11+card IF3 by Lm10,Lm12,AFINSQ_1:17
    .=22+(card (k5 ';' k6 ';' k7 ';' k8 ';' k9 ';' k0)+1) by SCMPDS_6:75
    .=22+(card (k5 ';' k6 ';' k7 ';' k8 ';' k9)+1+1) by SCMP_GCD:4
    .=22+(card (k5 ';' k6 ';' k7 ';' k8)+1+1+1) by SCMP_GCD:4
    .=22+(card (k5 ';' k6 ';' k7)+1+1+1+1) by SCMP_GCD:4
    .=22+(card (k5 ';' k6)+1+1+1+1+1) by SCMP_GCD:4
    .=22+(2+1+1+1+1+1) by SCMP_GCD:5
    .=29;
end;

Lm17: card WH3=31
proof
  thus card WH3=29+2 by Lm16,SCMPDS_8:17
    .=31;
end;

begin :: The Basic Property of Partition Program

theorem Th9:
  card Partition=38
proof
  thus card Partition=card (K4 ';' WH3 ';' j8 ';' j9)+1 by SCMP_GCD:4
    .=card (K4 ';' WH3 ';' j8)+1+1 by SCMP_GCD:4
    .=card (K4 ';' WH3)+1+1+1 by SCMP_GCD:4
    .=card K4+card WH3+1+1+1 by AFINSQ_1:17
    .=4+31+1+1+1 by Lm17,Th4
    .=38;
end;

Lm18: for s be 0-started State of SCMPDS,
m3,m4 be Nat st s.GBP=0 & s.a5 > 0 &
s.a3=m3 & s.a4=m4 & m3>6 & m4 > 6
 holds IExec(IF3,P,Initialize s).GBP=0 & IExec(IF3,P,Initialize s).a1=s.
a1 & IExec(IF3,P,Initialize s).a2=s.a2 &
IExec(IF3,P,Initialize s).intpos m3=s.intpos m4
 & IExec(IF3,P,Initialize s).
intpos m4=s.intpos m3 & IExec(IF3,P,Initialize s).a3=s.a3+1
 & IExec(IF3,P,Initialize s).a4=s.a4-1 &
 IExec(IF3,P,Initialize s).a5=s.a5-2 &
  for i be Nat st i >= 8 & i <> m3 & i <> m4 holds
IExec(IF3,P,Initialize s).intpos i=s.intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m3,m4 be Nat;
  assume that
A1: s.a=0 and
A2: s.a5 > 0 and
A3: s.a3=m3 and
A4: s.a4=m4 and
A5: m3 > 6 and
A6: m4 > 6;
A7: m4 > 3 by A6,XXREAL_0:2;

  set x=intpos m3, y=intpos m4, t0=Initialize s, t1=IExec(k5 ';' k6 ';' k7

';' k8 ';' k9 ';' k0,P,Initialize s),
t2=IExec(k5 ';' k6 ';' k7 ';' k8 ';' k9,P,Initialize s),
t3=IExec(k5 ';' k6 ';' k7 ';' k8,P,Initialize s),
t4=IExec(k5 ';' k6 ';' k7,P,Initialize s), t5=IExec(k5 ';' k6,P,Initialize s)
  , t6=Exec(k5,t0);

A8: t0.a=0 by A1,SCMPDS_5:15;
  then
A9: DataLoc(t0.a,6)=intpos (0+6) by SCMP_GCD:1;
  then
A10: t6.a =0 by A8,AMI_3:10,SCMPDS_2:47;
A11: t0.a4=m4 by A4,SCMPDS_5:15;
  then
A12: t6.a4 =m4 by A9,AMI_3:10,SCMPDS_2:47;
  then
A13: DataLoc(t6.a4,0)=intpos (m4+0) by SCMP_GCD:1;
A14: t5.a =Exec(k6, t6).a by SCMPDS_5:42
    .=0 by A6,A10,A13,AMI_3:10,SCMPDS_2:47;
A15: t6.a6 =t0.DataLoc(t0.a4,0) by A9,SCMPDS_2:47
    .=t0.intpos(m4+0) by A11,SCMP_GCD:1
    .=s.y by SCMPDS_5:15;
  t5.a6 =Exec(k6, t6).a6 by SCMPDS_5:42
    .=s.y by A6,A15,A13,AMI_3:10,SCMPDS_2:47;
  then
A16: t5.DataLoc(t5.a,6)=s.y by A14,SCMP_GCD:1;
  t0.a3=m3 by A3,SCMPDS_5:15;
  then
A17: t6.a3 =m3 by A9,AMI_3:10,SCMPDS_2:47;
A18: t5.a3 =Exec(k6, t6).a3 by SCMPDS_5:42
    .=m3 by A7,A17,A13,AMI_3:10,SCMPDS_2:47;
  then
A19: DataLoc(t5.a3,0)=intpos (m3+0) by SCMP_GCD:1;
A20: t0.x=s.x by SCMPDS_5:15;
A21: t5.y=Exec(k6, t6).y by SCMPDS_5:42
    .=t6.DataLoc(t6.a3,0) by A13,SCMPDS_2:47
    .=t6.intpos(m3+0) by A17,SCMP_GCD:1
    .=s.x by A5,A20,A9,AMI_3:10,SCMPDS_2:47;
A22: now
    per cases;
    suppose
A23:  y<>DataLoc(t5.a3,0);
      thus t4.y =Exec(k7, t5).y by SCMPDS_5:41
        .=s.x by A21,A23,SCMPDS_2:47;
    end;
    suppose
A24:  y=DataLoc(t5.a3,0);
      thus t4.y =Exec(k7, t5).y by SCMPDS_5:41
        .=s.x by A19,A16,A24,SCMPDS_2:47;
    end;
  end;
  t0.a2=s.a2 by SCMPDS_5:15;
  then
A25: t6.a2 =s.a2 by A9,AMI_3:10,SCMPDS_2:47;
A26: m4 > 2 by A6,XXREAL_0:2;
A27: m3 > 5 by A5,XXREAL_0:2;
A28: t4.a =Exec(k7, t5).a by SCMPDS_5:41
    .=0 by A5,A14,A19,AMI_3:10,SCMPDS_2:47;
  then
A29: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:1;
A30: t3.a =Exec(k8, t4).a by SCMPDS_5:41
    .=0 by A28,A29,AMI_3:10,SCMPDS_2:48;
  then
A31: a<>DataLoc(t3.a,3) by AMI_3:10,SCMP_GCD:1;
A32: m3 > 3 by A5,XXREAL_0:2;
  then
A33: x<>DataLoc(t3.a,3) by A30,AMI_3:10,SCMP_GCD:1;
A34: t4.a3 =Exec(k7, t5).a3 by SCMPDS_5:41
    .=m3 by A32,A18,A19,AMI_3:10,SCMPDS_2:47;
A35: t3.a3 =Exec(k8, t4).a3 by SCMPDS_5:41
    .=m3 by A34,A29,AMI_3:10,SCMPDS_2:48;
A36: DataLoc(t3.a,3)=intpos (0+3) by A30,SCMP_GCD:1;
A37: t2.a3 =Exec(k9, t3).a3 by SCMPDS_5:41
    .=m3+1 by A35,A36,SCMPDS_2:48;
A38: m3 > 2 by A5,XXREAL_0:2;
A39: m4 > 5 by A6,XXREAL_0:2;
A40: t5.a2 =Exec(k6, t6).a2 by SCMPDS_5:42
    .=s.a2 by A25,A13,A26,AMI_3:10,SCMPDS_2:47;
A41: t4.x=Exec(k7, t5).x by SCMPDS_5:41
    .=s.y by A19,A16,SCMPDS_2:47;
A42: t3.x =Exec(k8, t4).x by SCMPDS_5:41
    .=s.y by A27,A41,A29,AMI_3:10,SCMPDS_2:48;
A43: t2.x =Exec(k9, t3).x by SCMPDS_5:41
    .=s.y by A42,A33,SCMPDS_2:48;
A44: t3.y =Exec(k8, t4).y by SCMPDS_5:41
    .=s.x by A39,A22,A29,AMI_3:10,SCMPDS_2:48;
A45: y<>DataLoc(t3.a,3) by A7,A30,AMI_3:10,SCMP_GCD:1;
A46: t2.y =Exec(k9, t3).y by SCMPDS_5:41
    .=s.x by A44,A45,SCMPDS_2:48;
A47: t4.a2 =Exec(k7, t5).a2 by SCMPDS_5:41
    .=s.a2 by A40,A19,A38,AMI_3:10,SCMPDS_2:47;
A48: t3.a2 =Exec(k8, t4).a2 by SCMPDS_5:41
    .=s.a2 by A47,A29,AMI_3:10,SCMPDS_2:48;
A49: a2<>DataLoc(t3.a,3) by A30,AMI_3:10,SCMP_GCD:1;
A50: t2.a2 =Exec(k9, t3).a2 by SCMPDS_5:41
    .=s.a2 by A48,A49,SCMPDS_2:48;
A51: m4 > 1 by A6,XXREAL_0:2;
A52: DataLoc(s.a,5)=intpos(0+5) by A1,SCMP_GCD:1;
  t0.a5=s.a5 by SCMPDS_5:15;
  then
A53: t6.a5 =s.a5 by A9,AMI_3:10,SCMPDS_2:47;
A54: t5.a5 =Exec(k6, t6).a5 by SCMPDS_5:42
    .=s.a5 by A39,A53,A13,AMI_3:10,SCMPDS_2:47;
A55: t4.a5 =Exec(k7, t5).a5 by SCMPDS_5:41
    .=s.a5 by A27,A54,A19,AMI_3:10,SCMPDS_2:47;
A56: t3.a5 =Exec(k8, t4).a5 by SCMPDS_5:41
    .=t4.a5+-2 by A29,SCMPDS_2:48
    .=s.a5-2 by A55;
A57: a5<>DataLoc(t3.a,3) by A30,AMI_3:10,SCMP_GCD:1;
A58: t2.a5 =Exec(k9, t3).a5 by SCMPDS_5:41
    .=s.a5-2 by A56,A57,SCMPDS_2:48;
  t0.a1=s.a1 by SCMPDS_5:15;
  then
A59: t6.a1 =s.a1 by A9,AMI_3:10,SCMPDS_2:47;
A60: m3 > 1 by A5,XXREAL_0:2;
A61: t2.a =Exec(k9, t3).a by SCMPDS_5:41
    .=0 by A30,A31,SCMPDS_2:48;
  then
A62: a<>DataLoc(t2.a,4) by AMI_3:10,SCMP_GCD:1;
A63: m4 > 4 by A6,XXREAL_0:2;
  then
A64: y<>DataLoc(t2.a,4) by A61,AMI_3:10,SCMP_GCD:1;
A65: m3 > 4 by A5,XXREAL_0:2;
  then
A66: x<>DataLoc(t2.a,4) by A61,AMI_3:10,SCMP_GCD:1;
A67: a4<>DataLoc(t3.a,3) by A30,AMI_3:10,SCMP_GCD:1;
A68: t5.a4 =Exec(k6, t6).a4 by SCMPDS_5:42
    .=m4 by A63,A12,A13,AMI_3:10,SCMPDS_2:47;
A69: t4.a4 =Exec(k7, t5).a4 by SCMPDS_5:41
    .=m4 by A65,A68,A19,AMI_3:10,SCMPDS_2:47;
A70: t3.a4 =Exec(k8, t4).a4 by SCMPDS_5:41
    .=m4 by A69,A29,AMI_3:10,SCMPDS_2:48;
A71: t2.a4 =Exec(k9, t3).a4 by SCMPDS_5:41
    .=m4 by A70,A67,SCMPDS_2:48;
A72: a3<>DataLoc(t2.a,4) by A61,AMI_3:10,SCMP_GCD:1;
A73: t5.a1 =Exec(k6, t6).a1 by SCMPDS_5:42
    .=s.a1 by A59,A13,A51,AMI_3:10,SCMPDS_2:47;
A74: t4.a1 =Exec(k7, t5).a1 by SCMPDS_5:41
    .=s.a1 by A73,A19,A60,AMI_3:10,SCMPDS_2:47;
A75: t3.a1 =Exec(k8, t4).a1 by SCMPDS_5:41
    .=s.a1 by A74,A29,AMI_3:10,SCMPDS_2:48;
A76: a1<>DataLoc(t3.a,3) by A30,AMI_3:10,SCMP_GCD:1;
A77: t2.a1 =Exec(k9, t3).a1 by SCMPDS_5:41
    .=s.a1 by A75,A76,SCMPDS_2:48;
A78: a1<>DataLoc(t2.a,4) by A61,AMI_3:10,SCMP_GCD:1;
  t1.a =Exec(k0, t2).a by SCMPDS_5:41
    .=0 by A61,A62,SCMPDS_2:48;
  hence IExec(IF3,P,Initialize s).a=0 by A2,A52,SCMPDS_6:83;
  t1.a1 =Exec(k0, t2).a1 by SCMPDS_5:41
    .=s.a1 by A77,A78,SCMPDS_2:48;
  hence IExec(IF3,P,Initialize s).a1=s.a1 by A2,A52,SCMPDS_6:83;
A79: a2<>DataLoc(t2.a,4) by A61,AMI_3:10,SCMP_GCD:1;
  t1.a2 =Exec(k0, t2).a2 by SCMPDS_5:41
    .=s.a2 by A50,A79,SCMPDS_2:48;
  hence IExec(IF3,P,Initialize s).a2=s.a2 by A2,A52,SCMPDS_6:83;
  t1.x =Exec(k0, t2).x by SCMPDS_5:41
    .=s.y by A43,A66,SCMPDS_2:48;
  hence IExec(IF3,P,Initialize s).x=s.y by A2,A52,SCMPDS_6:83;
  t1.y =Exec(k0, t2).y by SCMPDS_5:41
    .=s.x by A46,A64,SCMPDS_2:48;
  hence IExec(IF3,P,Initialize s).y=s.x by A2,A52,SCMPDS_6:83;
A80: DataLoc(t2.a,4)=intpos (0+4) by A61,SCMP_GCD:1;
  t1.a3 =Exec(k0, t2).a3 by SCMPDS_5:41
    .=m3+1 by A37,A72,SCMPDS_2:48;
  hence IExec(IF3,P,Initialize s).a3=s.a3+1 by A2,A3,A52,SCMPDS_6:83;
  t1.a4 =Exec(k0, t2).a4 by SCMPDS_5:41
    .=t2.a4+-1 by A80,SCMPDS_2:48
    .=s.a4-1 by A4,A71;
  hence IExec(IF3,P,Initialize s).a4=s.a4-1 by A2,A52,SCMPDS_6:83;
A81: a5<>DataLoc(t2.a,4) by A61,AMI_3:10,SCMP_GCD:1;
  t1.a5 =Exec(k0, t2).a5 by SCMPDS_5:41
    .=s.a5-2 by A58,A81,SCMPDS_2:48;
  hence IExec(IF3,P,Initialize s).a5=s.a5-2 by A2,A52,SCMPDS_6:83;
A82: now
    let i be Nat;
    assume that
A83: i >= 8 and
    i <> m3 and
    i <> m4;
    i > 6 by A83,XXREAL_0:2;
    hence t6.intpos i =t0.intpos i by A9,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by SCMPDS_5:15;
  end;
A84: now
    let i be Nat;
    assume that
A85: i >= 8 and
A86: i <> m3 and
A87: i <> m4;
    thus t5.intpos i =Exec(k6, t6).intpos i by SCMPDS_5:42
      .=t6.intpos i by A13,A87,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by A82,A85,A86,A87;
  end;
A88: now
    let i be Nat;
    assume that
A89: i >= 8 and
A90: i <> m3 and
A91: i <> m4;
    thus t4.intpos i =Exec(k7, t5).intpos i by SCMPDS_5:41
      .=t5.intpos i by A19,A90,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by A84,A89,A90,A91;
  end;
A92: now
    let i be Nat;
    assume that
A93: i >= 8 and
A94: i <> m3 and
A95: i <> m4;
A96: i > 5 by A93,XXREAL_0:2;
    thus t3.intpos i =Exec(k8, t4).intpos i by SCMPDS_5:41
      .=t4.intpos i by A29,A96,AMI_3:10,SCMPDS_2:48
      .=s.intpos i by A88,A93,A94,A95;
  end;
A97: now
    let i be Nat;
    assume that
A98: i >= 8 and
A99: i <> m3 and
A100: i <> m4;
    i > 3 by A98,XXREAL_0:2;
    then
A101: intpos i <> DataLoc(t3.a,3) by A30,AMI_3:10,SCMP_GCD:1;
    thus t2.intpos i =Exec(k9, t3).intpos i by SCMPDS_5:41
      .=t3.intpos i by A101,SCMPDS_2:48
      .=s.intpos i by A92,A98,A99,A100;
  end;
A102: now
    let i be Nat;
    assume that
A103: i >= 8 and
A104: i <> m3 and
A105: i <> m4;
    i > 4 by A103,XXREAL_0:2;
    then
A106: intpos i <> DataLoc(t2.a,4) by A61,AMI_3:10,SCMP_GCD:1;
    thus t1.intpos i =Exec(k0, t2).intpos i by SCMPDS_5:41
      .=t2.intpos i by A106,SCMPDS_2:48
      .=s.intpos i by A97,A103,A104,A105;
  end;
  hereby
    let i be Nat;
    assume that
A107: i >= 8 and
A108: i <> m3 and
A109: i <> m4;
    thus IExec(IF3,P,Initialize s).intpos i = t1.intpos i by A2,A52,SCMPDS_6:83
      .=s.intpos i by A102,A107,A108,A109;
  end;
end;

Lm19: for s be 0-started State of SCMPDS,
md,m3 be Nat st s.GBP=0 & s.a5 > 0 &
s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md & md >= 8 & md <= m3
 holds WB3 is_closed_on s,P
  & WB3 is_halting_on s,P & IExec(WB3,P,s).GBP=0 &
  IExec(WB3,P,s).a1=s.a1
 & IExec(WB3,P,s).a2=md & IExec(WB3,P,s).a3 >= s.a3
 & IExec(WB3,P,s).a4 <= s.a4 & IExec(WB3,P,s).a4
>= m3 & IExec(WB3,P,s).a5 < s.a5 & IExec(WB3,P,s).a5 >= -1
 & IExec(WB3,P,s).a4= IExec(WB3,P,s).a3-1+IExec(WB3,P,s).a5
 & ex n1,n2 be Nat st n1=IExec(WB3,P,s).a3-1 &
 n2=IExec(WB3,P,s).a4+1
 & (for i be Nat st i >= 8 & i <>n1 & i<> n2
holds IExec(WB3,P,s).intpos i=s.intpos i)
 & (IExec(WB3,P,s).intpos n1=s.intpos n1 &
IExec(WB3,P,s).intpos n2=s.intpos n2 or n1 >= s.a3
 & n2 <= s.a4 & IExec(WB3,P,s).
intpos n1=s.intpos n2 & IExec(WB3,P,s).intpos n2=s.intpos n1)
 & (for i be Nat st s.a3<=i & i <= n1
 holds IExec(WB3,P,s).intpos md >= IExec(WB3,P,s).intpos i) &
  for i be Nat st n2<=i & i <= s.a4
 holds IExec(WB3,P,s).intpos md <= IExec(WB3,P,s).intpos i
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,md,m3 be Nat;
A1: Initialize s = s by MEMSTR_0:44;
  assume that
A2: s.a=0 and
A3: s.a5 > 0 and
A4: s.a4=m3+s.a5 and
A5: m3=s.a3-1 and
A6: s.a2=md and
A7: md >= 8 and
A8: md <= m3;
  set s1=IExec(WH1,P,s);
A9: s1.a = (Initialize s1).a by SCMPDS_5:15;
A10: s1.a1 = (Initialize s1).a1 by SCMPDS_5:15;
A11: s1.a2 = (Initialize s1).a2 by SCMPDS_5:15;
A12: s1.a3 = (Initialize s1).a3 by SCMPDS_5:15;
A13: s1.a4 = (Initialize s1).a4 by SCMPDS_5:15;
A14: s1.a7 = (Initialize s1).a7 by SCMPDS_5:15;
A15: m3 >= 8 by A7,A8,XXREAL_0:2;
  then consider mE be Nat such that
A16: mE=s1.a7 and
A17: s1.a4=m3+mE and
A18: mE <= s.a5 and
A19: for i be Nat st m3+mE < i & i <=s.a4 holds s1.intpos md
  < s1.intpos i and
A20: mE = 0 or s1.intpos md >= s1.intpos(m3+mE) by A2,A3,A4,A6,A7,Lm8;
A21: s1.a=0 by A2,A3,A4,A6,A7,A15,Lm8;
A22: s1.a1=s.a1 by A2,A3,A4,A6,A7,A15,Lm8;
A23: WH1 is_halting_on s,P by A2,A4,A6,A7,A15,Lm9;

  set s2=IExec(WH2,P,Initialize s1), sm=m3+1+mE,
     s12=IExec(WH1 ';' WH2,P,s),
     s3=IExec(WB3,P,s), P12 = P, P3 = P,
  m4=m3+mE;
A24: s12.a = (Initialize s12).a by SCMPDS_5:15;
A25: s12.a1 = (Initialize s12).a1 by SCMPDS_5:15;
A26: s12.a2 = (Initialize s12).a2 by SCMPDS_5:15;
A27: s12.a3 = (Initialize s12).a3 by SCMPDS_5:15;
A28: s12.a4 = (Initialize s12).a4 by SCMPDS_5:15;
A29: s12.a5 = (Initialize s12).a5 by SCMPDS_5:15;
A30: s1.a3+s1.a7=sm by A2,A3,A4,A5,A6,A7,A15,A16,Lm8;
A31: m4 >= 8 by A15,NAT_1:12;
A32: s1.a2=s.a2 by A2,A3,A4,A6,A7,A15,Lm8;
A33: s1.a3=s.a3 by A2,A3,A4,A6,A7,A15,Lm8;
  s1.a3=m3+1 by A2,A3,A4,A5,A6,A7,A15,Lm8;
  then m3 < s1.a3 by XREAL_1:29;
  then
A34: s1.a3 >= 8 by A15,XXREAL_0:2;
A35: s1.a5=0 by A2,A3,A4,A6,A7,A15,Lm8;
A36: m3+mE <= m3+s.a5 by A18,XREAL_1:6;
A37: WH1 is_closed_on s,P by A2,A4,A6,A7,A15,Lm9;
  per cases;
  suppose
A38: mE <= 0;
A39: (Initialize s1).GBP = s1.GBP by SCMPDS_5:15;
A40: (Initialize s1).DataLoc(s1.GBP,7) = s1.DataLoc(s1.GBP,7) by SCMPDS_5:15;
A41: (Initialize s1).a5 = s1.a5 by SCMPDS_5:15;
A42: (Initialize s1).a1 = s1.a1 by SCMPDS_5:15;
A43: (Initialize s1).a2 = s1.a2 by SCMPDS_5:15;
A44: (Initialize s1).a3 = s1.a3 by SCMPDS_5:15;
A45: (Initialize s1).a4 = s1.a4 by SCMPDS_5:15;

A46: DataLoc(s1.a,7)=intpos(0+7) by A21,SCMP_GCD:1;
    then
A47: WH2 is_halting_on s1,P by A16,A38,SCMPDS_8:20;
A48: WH2 is_closed_on s1,P by A16,A38,A46,SCMPDS_8:20;
    then
A49: s12.a5=s2.a5 by A37,A23,A47,SCMPDS_7:30
      .=0 by A35,A41,A16,A38,A46,A39,A40,SCMPDS_8:23;
A50: s12.a=s2.a by A37,A23,A48,A47,SCMPDS_7:30
      .=0 by A21,A39,A16,A38,A46,A40,SCMPDS_8:23;
    then
A51: DataLoc(s12.a,5)=intpos(0+5) by SCMP_GCD:1;

A52: WH1 ';' WH2 is_halting_on s,P by A37,A23,A48,A47,A1,SCMPDS_7:24;
A53: WH1 ';' WH2 is_closed_on s,P by A37,A23,A48,A47,A1,SCMPDS_7:24;
    hence WB3 is_closed_on s,P & WB3 is_halting_on s,P by A52,SCPISORT:8;
    thus IExec(WB3,P,s).a
       =IExec(IF3,P12,Initialize s12).a by A53,A52,SCPISORT:6
      .=0 by A50,A49,A51,SCMPDS_6:84;
    thus IExec(WB3,P,s).a1=IExec(IF3,P12,Initialize s12).a1
    by A53,A52,SCPISORT:6
      .= s12.a1 by A49,A51,SCMPDS_6:84
      .= s2.a1 by A37,A23,A48,A47,SCMPDS_7:30
      .= s.a1 by A22,A16,A38,A46,A39,A40,A42,SCMPDS_8:23;
    thus s3.a2=IExec(IF3,P12,Initialize s12).a2 by A53,A52,SCPISORT:6
      .= s12.a2 by A49,A51,SCMPDS_6:84
      .= s2.a2 by A37,A23,A48,A47,SCMPDS_7:30
      .= md by A6,A32,A16,A38,A46,A39,A40,A43,SCMPDS_8:23;
A54: s3.a3=IExec(IF3,P12,Initialize s12).a3 by A53,A52,SCPISORT:6
      .= s12.a3 by A49,A51,SCMPDS_6:84
      .= s2.a3 by A37,A23,A48,A47,SCMPDS_7:30
      .= s.a3 by A33,A16,A38,A46,A39,A40,A44,SCMPDS_8:23;
    hence s3.a3 >= s.a3;
A55: s3.a4=IExec(IF3,P12,Initialize s12).a4 by A53,A52,SCPISORT:6
      .= s12.a4 by A49,A51,SCMPDS_6:84
      .= s2.a4 by A37,A23,A48,A47,SCMPDS_7:30
      .= m4 by A16,A17,A38,A46,A39,A40,A45,SCMPDS_8:23;
    hence s3.a4 <= s.a4 by A4,A18,XREAL_1:6;
    thus s3.a4 >= m3 by A55,NAT_1:12;
A56: s3.a5=IExec(IF3,P12,Initialize s12).a5 by A53,A52,SCPISORT:6
      .=0 by A49,A51,SCMPDS_6:84;
    hence s3.a5 < s.a5 by A3;
    thus s3.a5 >= -1 by A56;
    thus s3.a4=s3.a3-1+s3.a5 by A5,A38,A54,A55,A56;
    take n1=m4;
    take n2=m4+1;
A57: mE=0 by A38;
    hence n1=s3.a3-1 by A5,A54;
    thus n2=s3.a4+1 by A55;
A58: now
      let x;
      thus s3.x=IExec(IF3,P12,Initialize s12).x by A53,A52,SCPISORT:6
        .=s12.x by A49,A51,SCMPDS_6:84
        .=s2.x by A37,A23,A48,A47,SCMPDS_7:30;
    end;
A59: now
      let i be Nat;
      assume
A60:  i >= 8;
A61: (Initialize s1).GBP = s1.GBP by SCMPDS_5:15;
A62: (Initialize s1).DataLoc(s1.GBP,7) = s1.DataLoc(s1.GBP,7) by SCMPDS_5:15;
      thus s3.intpos i=s2.intpos i by A58
        .=(Initialize s1).intpos i by A16,A38,A46,A61,A62,SCMPDS_8:23
        .=s1.intpos i by SCMPDS_5:15
        .=s.intpos i by A2,A3,A4,A6,A7,A15,A60,Lm8;
    end;
   hence
    for i be Nat st i >= 8 & i <>n1 & i<> n2
     holds s3.intpos i =s.intpos i;
A63: m4 < n2 by XREAL_1:29;
    hence s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or n1 >= s.a3 &
n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A31,A59,
XXREAL_0:2;
    thus for i be Nat st s.a3<=i & i <= n1 holds s3.intpos md >= s3
    .intpos i by A5,A57,XREAL_1:146,XXREAL_0:2;
    hereby
A64: (Initialize s1).GBP = s1.GBP by SCMPDS_5:15;
A65: (Initialize s1).DataLoc(s1.GBP,7) = s1.DataLoc(s1.GBP,7) by SCMPDS_5:15;
A66:  s3.intpos md=s2.intpos md by A58
        .=(Initialize s1).intpos md by A16,A38,A46,A64,A65,SCMPDS_8:23
        .=s1.intpos md by SCMPDS_5:15;
      let i be Nat;
      assume that
A67:  n2<=i and
A68:  i <= s.a4;
A69:  s3.intpos i=s2.intpos i by A58
        .=(Initialize s1).intpos i by A16,A38,A46,A64,A65,SCMPDS_8:23
        .=s1.intpos i by SCMPDS_5:15;
      m4 < i by A63,A67,XXREAL_0:2;
      hence s3.intpos md <= s3.intpos i by A19,A68,A66,A69;
    end;
  end;
  suppose
A70: mE > 0;
  then consider m5,mE3 be Nat such that
A71: m5=s2.a5 and
A72: s2.a3=mE3 and
A73: mE3+m5=sm and
A74: m5 <= (Initialize s1).a7 and
A75: (for i be Nat st (Initialize s1).a3 <= i & i < mE3 holds
    s2.intpos md > s2.intpos i) and
A76: (m5 = 0 or s2.intpos
 md <= s2.intpos mE3) by A5,A6,A7,A16,A21,A32,A33,A34,Lm14,A9,A11,A14,A12;
A77: mE3+m5 <= mE3+s1.a7 by A74,A14,XREAL_1:6;
    then
A78: s1.a3 <= mE3 by A5,A33,A16,A73,XREAL_1:6;
A79: s1.a3+s1.a7 <= mE3+s1.a7 by A5,A33,A16,A73,A74,A14,XREAL_1:6;
    then
A80: s.a3 <= mE3 by A33,XREAL_1:6;
    then mE3 >= 8 by A33,A34,XXREAL_0:2;
    then
A81: mE3 > 6 by XXREAL_0:2;
A82: (Initialize s1).GBP = s1.GBP by SCMPDS_5:15;
A83: (Initialize s1).a2 = s1.a2 by SCMPDS_5:15;
A84: (Initialize s1).a3 = s1.a3 by SCMPDS_5:15;

A85: WH2 is_halting_on Initialize s1,P by A6,A7,A21,A32,A34,Lm15,A82,A83,A84;
A86: WH2 is_halting_on s1,P
      proof
        P+*stop WH2 halts_on Initialize Initialize s1 by A85,SCMPDS_6:def 3;
       hence thesis by SCMPDS_6:def 3;
      end;
A87: WH2 is_closed_on Initialize s1,P by A6,A7,A21,A32,A34,Lm15,A82,A83,A84;
A88: WH2 is_closed_on s1,P
     proof
       for k being Nat holds
       IC Comput(P+*stop WH2,Initialize Initialize s1,k) in dom stop WH2
                    by A87,SCMPDS_6:def 2;
      hence thesis by SCMPDS_6:def 2;
     end;
    then
A89: WH1 ';' WH2 is_closed_on s,P by A37,A23,A86,A1,SCMPDS_7:24;
    s2.a1=s1.a1 by A5,A6,A7,A21,A32,A33,A34,A30,A70,Lm14,A9,A10,A11,A12,A14;
    then
A90: s12.a1=s.a1 by A22,A37,A23,A88,A86,SCMPDS_7:30;
    s2.a4=s1.a4
     by A5,A6,A7,A21,A32,A33,A34,A30,A70,Lm14,A9,A11,A12,A13,A14;
    then
A91: s12.a4=m4 by A17,A37,A23,A88,A86,SCMPDS_7:30;
    s2.a2=s1.a2 by A5,A6,A7,A21,A32,A33,A34,A30,A70,Lm14,A9,A11,A12,A14;
    then
A92: s12.a2=md by A6,A32,A37,A23,A88,A86,SCMPDS_7:30;
    s2.a=0 by A5,A6,A7,A21,A32,A33,A34,A30,A70,Lm14,A9,A11,A12,A14;
    then
A93: s12.a=0 by A37,A23,A88,A86,SCMPDS_7:30;
A94: s12.a5=m5 by A37,A23,A71,A88,A86,SCMPDS_7:30;
A95: s12.a3=mE3 by A37,A23,A72,A88,A86,SCMPDS_7:30;
A96: WH1 ';' WH2 is_halting_on s,P by A37,A23,A88,A86,A1,SCMPDS_7:24;
    hence WB3 is_closed_on s,P & WB3 is_halting_on s,P by A89,SCPISORT:8;
A97: m4 > 6 by A31,XXREAL_0:2;
A98: m4 > m3+0 by A70,XREAL_1:6;
    then
A99: m4 >= m3+1 by INT_1:7;
A100: IExec(IF3,P12,Initialize s12) = IExec(IF3,P12,Initialize Initialize s12);
    hereby
      per cases;
      suppose
A101:    s12.a5 > 0;
        then IExec(IF3,P12,Initialize s12).a=0
         by A93,A95,A81,A91,A97,Lm18,A24,A27,A28,A29,A100;
        hence IExec(WB3,P,s).a=0 by A89,A96,SCPISORT:6;
        IExec(IF3,P12,Initialize s12).a1=s12.a1
         by A93,A95,A81,A91,A97,A101,Lm18,A24,A25,A27,A28,A29,A100;
        hence IExec(WB3,P,s).a1=s.a1 by A89,A96,A90,SCPISORT:6;
        IExec(IF3,P12,Initialize s12).a2=s12.a2
         by A93,A95,A81,A91,A97,A101,Lm18,A24,A26,A27,A28,A29,A100;
        hence s3.a2=md by A89,A96,A92,SCPISORT:6;
        IExec(IF3,P12,Initialize s12).a3=s12.a3+1
         by A93,A95,A81,A91,A97,A101,Lm18,A24,A27,A28,A29,A100;
        then
A102:    s3.a3=mE3+1 by A89,A96,A95,SCPISORT:6;
        then mE3 < s3.a3 by XREAL_1:29;
        hence s3.a3 >= s.a3 by A33,A78,XXREAL_0:2;
A103:    IExec(IF3,P12,Initialize s12).a4=s12.a4-1
 by A93,A95,A81,A91,A97,A101,Lm18,A24,A27,A28,A29,A100;
        then
A104:    s3.a4=m4-1 by A89,A96,A91,SCPISORT:6;
        hence s3.a4 <= s.a4 by A4,A36,XREAL_1:146,XXREAL_0:2;
A105:    IExec(IF3,P12,Initialize s12).a5=s12.a5-2
 by A93,A95,A81,A91,A97,A101,Lm18,A24,A27,A28,A29,A100;
        then
A106:    s3.a5 =s12.a5-2 by A89,A96,SCPISORT:6;
        s12.a5 >=0+1 by A101,INT_1:7;
        then
A107:    s12.a5-2 >= 1-2 by XREAL_1:9;
        then
A108:    s3.a5+1 >= -1+1 by A106,XREAL_1:6;
        thus s3.a4 >= m3 by A99,A104,XREAL_1:19;
        m5 <= s.a5 by A16,A18,A74,A14,XXREAL_0:2;
        then m5-2 < s.a5-0 by XREAL_1:15;
        hence s3.a5 < s.a5 by A37,A23,A71,A88,A86,A106,SCMPDS_7:30;
        thus s3.a5 >= -1 by A89,A96,A105,A107,SCPISORT:6;
        thus s3.a4=s3.a3-1+s3.a5 by A73,A89,A96,A91,A94,A103,A102,A106
,SCPISORT:6;
        take n1=mE3;
        take n2=m4;
        n2=n1+(s3.a5+1) by A73,A94,A106;
        then
A109:    n2 >= n1+0 by A108,XREAL_1:6;
        thus n1=s3.a3-1 by A102;
        thus n2=m4+-1+1
          .=s3.a4+1 by A89,A96,A91,A103,SCPISORT:6;
A110:    now
          let i be Nat;
A111:      s1.intpos i = (Initialize s1).intpos i by SCMPDS_5:15;
          assume
A112:      i >= 8;
          thus s12.intpos i=s2.intpos i by A37,A23,A88,A86,SCMPDS_7:30
            .=s1.intpos i by A5,A6,A7,A21,A32,A33,A34,A30,A70,A112,Lm14,A9,A11
,A12,A14,A111
            .=s.intpos i by A2,A3,A4,A6,A7,A15,A112,Lm8;
        end;
A113:    now
          let i be Nat;
          assume that
A114:      i >= 8 and
A115:      i <>n1 and
A116:      i<> n2;
A117: s12.intpos i = (Initialize s12).intpos i by SCMPDS_5:15;
          thus s3.intpos i=IExec(IF3,P12,Initialize s12).intpos i
           by A89,A96,SCPISORT:6
            .=s12.intpos i by A93,A95,A81,A91,A97,A101,A114,A115,A116,Lm18,A24,
A27
,A28,A29,A100,A117
            .=s.intpos i by A110,A114;
        end;

        hence for i be Nat st i >= 8 & i <>n1 & i<> n2 holds s3.
        intpos i=s.intpos i;
A118: s12.intpos m4 = (Initialize s12).intpos m4 by SCMPDS_5:15;
        IExec(IF3,P12,Initialize s12).intpos mE3=s12.intpos m4
         by A93,A95,A81,A91,A97,A101,Lm18,A24,A27,A28,A29,A100,A118;
        then
A119:    s3.intpos n1=s12.intpos n2 by A89,A96,SCPISORT:6
          .=s.intpos n2 by A15,A110,NAT_1:12;
        m3 < m3+1 by XREAL_1:29;
        then m3 < n1 by A5,A33,A78,XXREAL_0:2;
        then
A120:    md < n1 by A8,XXREAL_0:2;
        then md < n2 by A109,XXREAL_0:2;
        then
A121:    n2 >= 8 by A7,XXREAL_0:2;
A122:    s3.intpos md=s.intpos md by A7,A113,A120,A109;
        then
A123:    s1.intpos md=s3.intpos md by A2,A3,A4,A6,A7,A15,Lm8;
A124: s12.intpos mE3 = (Initialize s12).intpos mE3 by SCMPDS_5:15;
        IExec(IF3,P12,Initialize s12).intpos m4=s12.intpos mE3
         by A93,A95,A81,A91,A97,A101,Lm18,A24,A27,A28,A29,A100,A124;
        then
A125:    s3.intpos n2=s12.intpos n1 by A89,A96,SCPISORT:6
          .=s.intpos n1 by A33,A34,A80,A110,XXREAL_0:2;
        hence
        s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or s.a3 <= n1
& n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A4,A33
,A18,A79,A119,XREAL_1:6;
A126:      s1.intpos md = (Initialize s1).intpos md by SCMPDS_5:15;
A127:    s2.intpos md=s1.intpos md by A5,A6,A7,A21,A32,A33,A34,A30,A70,Lm14,A9
,A11,A12,A14,A126
          .=s3.intpos md by A2,A3,A4,A6,A7,A15,A122,Lm8;
        hereby
          let i be Nat;
          assume that
A128:      s.a3<=i and
A129:      i <= n1;
A130:      i >= 8 by A33,A34,A128,XXREAL_0:2;
A131:      s1.a3 <= i by A2,A3,A4,A6,A7,A15,A128,Lm8;
          per cases;
          suppose
A132:        i < n1;
A133:      s1.intpos i = (Initialize s1).intpos i by SCMPDS_5:15;
            s2.intpos i=s1.intpos i by A5,A6,A7,A21,A32,A33,A34,A30,A70,A130,A9
,A11,A12,A14,A133,Lm14
              .=s.intpos i by A2,A3,A4,A6,A7,A15,A130,Lm8
              .=s3.intpos i by A33,A34,A113,A109,A128,A132,XXREAL_0:2;
            hence s3.intpos md >= s3.intpos i by A75,A127,A131,A132,A12;
          end;
          suppose
            i >= n1;
            then i=n1 by A129,XXREAL_0:1;
            hence
            s3.intpos md >= s3.intpos i by A2,A3,A4,A6,A7,A15,A20,A70,A119,A121
,A123,Lm8;
          end;
        end;
A134:    n1 >= 8 by A7,A120,XXREAL_0:2;
        hereby
          let i be Nat;
          assume that
A135:      n2<=i and
A136:     i <= s.a4;
A137:     i >= 8 by A121,A135,XXREAL_0:2;
A138:      s1.intpos n1 = (Initialize s1).intpos n1 by SCMPDS_5:15;
          per cases;
          suppose
A139:       n2 < i;
            s1.intpos i=s.intpos i by A2,A3,A4,A6,A7,A15,A137,Lm8
              .=s3.intpos i by A113,A109,A121,A139,XXREAL_0:2;
            hence s3.intpos md <= s3.intpos i by A19,A123,A136,A139;
          end;
          suppose
            n2 >= i;
            then i=n2 by A135,XXREAL_0:1;
            then s3.intpos i=s1.intpos n1 by A2,A3,A4,A6,A7,A15,A125,A134,Lm8
              .=s2.intpos n1 by A5,A6,A7,A21,A32,A33,A34,A30,A70,A134,Lm14,A9
,A11,A12,A14,A138;
            hence s3.intpos md <= s3.intpos i by A37,A23,A71,A76,A88,A86,A101
,A127,SCMPDS_7:30;

          end;
        end;
      end;
      suppose
A140:   s12.a5 <= 0;
A141:   DataLoc(s12.a,5)=intpos(0+5) by A93,SCMP_GCD:1;
        thus IExec(WB3,P,s).a=IExec(IF3,P12,Initialize s12).a
        by A89,A96,SCPISORT:6
          .=0 by A93,A140,A141,SCMPDS_6:84;
        thus IExec(WB3,P,s).a1=IExec(IF3,P12,Initialize s12).a1
        by A89,A96,SCPISORT:6
          .= s.a1 by A90,A140,A141,SCMPDS_6:84;
        thus s3.a2=IExec(IF3,P12,Initialize s12).a2 by A89,A96,SCPISORT:6
          .= md by A92,A140,A141,SCMPDS_6:84;
A142:   s3.a3=IExec(IF3,P12,Initialize s12).a3 by A89,A96,SCPISORT:6
          .= mE3 by A95,A140,A141,SCMPDS_6:84;
        hence s3.a3 >= s.a3 by A5,A16,A73,A77,XREAL_1:6;
A143:   s3.a4=IExec(IF3,P12,Initialize s12).a4 by A89,A96,SCPISORT:6
          .= m4 by A91,A140,A141,SCMPDS_6:84;
        hence s3.a4 <= s.a4 by A4,A18,XREAL_1:6;
A144:   s12.a5=0 by A37,A23,A71,A88,A86,A140,SCMPDS_7:30;
        thus s3.a4 >= m3 by A98,A143;
A145:   s3.a5=IExec(IF3,P12,Initialize s12).a5 by A89,A96,SCPISORT:6
          .=0 by A141,A144,SCMPDS_6:84;
        hence s3.a5 < s.a5 by A3;
        thus s3.a5 >= -1 by A145;
A146:   m4=m3+mE+1-1
          .=mE3+0-1 by A37,A23,A71,A73,A88,A86,A144,SCMPDS_7:30;
        hence s3.a4=s3.a3-1+s3.a5 by A142,A143,A145;
        take n1=m4;
         reconsider n2=m4+1 as Nat;
        take n2;
        thus n1=s3.a3-1 by A142,A146;
        thus n2=s3.a4+1 by A143;
A147:   now
          let x;
          thus s3.x=IExec(IF3,P12,Initialize s12).x by A89,A96,SCPISORT:6
            .=s12.x by A140,A141,SCMPDS_6:84
            .=s2.x by A37,A23,A88,A86,SCMPDS_7:30;
        end;
A148:   now
          let i be Nat;
          assume
A149:     i >= 8;
A150:      s1.intpos i = (Initialize s1).intpos i by SCMPDS_5:15;
          thus s3.intpos i=s2.intpos i by A147
            .=s1.intpos i by A5,A6,A7,A21,A32,A33,A34,A30,A70,A149,Lm14,A9,A11
,A12,A14,A150
            .=s.intpos i by A2,A3,A4,A6,A7,A15,A149,Lm8;
        end;
        hence for i be Nat st i >= 8 & i <>n1 & i<> n2 holds s3.
        intpos i=s.intpos i;
A151:   m4 < n2 by XREAL_1:29;
        hence
        s3.intpos n1=s.intpos n1 & s3.intpos n2=s.intpos n2 or s.a3 <= n1
& n2 <= s.a4 & s3.intpos n1=s.intpos n2 & s3.intpos n2=s.intpos n1 by A31,A148,
XXREAL_0:2;
        hereby
          let i be Nat;
          assume that
A152:     s.a3<=i and
A153:     i <= n1;
          i < mE3 by A146,A153,XREAL_1:146,XXREAL_0:2;
          then
A154:     s2.intpos md > s2.intpos i by A33,A75,A152,A12;
          s3.intpos md=s2.intpos md by A147;
          hence s3.intpos md >= s3.intpos i by A147,A154;
        end;
        hereby
          let i be Nat;
          assume that
A155:     n2<=i and
A156:     i <= s.a4;
A157:     m4 < i by A151,A155,XXREAL_0:2;
          then
A158:     i >= 8 by A31,XXREAL_0:2;
A159:      s1.intpos md = (Initialize s1).intpos md by SCMPDS_5:15;
A160:      s1.intpos i = (Initialize s1).intpos i by SCMPDS_5:15;
A161:     s3.intpos md=s2.intpos md by A147
            .=s1.intpos md by A5,A6,A7,A21,A32,A33,A34,A30,A70,Lm14,A9,A11,A12
,A14,A159;
          s3.intpos i=s2.intpos i by A147
            .=s1.intpos i by A5,A6,A7,A21,A32,A33,A34,A30,A70,A158,Lm14,A9,A11
,A12,A14,A160;
          hence s3.intpos md <= s3.intpos i by A19,A156,A157,A161;
        end;
      end;
    end;
  end;
end;

Lm20: for i be Integer st i >= -1 & i <= 0 holds i=-1 or i=0
proof
  let i be Integer;
  assume that
A1: i >= -1 and
A2: i <= 0;
  per cases;
  suppose
    i <= -1;
    hence thesis by A1,XXREAL_0:1;
  end;
  suppose
    i > -1;
    then i >= -1+1 by INT_1:7;
    hence thesis by A2;
  end;
end;

Lm21: for i1,i2 be Integer,n1,n2,i be Nat st i1 >= -1 & i1 <= 0 &
n2=i2+1 & i2=n1+i1 & i < n2 holds i <= n1

proof
  let i1,i2 be Integer,n1,n2,i be Nat;
  assume that
A1: i1 >= -1 and
A2: i1 <= 0 and
A3: n2=i2+1 and
A4: i2=n1+i1 and
A5: i < n2;
  per cases by A1,A2,Lm20;
  suppose
    i1=0;
    hence thesis by A3,A4,A5,NAT_1:13;
  end;
  suppose
    i1=-1;
    hence thesis by A3,A4,A5;
  end;
end;

Lm22: for i1,i2 be Integer,n1,n2 be Nat st i1 >= -1 & n2=i2+1 & i2=
n1+i1 holds n1 <= n2
proof
  let i1,i2 be Integer,n1,n2 be Nat;
  assume that
A1: i1 >= -1 and
A2: n2=i2+1 and
A3: i2=n1+i1;
  n1+i1 >= n1+ -1 by A1,XREAL_1:6;
  then i2+1 >= n1+ -1+1 by A3,XREAL_1:6;
  hence thesis by A2;
end;

Lm23: for s,s1 be State of SCMPDS,n0,n1,n2,n be Nat,f, f1 be
FinSequence of INT st f is_FinSequence_on s,n0 & f1 is_FinSequence_on s1,n0 &
len f=n & len f1 = n & (for i be Nat st i >= n0+1 & i<>n1 & i<>n2
holds s1.intpos i=s.intpos i) & (s1.intpos n1=s.intpos n1 & s1.intpos n2=s.
intpos n2 or n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=s
.intpos n2 & s1.intpos n2=s.intpos n1) holds f,f1 are_fiberwise_equipotent
proof
  let s,s1 be State of SCMPDS,n0,n1,n2,n be Nat, f,f1 be
  FinSequence of INT;
  assume that
A1: f is_FinSequence_on s,n0 and
A2: f1 is_FinSequence_on s1,n0;
  assume that
A3: len f=n and
A4: len f1 = n;
  assume
A5: for i be Nat st i >= n0+1 & i<>n1 & i<>n2 holds s1.intpos
  i=s.intpos i;
  assume that
A6: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or n1 >= n0+1 &
n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=s.intpos n2 & s1.intpos n2=
  s.intpos n1;
  per cases by A6;
  suppose
A7: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2;
A8: dom f1 = Seg n by A4,FINSEQ_1:def 3;
    now
      let i be Nat;
      reconsider a = i as Nat;
      assume
A9:   i in dom f1;
      then
A10:  1 <= i by A8,FINSEQ_1:1;
      then
A11:  n0+1 <= n0+i by XREAL_1:6;
A12:  i <= n by A8,A9,FINSEQ_1:1;
      per cases;
      suppose
A13:    n0+i<>n1 & n0+i<>n2;
        thus f1.i=s1.intpos (n0+a) by A2,A4,A10,A12
          .=s.intpos (n0+a) by A5,A11,A13
          .=f.i by A1,A3,A10,A12;
      end;
      suppose
A14:    not (n0+i<>n1 & n0+i<>n2);
        hereby
          per cases by A14;
          suppose
            n0+i=n1;
            hence f1.i=s.intpos (n0+a) by A2,A4,A7,A10,A12
              .=f.i by A1,A3,A10,A12;
          end;
          suppose
            n0+i=n2;
            hence f1.i=s.intpos (n0+a) by A2,A4,A7,A10,A12
              .=f.i by A1,A3,A10,A12;
          end;
        end;
      end;
    end;
    hence thesis by A3,A4,FINSEQ_2:9;
  end;
  suppose
A15: n1 >= n0+1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & s1.intpos n1=
    s.intpos n2 & s1.intpos n2=s.intpos n1;
    then
A16: n1-n0 >= 1 by XREAL_1:19;
    then reconsider m1=n1-n0 as Element of NAT by INT_1:3;
A17: m1 <= len f by A3,A15,XREAL_1:20;
A18: n2-n0 >= 1 by A15,XREAL_1:19;
    then reconsider m2=n2-n0 as Element of NAT by INT_1:3;
A19: m2 <= len f1 by A4,A15,XREAL_1:20;
A20: n2=m2+n0;
A21: n1=m1+n0;
    then
A22: f.m1=s1.intpos n2 by A1,A15,A16,A17
      .=f1.m2 by A2,A18,A19,A20;
A23: now
      let k be Nat;
      assume that
A24:  k <> m1 and
A25:  k <> m2 and
A26:  1 <= k and
A27:  k <= len f;
A28:  k+n0 <> m1+n0 by A24;
A29:  n0+1 <= n0+k by A26,XREAL_1:6;
A30:  k+n0 <> m2+n0 by A25;
      thus f.k=s.intpos(k+n0) by A1,A26,A27
        .=s1.intpos (k+n0) by A5,A28,A30,A29
        .=f1.k by A2,A3,A4,A26,A27;
    end;
A31: m2 <= len f by A3,A15,XREAL_1:20;
    then f.m2=s1.intpos n1 by A1,A15,A18,A20
      .=f1.m1 by A2,A3,A4,A16,A17,A21;
    hence thesis by A3,A4,A16,A18,A17,A31,A22,A23,SCPISORT:3;
  end;
end;

Lm24: for s,s1 be State of SCMPDS,n0,n1,n2 be Nat,c1,c2 be Integer
st (for i be Nat st i >= n0 & i <>n1 & i<> n2 holds s1.intpos i=s.
intpos i) & n1 <= n2 & (s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or
c1 <= n1 & n2 <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1)
holds for i be Nat st i >= n0 & (i < c1 or i > c2) holds s1.intpos i
=s.intpos i

proof
  let s,s1 be State of SCMPDS,n0,n1,n2 be Nat,c1,c2 be Integer;
  assume

A1: for i be Nat st i >= n0 & i<>n1 & i<>n2 holds s1.intpos i
  =s.intpos i;
  assume
A2: n1 <= n2;
  assume
A3: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2 or c1 <= n1 & n2
  <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.intpos n1;
  per cases by A3;
  suppose
A4: s1.intpos n1=s.intpos n1 & s1.intpos n2=s.intpos n2;
    hereby
      let i be Nat;
      assume that
A5:   i >= n0 and
      i < c1 or i > c2;
      per cases;
      suppose
        i<>n1 & i<>n2;
        hence s1.intpos i=s.intpos i by A1,A5;
      end;
      suppose
A6:     not (i<>n1 & i<>n2);
        hereby
          per cases by A6;
          suppose
            i=n1;
            hence s1.intpos i=s.intpos i by A4;
          end;
          suppose
            i=n2;
            hence s1.intpos i=s.intpos i by A4;
          end;
        end;
      end;
    end;
  end;
  suppose
A7: c1 <= n1 & n2 <= c2 & s1.intpos n1=s.intpos n2 & s1.intpos n2=s.
    intpos n1;
    hereby
      let i be Nat;
      assume that
A8:   i >= n0 and
A9:   i < c1 or i > c2;
      per cases by A9;
      suppose
        i < c1;
        then i < n1 by A7,XXREAL_0:2;
        hence s1.intpos i=s.intpos i by A1,A2,A8;
      end;
      suppose
        i > c2;
        then i > n2 by A7,XXREAL_0:2;
        hence s1.intpos i=s.intpos i by A1,A2,A8;
      end;
    end;
  end;
end;

Lm25: for s be 0-started State of SCMPDS,
  md,m3,n0 be Nat,f,f1 be FinSequence
of INT st s.GBP=0 & s.a5 > 0 & s.a4=m3+s.a5 & m3=s.a3-1 & s.a2=md & md >= n0+1
& md <= m3 & n0+1 <= s.a3 & s.a4 <= n0+n & f is_FinSequence_on s,n0 & f1
is_FinSequence_on IExec(WH3,P,s),n0 & n0 >= 7 &
len f=n & len f1=n holds
 IExec(WH3,P,s).GBP=0 & IExec(WH3,P,s).a1=s.a1 &
 IExec(WH3,P,s).a2=md &
 IExec(WH3,P,s).a4 >= md &
 IExec(WH3,P,s).a4 <= s.a4 &
 f,f1 are_fiberwise_equipotent &
 (for i be Nat st s.a3<=i & i <= IExec(WH3,P,s).a4
   holds IExec(WH3,P,s).intpos md >=
   IExec(WH3,P,s).intpos i) &
 (for i be Nat st IExec(WH3,P,s).a4 < i & i <= s.a4
   holds IExec(WH3,P,s).intpos md <=
   IExec(WH3,P,s).intpos i) &
 for i be Nat st i >= n0+1 & (i < s.a3 or i > s.a4)
   holds IExec(WH3,P,s).intpos i = s.intpos i
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,
      md,m3,n0 be Nat, f,f1 be FinSequence of INT;
  assume that
A1: s.a=0 and
A2: s.a5 > 0 and
A3: s.a4=m3+s.a5 and
A4: m3=s.a3-1 and
A5: s.a2=md and
A6: md >= n0+1 and
A7: md <= m3 and
A8: n0+1 <= s.a3 and
A9: s.a4 <= n0+n;
  defpred P[Nat] means
   for t be 0-started State of SCMPDS,Q
   for n3 be Nat, g,g1 be FinSequence of INT
     st t.a=0 & t.a5 > 0 & t.a5<= $1+1 & t.a4=n3+t.
  a5 & n3=t.a3-1 & t.a2=md & md <= n3 & n0+1 <= t.a3 & t.a4 <= n0+n & g
  is_FinSequence_on t,n0 & g1 is_FinSequence_on IExec(WH3,Q,t),n0
   & len g=n
   & len g1=n holds
    IExec(WH3,Q,t).a=0 & IExec(WH3,Q,t).a1=t.a1
 & IExec(WH3,Q,t).a2=md & IExec
(WH3,Q,t).a4 >= md & IExec(WH3,Q,t).a4 <= t.a4
 & g,g1 are_fiberwise_equipotent & (
  for i be Nat st t.a3<=i & i <= IExec(WH3,Q,t).a4
   holds IExec(WH3,Q,t).intpos md
    >= IExec(WH3,Q,t).intpos i)
 & (for i be Nat st IExec(WH3,Q,t).
  a4 < i & i <= t.a4
   holds IExec(WH3,Q,t).intpos md <=
   IExec(WH3,Q,t).intpos i) &
   (for i be Nat st i >= n0+1 & (i < t.a3 or i > t.a4)
 holds IExec(WH3,Q,t).intpos i = t.intpos i);
  assume
A10: f is_FinSequence_on s,n0;
  assume
A11: f1 is_FinSequence_on IExec(WH3,P,s),n0;
  assume that
A12: n0 >= 7 and
A13: len f=n and
A14: len f1=n;
  n0+1 >= 7+1 by A12,XREAL_1:6;
  then
A15: md >= 8 by A6,XXREAL_0:2;
A16: now
    let k be Nat;
    assume
A17: P[k];
    now
      let t be 0-started State of SCMPDS,
          n3 be Nat, g,g1 be FinSequence of INT;
      let Q;
      assume that
A18:  t.a=0 and
A19:  t.a5 > 0 and
A20:  t.a5<= (k+1)+1 and
A21:  t.a4=n3+t.a5 and
A22:  n3=t.a3-1 and
A23:  t.a2=md and
A24:  md <= n3 and
A25:  n0+1 <= t.a3 and
A26:  t.a4 <= n0+n;
      set t1=IExec(WB3,Q,t), Q1 = Q;
A27: t1.a=(Initialize t1).a by SCMPDS_5:15;
A28: t1.a1=(Initialize t1).a1 by SCMPDS_5:15;
A29: t1.a2=(Initialize t1).a2 by SCMPDS_5:15;
A30: t1.a3=(Initialize t1).a3 by SCMPDS_5:15;
A31: t1.a4=(Initialize t1).a4 by SCMPDS_5:15;
A32: t1.a5=(Initialize t1).a5 by SCMPDS_5:15;
A33:  t1.a4=t1.a3-1+t1.a5 by A15,A18,A19,A21,A22,A23,A24,Lm19;
A34:  now
A35:    DataLoc(t.a,5)=intpos(0+5) by A18,SCMP_GCD:1;
        let v be 0-started State of SCMPDS;
        let V;
        assume that
A36:    v.a4=v.a3-1+v.a5 and
A37:    md <= v.a3-1 and
A38:    v.a2=t.a2 and
A39:    v.a=t.a and
A40:    v.DataLoc(t.a,5) > 0;
        reconsider mm=v.a3-1 as Element of NAT by A37,INT_1:3;
        set Iv=IExec(WB3,V,v);
A41:    v.a4=mm+v.a5 by A36;
        hence Iv.a=v.a
         by A15,A18,A23,A37,A38,A39,A40,A35,Lm19;
        thus WB3 is_closed_on v,V & WB3 is_halting_on v,V
           by A15,A18,A23,A37,A38,A39,A40,A35,A41,Lm19;

        thus Iv.DataLoc(t.a,5) < v.DataLoc(t.a,5) by A15,A18,A23,A37,A38,A39
,A40,A35,A41,Lm19;
        thus Iv.a4=Iv.a3-1+Iv.a5 by A15,A18,A23,A37,A38,A39,A40,A35,A41,Lm19;
        Iv.a3 >= v.a3 by A15,A18,A23,A37,A38,A39,A40,A35,A41,Lm19;
        then Iv.a3-1 >= v.a3-1 by XREAL_1:9;
        hence md <= Iv.a3-1 by A37,XXREAL_0:2;
        thus Iv.a2=v.a2 by A15,A18,A23,A37,A38,A39,A40,A35,A41,Lm19;
      end;
      t1.a5 < t.a5 by A15,A18,A19,A21,A22,A23,A24,Lm19;
      then t1.a5+1 <= t.a5 by INT_1:7;
      then t1.a5+1 <= (k+1)+1 by A20,XXREAL_0:2;
      then
A42:  t1.a5 <= k+1 by XREAL_1:6;
      set t2=IExec(WH3,Q,t);
      assume
A43:  g is_FinSequence_on t,n0;
      assume
A44:  g1 is_FinSequence_on IExec(WH3,Q,t),n0;
A45:  t1.a=0 by A15,A18,A19,A21,A22,A23,A24,Lm19;
      then
A46:  DataLoc(t1.a,5)=intpos(0+5) by SCMP_GCD:1;
      assume that
A47:  len g=n and
A48:  len g1=n;
A49:  t1.a2=md by A15,A18,A19,A21,A22,A23,A24,Lm19;
A50:  t1.a1=t.a1 by A15,A18,A19,A21,A22,A23,A24,Lm19;
A51:  t1.a3 >= t.a3 by A15,A18,A19,A21,A22,A23,A24,Lm19;
A52:  t1.a4 >= n3 by A15,A18,A19,A21,A22,A23,A24,Lm19;
A53:  DataLoc(t.a,5)=intpos(0+5) by A18,SCMP_GCD:1;
A54:  t1.a4 <= t.a4 by A15,A18,A19,A21,A22,A23,A24,Lm19;
      consider n1,n2 be Nat such that
A55:  n1=t1.a3-1 and
A56:  n2=t1.a4+1 and
A57:  for i be Nat st i >= 8 & i <>n1 & i<> n2 holds t1.
      intpos i=t.intpos i and
A58:  t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or t.a3 <=
      n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1 and
A59:  for i be Nat st t.a3<=i & i <= n1 holds t1.intpos
      md >= t1.intpos i and
A60:  for i be Nat st n2<=i & i <= t.a4 holds t1.intpos
      md <= t1.intpos i by A15,A18,A19,A21,A22,A23,A24,Lm19;

A61:  t1.a5 >= -1 by A15,A18,A19,A21,A22,A23,A24,Lm19;
      then
A62:  n1 <= n2 by A33,A55,A56,Lm22;
      per cases;
      suppose
A63:    t1.a5 > 0;
        set t3=IExec(WH3,Q1,Initialize t1);
        consider f3 be FinSequence of INT such that
A64:    len f3=n and
A65:    for i be Nat st 1<=i & i <= len f3 holds f3.i=t1.
        intpos (n0+i) by SCPISORT:1;
A66:    f3 is_FinSequence_on t1,n0 by A65;
A67:    f3 is_FinSequence_on Initialize t1,n0
        proof let i be Nat;
         assume 1 <= i & i <= len f3;
          then f3.i=t1.intpos(n0+i) by A65;
         hence f3.i=(Initialize t1).intpos(n0+i) by SCMPDS_5:15;
        end;
A68:    t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or n1 >= n0+
1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t1.intpos n1=t.intpos n2 & t1.intpos
        n2=t.intpos n1
        proof
          per cases by A58;
          suppose
            t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose
A69:        t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
            intpos n2=t.intpos n1;
            then
A70:        n2 <= n0+n by A26,XXREAL_0:2;
            n1 >= n0+1 by A25,A69,XXREAL_0:2;
            hence thesis by A62,A69,A70,XXREAL_0:2;
          end;
        end;
A71:    n0+1 <= t1.a3 by A25,A51,XXREAL_0:2;
        t1.a3-1 >= t.a3-1 by A51,XREAL_1:9;
        then
A72:    md <= n1 by A22,A24,A55,XXREAL_0:2;
        now
          let i be Nat;
          assume that
A73:      i >= n0+1 and
A74:      i<>n1 and
A75:      i<>n2;
          n0+1 >= 7+1 by A12,XREAL_1:6;
          hence t1.intpos i=t.intpos i by A57,A73,A74,A75,XXREAL_0:2;
        end;
        then
A76:    g,f3 are_fiberwise_equipotent by A43,A47,A64,A66,A68,Lm23;
A77:    t1.a4 <= n0+n by A26,A54,XXREAL_0:2;
A78:    t2 =t3 by A19,A21,A22,A24,A53,A34,Th7;
        consider f4 be FinSequence of INT such that
A79:    len f4=n and
A80:    for i be Nat st 1<=i & i <= len f4 holds f4.i=t3.
        intpos (n0+i) by SCPISORT:1;
A81:    f4 is_FinSequence_on t3,n0
         by A80;
        thus t2.a=0 by A17,A33,A42,A45,A49,A55,A63,A64,A67,A78,A79,A81,A72,A71
,A77,A27,A29,A30,A31,A32;
A82:
(md < t1.a3 or md > t1.a4)
  implies t2.intpos md
   = (Initialize t1).intpos md by A6,A17,A33,A42,A45,A49,A55,A63,A64,A67,A71
,A72,A77,A78,A79,A81,A27,A29,A30,A31,A32;

A83:   md < t1.a3 by A55,A72,XREAL_1:146,XXREAL_0:2;
A84:    dom f4 = Seg n by A79,FINSEQ_1:def 3;
        now
          let i be Nat;
          reconsider a = i as Nat;
          assume
A85:      i in dom f4;
          then
A86:      i <= n by A84,FINSEQ_1:1;
A87:      1 <= i by A84,A85,FINSEQ_1:1;
          hence f4.i=t2.intpos (n0+a) by A79,A80,A78,A86
            .=g1.i by A44,A48,A87,A86;
        end;
        then
A88:    f4=g1 by A48,A79,FINSEQ_2:9;

        thus t2.a1=t.a1 by A17,A45,A50,A49,A33,A55,A42,A63,A64,A67,A79,A81,A72
,A71,A77,A78,A27,A28,A29,A30,A31,A32;

        thus t2.a2=md by A17,A45,A49,A33,A55,A42,A63,A64,A67,A79,A81,A72,A71
,A77,A78,A27,A29,A30,A31,A32;

        thus t2.a4 >= md by A17,A45,A49,A33,A55,A42,A63,A64,A67,A79,A81,A72,A71
,A77,A78,A27,A29,A30,A31,A32;

        t3.a4 <= t1.a4 by A17,A45,A49,A33,A55,A42,A63,A64,A67,A79,A81,A72,A71
,A77,A27,A29,A30,A31,A32;

        hence t2.a4 <= t.a4 by A54,A78,XXREAL_0:2;

        f3,f4 are_fiberwise_equipotent by A17,A45,A49,A33,A55,A42,A63,A64,A67
,A79,A81,A72,A71,A77,A27,A29,A30,A31,A32;

        hence g,g1 are_fiberwise_equipotent by A76,A88,CLASSES1:76;
A89:    t1.a3=n1+1 by A55;
        hereby
          let i be Nat;
          assume that
A90:      t.a3<=i and
A91:      i <= t2.a4;
A92:     t1.intpos i = (Initialize t1).intpos i by SCMPDS_5:15;
A93:      n0+1 <= i by A25,A90,XXREAL_0:2;
          hereby
            per cases;
            suppose
A94:          i < t1.a3;
              then
A95:          i <= n1 by A89,INT_1:7;

A96:       t2.intpos i = t1.intpos i by A17,A45,A49,A33,A55,A42,A63,A64,A67
,A79,A81,A72,A71,A77,A78,A93,A94,A92,A27,A29,A30,A31,A32;
         t2.intpos md = t1.intpos md by A83,A82,SCMPDS_5:15;
              hence t2.intpos md >= t2.intpos i by A59,A90,A95,A96;
            end;
            suppose
A97:           i >= t1.a3;

              thus
              t2.intpos md >= t2.intpos i by A17,A45,A49,A33,A55,A42,A63,A64
,A67,A79,A81,A72,A71,A77,A78,A91,A97,A27,A29,A30,A31,A32;

            end;
          end;
        end;
        hereby
          let i be Nat;
          assume that
A98:      t2.a4 < i and
A99:      i <= t.a4;
A100:     t1.intpos i = (Initialize t1).intpos i by SCMPDS_5:15;
          hereby
            per cases;
            suppose
A101:          i > t1.a4;
              then
A102:          i >= n2 by A56,INT_1:7;
              t1.a4 > n1+0 by A33,A55,A63,XREAL_1:6;
              then n2 > n1+1 by A56,XREAL_1:6;
              then n2 >= n0+1 by A55,A71,XXREAL_0:2;
              then i >= n0+1 by A102,XXREAL_0:2;

              then
A103:           t2.intpos i = t1.intpos i
         by A17,A45,A49,A33,A55,A42,A63,A64,A67,A79,A81,A72,A71,A77,A78,A101
,A27,A29,A30,A31,A32,A100;
           t2.intpos md = t1.intpos md by A83,A82,SCMPDS_5:15;
              hence t2.intpos md <= t2.intpos i by A60,A99,A102,A103;
            end;
            suppose
A104:         i <= t1.a4;
              thus
              t2.intpos md <= t2.intpos i
        by A17,A45,A49,A33,A55,A42,A63,A64,A67,A79,A81,A72,A71,A77,A78,A98
,A104,A27,A29,A30,A31,A32;
            end;
          end;
        end;
        hereby
          let i be Nat;
A105:     t1.intpos i = (Initialize t1).intpos i by SCMPDS_5:15;
          assume that
A106:      i >= n0+1 and
A107:      i < t.a3 or i > t.a4;
          n0+1 >= 7+1 by A12,XREAL_1:6;
          then
A108:         i >= 8 by A106,XXREAL_0:2;
          then
A109:      t1.intpos i = t.intpos i by A57,A58,A62,A107,Lm24;
          per cases by A107;
          suppose
            i < t.a3;
            then i < t1.a3 by A51,XXREAL_0:2;

            hence
            t2.intpos i = t1.intpos i
         by A17,A45,A49,A33,A55,A42,A63,A64,A67,A79,A81,A72,A71,A77,A78,A106
,A27,A29,A30,A31,A32,A105
            .= t.intpos i by A57,A58,A62,A107,Lm24,A108;

          end;
          suppose
            i > t.a4;
            then i > t1.a4 by A54,XXREAL_0:2;
            hence
            t2.intpos i = t.intpos i by A109,A17,A45,A49,A33,A55,A42,A63,A64,
             A67,A79,A81,A72,A71,A77,A78,A106,A27,A29,A30,A31,A32,A105;
          end;
        end;
      end;
      suppose
A110:    t1.a5 <= 0;
A111:    now
          let x;
A112: (Initialize t1).GBP = t1.GBP by SCMPDS_5:15;
A113: (Initialize t1).DataLoc(t1.GBP,5) = t1.DataLoc(t1.GBP,5) by SCMPDS_5:15;
          thus t2.x =IExec(WH3,Q1,Initialize t1).x
          by A19,A21,A22,A24,A53,A34,Th7
            .=(Initialize t1).x by A46,A110,A112,A113,SCMPDS_8:23
            .=t1.x by SCMPDS_5:15;
        end;
        hence t2.a=0 by A45;
        thus t2.a1=t.a1 by A50,A111;
        thus t2.a2=md by A49,A111;
        t2.a4 >= n3 by A52,A111;
        hence t2.a4 >= md by A24,XXREAL_0:2;
        thus t2.a4 <= t.a4 by A54,A111;
A114:    now
A115:      n0+1 >= 7+1 by A12,XREAL_1:6;
          let i be Nat;
          assume that
A116:      i >= n0+1 and
A117:      i<>n1 and
A118:     i<>n2;
          thus t2.intpos i=t1.intpos i by A111
            .=t.intpos i by A57,A116,A117,A118,A115,XXREAL_0:2;
        end;

A119:   t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or t.a3 <=
        n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1

        proof
          per cases by A58;
          suppose
            t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
            hence thesis by A111;
          end;
          suppose

            t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
            intpos n2=t.intpos n1;

            hence thesis by A111;
          end;
        end;

        t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or n1 >= n0+

1 & n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t2.intpos n1=t.intpos n2 & t2.intpos
        n2=t.intpos n1

        proof
          per cases by A119;
          suppose
            t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2;
            hence thesis;
          end;
          suppose
A120:       t.a3 <= n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.
            intpos n2=t.intpos n1;
            then
A121:       n2 <= n0+n by A26,XXREAL_0:2;
            n1 >= n0+1 by A25,A120,XXREAL_0:2;
            hence thesis by A62,A120,A121,XXREAL_0:2;
          end;
        end;
        hence g,g1 are_fiberwise_equipotent by A43,A44,A47,A48,A114,Lm23;
A122:   t2.a4=n2-1 by A56,A111;
        hereby
          let i be Nat;
          assume that
A123:     t.a3 <= i and
A124:     i <= t2.a4;
          i < n2 by A122,A124,XREAL_1:146,XXREAL_0:2;
          then i <= n1 by A61,A33,A55,A56,A110,Lm21;
          then t1.intpos md >= t1.intpos i by A59,A123;
          then t2.intpos md >= t1.intpos i by A111;
          hence t2.intpos md >= t2.intpos i by A111;
        end;
        hereby
          let i be Nat;
          assume that
A125:     t2.a4 < i and
A126:     i <= t.a4;
          t2.a4+1=n2 by A56,A111;
          then n2 <= i by A125,INT_1:7;
          then t1.intpos md <= t1.intpos i by A60,A126;
          then t2.intpos md <= t1.intpos i by A111;
          hence t2.intpos md <= t2.intpos i by A111;
        end;
        thus for i be Nat st i >= n0+1 & (i < t.a3 or i > t.a4)
        holds t2.intpos i = t.intpos i by A62,A114,A119,Lm24;
      end;
    end;
    hence P[k+1];
  end;
  s.a5 >=1+0 by A2,INT_1:7;
  then reconsider m5=s.a5-1 as Element of NAT by INT_1:3,XREAL_1:48;
A127: s.a5=m5+1;
A128: P[0 qua Nat]
  proof
    let t be 0-started State of SCMPDS, Q;
    let n3 be Nat,g,g1 be FinSequence of INT;
    assume that
A129: t.a=0 and
A130: t.a5 > 0 and
A131: t.a5<= 0+1 and
A132: t.a4=n3+t.a5 and
A133: n3=t.a3-1 and
A134: t.a2=md and
A135: md <= n3 and
A136: n0+1 <= t.a3 and
A137: t.a4 <= n0+n;
    set t2=IExec(WH3,Q,t), Q2 = Q;
    assume
A138: g is_FinSequence_on t,n0;
    set t1=IExec(WB3,Q,t), Q1 = Q;
    assume
A139: g1 is_FinSequence_on IExec(WH3,Q,t),n0;
A140: t1.a4=t1.a3-1+t1.a5 by A15,A129,A130,A132,A133,A134,A135,Lm19;
    consider n1,n2 be Nat such that
A141: n1=t1.a3-1 and
A142: n2=t1.a4+1 and
A143: for i be Nat st i >= 8 & i <>n1 & i<> n2 holds t1.
    intpos i=t.intpos i and
A144: t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2 or t.a3 <= n1
    & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.intpos n2=t.intpos n1 and
A145: for i be Nat st t.a3<=i & i <= n1 holds t1.intpos md
    >= t1.intpos i and
A146: for i be Nat st n2<=i & i <= t.a4 holds t1.intpos md
    <= t1.intpos i by A15,A129,A130,A132,A133,A134,A135,Lm19;
A147: t1.a5 >= -1 by A15,A129,A130,A132,A133,A134,A135,Lm19;
    then
A148: n1 <= n2 by A140,A141,A142,Lm22;
    t1.a5 < t.a5 by A15,A129,A130,A132,A133,A134,A135,Lm19;
    then t1.a5+1 <= t.a5 by INT_1:7;
    then t1.a5+1 <= 0+1 by A131,XXREAL_0:2;
    then
A149: t1.a5 <= 0 by XREAL_1:6;
A150: now
A151: DataLoc(t.a,5)=intpos(0+5) by A129,SCMP_GCD:1;
      let v be 0-started State of SCMPDS;
      let V;
      assume that
A152: v.a4=v.a3-1+v.a5 and
A153: md <= v.a3-1 and
A154: v.a2=t.a2 and
A155: v.a=t.a and
A156: v.DataLoc(t.a,5) > 0;
      reconsider mm=v.a3-1 as Element of NAT by A153,INT_1:3;
      set Iv=IExec(WB3,V,v);
A157: v.a4=mm+v.a5 by A152;
      hence Iv.a=v.a by A15,A129,A134,A153,A154,A155,A156,A151,Lm19;
      thus WB3 is_closed_on v,V & WB3 is_halting_on v,V
        by A15,A129,A134,A153,A154,A155,A156,A151,A157,Lm19;
      thus Iv.DataLoc(t.a,5) < v.DataLoc(t.a,5) by A15,A129,A134,A153,A154,A155
,A156,A151,A157,Lm19;
      thus Iv.a4=Iv.a3-1+Iv.a5 by A15,A129,A134,A153,A154,A155,A156,A151,A157
,Lm19;
      Iv.a3 >= v.a3 by A15,A129,A134,A153,A154,A155,A156,A151,A157,Lm19;
      then Iv.a3-1 >= v.a3-1 by XREAL_1:9;
      hence md <= Iv.a3-1 by A153,XXREAL_0:2;
      thus Iv.a2=v.a2 by A15,A129,A134,A153,A154,A155,A156,A151,A157,Lm19;
    end;
A158: DataLoc(t.a,5)=intpos(0+5) by A129,SCMP_GCD:1;
    assume that
A159: len g=n and
A160: len g1=n;
A161: t1.a=0 by A15,A129,A130,A132,A133,A134,A135,Lm19;
    then
A162: DataLoc(t1.a,5)=intpos(0+5) by SCMP_GCD:1;
A163: now
A164: (Initialize t1).GBP = t1.GBP by SCMPDS_5:15;
A165: (Initialize t1).DataLoc(t1.GBP,5) = t1.DataLoc(t1.GBP,5) by SCMPDS_5:15;
      let x;
      thus t2.x =IExec(WH3,Q1,Initialize t1).x
       by A130,A132,A133,A135,A158,A150,Th7
        .=(Initialize t1).x by A162,A149,A164,A165,SCMPDS_8:23
        .=t1.x by SCMPDS_5:15;
    end;
    hence t2.a=0 by A161;
    t1.a1=t.a1 by A15,A129,A130,A132,A133,A134,A135,Lm19;
    hence t2.a1=t.a1 by A163;
    t1.a2=md by A15,A129,A130,A132,A133,A134,A135,Lm19;
    hence t2.a2=md by A163;
    t1.a4 >= n3 by A15,A129,A130,A132,A133,A134,A135,Lm19;
    then t2.a4 >= n3 by A163;
    hence t2.a4 >= md by A135,XXREAL_0:2;
    t1.a4 <= t.a4 by A15,A129,A130,A132,A133,A134,A135,Lm19;
    hence t2.a4 <= t.a4 by A163;
A166: now
A167: n0+1 >= 7+1 by A12,XREAL_1:6;
      let i be Nat;
      assume that
A168: i >= n0+1 and
A169: i<>n1 and
A170: i<>n2;
      thus t2.intpos i=t1.intpos i by A163
        .=t.intpos i by A143,A168,A169,A170,A167,XXREAL_0:2;
    end;

A171: t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or t.a3 <= n1 &
    n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.intpos n2=t.intpos n1

    proof
      per cases by A144;
      suppose
        t1.intpos n1=t.intpos n1 & t1.intpos n2=t.intpos n2;
        hence thesis by A163;
      end;
      suppose
        t.a3 <= n1 & n2 <= t.a4 & t1.intpos n1=t.intpos n2 & t1.
        intpos n2=t.intpos n1;
        hence thesis by A163;
      end;
    end;
    t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2 or n1 >= n0+1 &
n2 >= n0+1 & n1 <= n0+n & n2 <= n0+n & t2.intpos n1=t.intpos n2 & t2.intpos n2=
    t.intpos n1
    proof
      per cases by A171;
      suppose
        t2.intpos n1=t.intpos n1 & t2.intpos n2=t.intpos n2;
        hence thesis;
      end;
      suppose
A172:   t.a3 <= n1 & n2 <= t.a4 & t2.intpos n1=t.intpos n2 & t2.
        intpos n2=t.intpos n1;
        then
A173:   n2 <= n0+n by A137,XXREAL_0:2;
        n1 >= n0+1 by A136,A172,XXREAL_0:2;
        hence thesis by A148,A172,A173,XXREAL_0:2;
      end;
    end;
    hence g,g1 are_fiberwise_equipotent by A138,A139,A159,A160,A166,Lm23;
A174: t2.a4=n2-1 by A142,A163;
    hereby
      let i be Nat;
      assume that
A175: t.a3 <= i and
A176: i <= t2.a4;
      i < n2 by A174,A176,XREAL_1:146,XXREAL_0:2;
      then i <= n1 by A147,A140,A141,A142,A149,Lm21;
      then t1.intpos md >= t1.intpos i by A145,A175;
      then t2.intpos md >= t1.intpos i by A163;
      hence t2.intpos md >= t2.intpos i by A163;
    end;
    hereby
      let i be Nat;
      assume that
A177: t2.a4 < i and
A178: i <= t.a4;
      t2.a4+1=n2 by A142,A163;
      then n2 <= i by A177,INT_1:7;
      then t1.intpos md <= t1.intpos i by A146,A178;
      then t2.intpos md <= t1.intpos i by A163;
      hence t2.intpos md <= t2.intpos i by A163;
    end;
    thus thesis by A166,A148,A171,Lm24;
  end;
  for k be Nat holds P[k] from NAT_1:sch 2(A128,A16);
  hence thesis by A1,A3,A4,A5,A7,A8,A9,A10,A11,A13,A14,A127;
end;

Lm26: for s be 0-started State of SCMPDS,
   md,m3,n0 be Nat st s.GBP=0 & s.a4=m3
+s.a5 & m3=s.a3-1 & s.a2=md & md >= n0+1 & md <= m3 & n0 >= 7 holds WH3
is_closed_on s,P & WH3 is_halting_on s,P
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,md,m3,n0 be Nat;
  assume that
A1: s.a=0 and
A2: s.a4=m3+s.a5 and
A3: m3=s.a3-1 and
A4: s.a2=md and
A5: md >= n0+1 and
A6: md <= m3 and
A7: n0 >= 7;
  n0+1 >= 7+1 by A7,XREAL_1:6;
  then
A8: md >= 8 by A5,XXREAL_0:2;
A9: DataLoc(s.a,5)=intpos(0+5) by A1,SCMP_GCD:1;
  now
    let v be 0-started State of SCMPDS;
    let V;
    assume that
A10: v.a4=v.a3-1+v.a5 and
A11: md <= v.a3-1 and
A12: v.a2=s.a2 and
A13: v.a=s.a and
A14: v.DataLoc(s.a,5) > 0;
    set Iv=IExec(WB3,V,v);
    reconsider mm=v.a3-1 as Element of NAT by A11,INT_1:3;
A15: v.a4=mm+v.a5 by A10;
    hence Iv.a=v.a by A1,A4,A8,A9,A11,A12,A13,A14,Lm19;
    thus WB3 is_closed_on v,V & WB3 is_halting_on v,V
     by A1,A4,A8,A9,A11,A12,A13,A14,A15,Lm19;

    thus Iv.DataLoc(s.a,5) < v.DataLoc(s.a,5) by A1,A4,A8,A9,A11,A12,A13,A14
,A15,Lm19;

    thus Iv.a4=Iv.a3-1+Iv.a5 by A1,A4,A8,A9,A11,A12,A13,A14,A15,Lm19;
    Iv.a3 >= v.a3 by A1,A4,A8,A9,A11,A12,A13,A14,A15,Lm19;
    then Iv.a3-1 >= v.a3-1 by XREAL_1:9;
    hence md <= Iv.a3-1 by A11,XXREAL_0:2;
    thus Iv.a2=v.a2 by A1,A4,A8,A9,A11,A12,A13,A14,A15,Lm19;
  end;
  hence thesis by A2,A3,A6,Th7;
end;

Lm27: for s being 0-started State of SCMPDS
 st s.GBP=0 holds IExec(K4,P,Initialize s).GBP=0 &
 IExec(K4,P,Initialize s).a1=s.a1
  & IExec(K4,P,Initialize s).a2=s.a2 & IExec(K4,P,Initialize s).a3=s.a2+1 &
  IExec(K4,P,Initialize s).a4=s.
a4 & IExec(K4,P,Initialize s).a5=s.a4-s.a2
 & for i be Nat st i >= 8
 holds IExec(K4,P,Initialize s).intpos i=s.intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS;

  set t0=Initialize s, t1=IExec(k1 ';' k2 ';' k3 ';' k4,P,Initialize s),
  t2=IExec(k1 ';'k2 ';' k3,P,Initialize s),
  t3=IExec(k1 ';' k2,P,Initialize s), t4=Exec(k1, t0);

  assume s.a=0;
  then
A1: t0.a=0 by SCMPDS_5:15;
  then
A2: DataLoc(t0.a,5)=intpos (0+5) by SCMP_GCD:1;
  then
A3: t4.a5=t0.DataLoc(t0.a,4) by SCMPDS_2:47
    .=t0.intpos (0+4) by A1,SCMP_GCD:1
    .=s.a4 by SCMPDS_5:15;
  t0.a4=s.a4 by SCMPDS_5:15;
  then
A4: t4.a4 =s.a4 by A2,AMI_3:10,SCMPDS_2:47;
  t0.a1=s.a1 by SCMPDS_5:15;
  then
A5: t4.a1 =s.a1 by A2,AMI_3:10,SCMPDS_2:47;
A6: t4.a =0 by A1,A2,AMI_3:10,SCMPDS_2:47;
  then
A7: DataLoc(t4.a,5)=intpos (0+5) by SCMP_GCD:1;
A8: t3.a=Exec(k2, t4).a by SCMPDS_5:42
    .=0 by A6,A7,AMI_3:10,SCMPDS_2:50;
  then
A9: DataLoc(t3.a,3)=intpos (0+3) by SCMP_GCD:1;
A10: t3.a4=Exec(k2, t4).a4 by SCMPDS_5:42
    .=s.a4 by A4,A7,AMI_3:10,SCMPDS_2:50;
A11: t2.a4 =Exec(k3, t3).a4 by SCMPDS_5:41
    .=s.a4 by A10,A9,AMI_3:10,SCMPDS_2:47;
A12: t0.a2=s.a2 by SCMPDS_5:15;
  then
A13: t4.a2 =s.a2 by A2,AMI_3:10,SCMPDS_2:47;
A14: t3.a5=Exec(k2, t4).a5 by SCMPDS_5:42
    .=t4.a5-t4.DataLoc(t4.a,2) by A7,SCMPDS_2:50
    .=t4.a5-t4.intpos(0+2) by A6,SCMP_GCD:1
    .=s.a4-s.a2 by A12,A2,A3,AMI_3:10,SCMPDS_2:47;
A15: t2.a5 =Exec(k3, t3).a5 by SCMPDS_5:41
    .=s.a4-s.a2 by A14,A9,AMI_3:10,SCMPDS_2:47;
A16: t3.a2=Exec(k2, t4).a2 by SCMPDS_5:42
    .=s.a2 by A13,A7,AMI_3:10,SCMPDS_2:50;
A17: t3.a1=Exec(k2, t4).a1 by SCMPDS_5:42
    .=s.a1 by A5,A7,AMI_3:10,SCMPDS_2:50;
A18: t2.a1 =Exec(k3, t3).a1 by SCMPDS_5:41
    .=s.a1 by A17,A9,AMI_3:10,SCMPDS_2:47;
A19: t2.a =Exec(k3, t3).a by SCMPDS_5:41
    .=0 by A8,A9,AMI_3:10,SCMPDS_2:47;
  then
A20: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:1;
A21: t2.a3 =Exec(k3, t3).a3 by SCMPDS_5:41
    .=t3.DataLoc(t3.a,2) by A9,SCMPDS_2:47
    .=s.a2 by A8,A16,SCMP_GCD:1;
A22: t2.a2 =Exec(k3, t3).a2 by SCMPDS_5:41
    .=s.a2 by A16,A9,AMI_3:10,SCMPDS_2:47;
  thus t1.a =Exec(k4, t2).a by SCMPDS_5:41
    .=0 by A19,A20,AMI_3:10,SCMPDS_2:48;
  thus t1.a1 =Exec(k4, t2).a1 by SCMPDS_5:41
    .=s.a1 by A18,A20,AMI_3:10,SCMPDS_2:48;
  thus t1.a2 =Exec(k4, t2).a2 by SCMPDS_5:41
    .=s.a2 by A22,A20,AMI_3:10,SCMPDS_2:48;
  thus t1.a3 =Exec(k4, t2).a3 by SCMPDS_5:41
    .=s.a2+1 by A21,A20,SCMPDS_2:48;
  thus t1.a4 =Exec(k4, t2).a4 by SCMPDS_5:41
    .=s.a4 by A11,A20,AMI_3:10,SCMPDS_2:48;
  thus t1.a5 =Exec(k4, t2).a5 by SCMPDS_5:41
    .=s.a4-s.a2 by A15,A20,AMI_3:10,SCMPDS_2:48;
A23: now
    let i be Nat;
    assume i>=8;
    then i > 5 by XXREAL_0:2;
    hence t4.intpos i=t0.intpos i by A2,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by SCMPDS_5:15;
  end;
A24: now
    let i be Nat;
    assume
A25: i>=8;
    then
A26: i > 5 by XXREAL_0:2;
    thus t3.intpos i=Exec(k2, t4).intpos i by SCMPDS_5:42
      .=t4.intpos i by A7,A26,AMI_3:10,SCMPDS_2:50
      .=s.intpos i by A23,A25;
  end;
A27: now
    let i be Nat;
    assume
A28: i>=8;
    then
A29: i > 3 by XXREAL_0:2;
    thus t2.intpos i=Exec(k3, t3).intpos i by SCMPDS_5:41
      .=t3.intpos i by A9,A29,AMI_3:10,SCMPDS_2:47
      .=s.intpos i by A24,A28;
  end;
  hereby
    let i be Nat;
    assume
A30: i>=8;
    then
A31: i > 3 by XXREAL_0:2;
    thus t1.intpos i=Exec(k4, t2).intpos i by SCMPDS_5:41
      .=t2.intpos i by A20,A31,AMI_3:10,SCMPDS_2:48
      .=s.intpos i by A27,A30;
  end;
end;

theorem Th10:
  for s be 0-started State of SCMPDS,
  md,p0 be Nat st s.GBP=0 & s.
  intpos 2=md & md >= p0+1 & p0 >= 7 holds Partition is_closed_on s,P
   & Partition
  is_halting_on s,P
proof
  set KW=K4 ';' WH3;
  let s be 0-started State of SCMPDS,md,n0 be Nat;
  set s2=IExec(K4,P,Initialize s), a=GBP, P2 = P;
  assume that
A1: s.a=0 and
A2: s.a2=md and
A3: md >= n0+1 and
A4: n0 >= 7;
A5: s2.a2=s.a2 by A1,Lm27;
  set m3=md;
  s2.a5=s.a4-s.a2 by A1,Lm27;
  then
A6: s2.a4=m3+s2.a5 by A1,A2,Lm27;
  s2.a3=s.a2+1 by A1,Lm27;
  then
A7: s.a2=s2.a3-1;
A8: s2.a=0 by A1,Lm27;

A9: (Initialize s2).GBP = s2.GBP by SCMPDS_5:15;
A10: (Initialize s2).a2 = s2.a2 by SCMPDS_5:15;
A11: (Initialize s2).a3 = s2.a3 by SCMPDS_5:15;
A12: (Initialize s2).a4 = s2.a4 by SCMPDS_5:15;
A13: (Initialize s2).a5 = s2.a5 by SCMPDS_5:15;
A14: WH3 is_halting_on Initialize s2,P2 by A2,A3,A4,A5,A7,A6,Lm26,A8,A9,A10,A11
,A12
,A13;
A15: WH3 is_halting_on s2,P2
     proof
       P+*stop WH3 halts_on Initialize Initialize s2 by A14,SCMPDS_6:def 3;
      hence thesis by SCMPDS_6:def 3;
     end;
A16: WH3 is_closed_on Initialize s2,P2 by A2,A3,A4,A8,A5,A7,A6,Lm26,A9,A10,A11,
A12
,A13;
A17: WH3 is_closed_on s2,P2
      proof
  for k being Nat holds
   IC Comput(P+*stop WH3,Initialize Initialize s2,k) in dom stop WH3
                   by A16,SCMPDS_6:def 2;
       hence thesis by SCMPDS_6:def 2;
      end;
  then
A18: KW is_closed_on s,P by A15,SCPISORT:9;
A19: KW is_halting_on s,P by A17,A15,SCPISORT:9;
  then
A20: KW ';' j8 is_closed_on s,P by A18,SCPISORT:10;
A21: KW ';' j8 is_halting_on s,P by A18,A19,SCPISORT:10;
  then
A22: KW ';' j8 ';' j9 is_halting_on s,P by A20,SCPISORT:10;
  KW ';' j8 ';' j9 is_closed_on s,P by A20,A21,SCPISORT:10;
  hence thesis by A22,SCPISORT:10;
end;

theorem Th11:
  for s be 0-started State of SCMPDS,
  md,p0,n be Nat,f,f1 be
FinSequence of INT st s.GBP=0 & s.intpos 4-s.intpos 2 > 0 & s.intpos 2=md & md
  >= p0+1 & s.intpos 4 <= p0+n & p0 >= 7 & f is_FinSequence_on s,p0 & len f=n &
f1 is_FinSequence_on IExec(Partition,P,s),p0 & len f1=n holds
IExec(Partition,P,s).GBP=0 &
IExec(Partition,P,s).intpos 1=s.intpos 1 &
 f,f1 are_fiberwise_equipotent
& ex m4 be Nat
   st m4=IExec(Partition,P,s).intpos 4 &
      md <= m4 & m4 <= s.intpos 4 &
  (for i be Nat st md<=i & i < m4
    holds IExec(Partition,P,s).intpos m4 >=
    IExec(Partition,P,s).intpos i) &
  (for i be Nat st m4 < i & i <= s.intpos 4
    holds IExec(Partition,P,s).intpos m4 <=
    IExec(Partition,P,s).intpos i) &
  for i be Nat st i >= p0+1 & (i < s.intpos 2 or i > s.
    intpos 4) holds IExec(Partition,P,s).intpos i = s.intpos i
proof
  set KW=K4 ';' WH3;
  let s be 0-started State of SCMPDS,
      md,n0,n be Nat, f,f1 be FinSequence of INT;
A1: Initialize s = s by MEMSTR_0:44;
  set s1=IExec(Partition,P,s), s2=IExec(K4,P,s), P2 = P,
  s3=IExec(K4 ';' WH3,P,s), a=GBP;
A2: s2.a=(Initialize s2).a by SCMPDS_5:15;
A3: s2.a1=(Initialize s2).a1 by SCMPDS_5:15;
A4: s2.a2=(Initialize s2).a2 by SCMPDS_5:15;
A5: s2.a3=(Initialize s2).a3 by SCMPDS_5:15;
A6: s2.a4=(Initialize s2).a4 by SCMPDS_5:15;
A7: s2.a5=(Initialize s2).a5 by SCMPDS_5:15;
  assume that
A8: s.a=0 and
A9: s.a4-s.a2 > 0 and
A10: s.a2=md and
A11: md >= n0+1 and
A12: s.a4 <= n0+n and
A13: n0 >= 7;
A14: s2.GBP=0 by A8,Lm27,A1;
A15: s2.a1=s.a1 by A8,Lm27,A1;
A16: n0+1 >= 7+1 by A13,XREAL_1:6;
  then
A17: md >= 8 by A11,XXREAL_0:2;
  then
A18: md > 1 by XXREAL_0:2;
A19: md > 4 by A17,XXREAL_0:2;
A20: md-n0 >= 1 by A11,XREAL_1:19;
  then reconsider n1=md-n0 as Element of NAT by INT_1:3;
A21: md=n0+n1;
A22: s2.a4=s.a4 by A8,Lm27,A1;
  set m3=md;
  s2.a5=s.a4-s.a2 by A8,Lm27,A1;
  then
A23: s2.a4=m3+s2.a5 by A8,A10,Lm27,A1;
  set s4=IExec(WH3,P2,Initialize s2);
  consider f3 be FinSequence of INT such that
A24: len f3=n and
A25: for i be Nat st 1<=i & i <= len f3 holds f3.i=s4.intpos(
  n0+i) by SCPISORT:1;
A26: f3 is_FinSequence_on s4,n0 by A25;
  md < s.a4 by A9,A10,XREAL_1:47;
  then md < n0+n by A12,XXREAL_0:2;
  then
A27: n1 <= len f3 by A24,XREAL_1:20;
A28: s2.a2=s.a2 by A8,Lm27,A1;
A29: s2.a3=s.a2+1 by A8,Lm27,A1;
  then
A30: s.a2=s2.a3-1;


A31: (Initialize s2).GBP = s2.GBP by SCMPDS_5:15;
A32: (Initialize s2).a2 = s2.a2 by SCMPDS_5:15;
A33: (Initialize s2).a3 = s2.a3 by SCMPDS_5:15;
A34: (Initialize s2).a4 = s2.a4 by SCMPDS_5:15;
A35: (Initialize s2).a5 = s2.a5 by SCMPDS_5:15;
A36: WH3 is_halting_on Initialize s2,P2 by A10,A11,A13,A14,A28,A23,Lm26,A30,A31
,A32,A33,A34,A35;
A37: WH3 is_halting_on s2,P2
   proof
      P+*stop WH3 halts_on Initialize Initialize s2 by A36,SCMPDS_6:def 3;
    hence thesis by SCMPDS_6:def 3;
   end;
  s.a2 < s2.a3 by A29,XREAL_1:29;
  then
A38: n0+1 <= s2.a3 by A10,A11,XXREAL_0:2;
A39: WH3 is_closed_on Initialize s2,P2 by A10,A11,A13,A14,A28,A30,A23,Lm26,A31,
A32
,A33,A34,A35;
A40: WH3 is_closed_on s2,P2
    proof
     for k being Nat holds
     IC Comput(P+*stop WH3,Initialize Initialize s2,k) in dom stop WH3
                by A39,SCMPDS_6:def 2;
     hence thesis by SCMPDS_6:def 2;
    end;
  then
A41: KW is_halting_on s,P by A37,A1,SCPISORT:9;
  consider f2 be FinSequence of INT such that
A42: len f2=n and
A43: for i be Nat st 1<=i & i <= len f2 holds f2.i=s2.intpos(
  n0+i) by SCPISORT:1;
A44: f2 is_FinSequence_on Initialize s2,n0
   proof let i be Nat;
    assume 1 <= i & i <= len f2;
    then f2.i=s2.intpos(n0+i) by A43;
    hence thesis by SCMPDS_5:15;
   end;
  then
A45: f2,f3 are_fiberwise_equipotent by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23
,A38,A42,A24,A26,Lm25,A2,A4,A5,A6,A7;

  s4.a4 > 0 by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38,A42,A44,A24,A26,Lm25
,A2,A4,A5,A6,A7;
  then reconsider m4=s4.a4 as Element of NAT by INT_1:3;
A46: s4.a4 >= md by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38,A42,A44,A24,A26
,Lm25,A2,A4,A5,A6,A7;
  then
A47: m4-n0 >= md-n0 by XREAL_1:9;
  then reconsider n2=m4-n0 as Element of NAT by A20,INT_1:3;
A48: m4-n0 >= 1 by A20,A47,XXREAL_0:2;
  s4.a2=md by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38,A42,A44,A24,A26,Lm25,
A2
,A4,A5,A6,A7;
  then
A49: s3.a2=md by A40,A37,SCPISORT:7;
A50: s3.a4 =m4 by A40,A37,SCPISORT:7;
  s4.a=0 by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38,A42,A44,A24,A26,Lm25,A2
,A4,A5,A6,A7;
  then
A51: s3.a=0 by A40,A37,SCPISORT:7;
  then
A52: DataLoc(s3.a,6)=intpos(0+6) by SCMP_GCD:1;
  set t2=IExec(KW ';' j8 ';' j9,P,s),
      t3=IExec(KW ';' j8,P,s);
  assume that
A53: f is_FinSequence_on s,n0 and
A54: len f=n;
  assume that
A55: f1 is_FinSequence_on s1,n0 and
A56: len f1=n;
A57: dom f2 = Seg n by A42,FINSEQ_1:def 3;
A58: now
    let i be Nat;
    reconsider a = i as Nat;
    assume
A59: i in dom f2;
    then
A60: 1 <= i by A57,FINSEQ_1:1;
    then i+n0 >= n0+1 by XREAL_1:6;
    then
A61: n0+i >= 8 by A16,XXREAL_0:2;
A62: i <= n by A57,A59,FINSEQ_1:1;
    hence f2.i=s2.intpos (n0+a) by A42,A43,A60
      .=s.intpos (n0+a) by A8,A61,Lm27,A1
      .=f.i by A53,A54,A60,A62;
  end;
A63: KW is_closed_on s,P by A40,A37,A1,SCPISORT:9;
  then
A64: KW ';' j8 is_closed_on s,P by A41,SCPISORT:10;
A65: s4.a4 <= s2.a4 by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38,A42,A44,A24
,A26,Lm25,A2,A4,A5,A6,A7;
  then m4 <= n0+n by A12,A22,XXREAL_0:2;
  then
A66: n2 <= len f3 by A24,XREAL_1:20;
A67: t3.a6=Exec(j8,s3).a6 by A63,A41,SCMPDS_7:31
    .=s3.DataLoc(s3.a4,0) by A52,SCMPDS_2:47
    .=s3.intpos(m4+0) by A50,SCMP_GCD:1
    .=s4.intpos m4 by A40,A37,SCPISORT:7;
A68: t3.a4=Exec(j8,s3).a4 by A63,A41,SCMPDS_7:31
    .=m4 by A50,A52,AMI_3:10,SCMPDS_2:47;
  then
A69: DataLoc(t3.a4,0)=intpos(m4+0) by SCMP_GCD:1;
A70: s4.a1=s2.a1 by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38,A42,A44,A24,A26
,Lm25,A2,A3,A4,A5,A6,A7;
A71: t3.a1=Exec(j8,s3).a1 by A63,A41,SCMPDS_7:31
    .=s3.a1 by A52,AMI_3:10,SCMPDS_2:47
    .=s.a1 by A15,A70,A40,A37,SCPISORT:7;
A72: s4.a4 >= 8 by A46,A17,XXREAL_0:2;
  then
A73: m4 > 2 by XXREAL_0:2;
A74: t3.a=Exec(j8,s3).a by A63,A41,SCMPDS_7:31
    .=0 by A51,A52,AMI_3:10,SCMPDS_2:47;
A75: t3.a2=Exec(j8,s3).a2 by A63,A41,SCMPDS_7:31
    .=md by A49,A52,AMI_3:10,SCMPDS_2:47;
A76: KW ';' j8 is_halting_on s,P by A63,A41,SCPISORT:10;
  then
A77: KW ';' j8 ';' j9 is_halting_on s,P by A64,SCPISORT:10;
  t2.a2=Exec(j9,t3).a2 by A64,A76,SCMPDS_7:31
    .=md by A75,A69,A73,AMI_3:10,SCMPDS_2:47;
  then
A78: DataLoc(t2.a2,0)=intpos(md+0) by SCMP_GCD:1;
A79: m4 > 6 by A72,XXREAL_0:2;
A80: m4 > 1 by A72,XXREAL_0:2;
A81: t2.a6=Exec(j9,t3).a6 by A64,A76,SCMPDS_7:31
    .=s4.intpos m4 by A67,A69,A79,AMI_3:10,SCMPDS_2:47;
A82: t2.a=Exec(j9,t3).a by A64,A76,SCMPDS_7:31
    .=0 by A11,A46,A74,A69,AMI_3:10,SCMPDS_2:47;
A83: KW ';' j8 ';' j9 is_closed_on s,P by A64,A76,SCPISORT:10;
  then
A84: s1.intpos md=Exec(j0,t2).intpos md by A77,SCMPDS_7:31
    .=t2.DataLoc(t2.a,6) by A78,SCMPDS_2:47
    .=s4.intpos m4 by A82,A81,SCMP_GCD:1;
A85: now
    let i be Nat;
    assume i >= 8;
    then
A86: i > 6 by XXREAL_0:2;
    thus t3.intpos i =Exec(j8,s3).intpos i by A63,A41,SCMPDS_7:31
      .=s3.intpos i by A52,A86,AMI_3:10,SCMPDS_2:47
      .=s4.intpos i by A40,A37,SCPISORT:7;
  end;
A87: now
    let i be Nat;
    assume that
A88: i >= 8 and
A89: i <> m4;
    thus t2.intpos i =Exec(j9,t3).intpos i by A64,A76,SCMPDS_7:31
      .=t3.intpos i by A69,A89,AMI_3:10,SCMPDS_2:47
      .=s4.intpos i by A85,A88;
  end;
A90: now
    let i be Nat;
    assume that
A91: i >= 8 and
A92: i <> m4 and
A93: i<>md;
    thus s1.intpos i =Exec(j0,t2).intpos i by A83,A77,SCMPDS_7:31
      .=t2.intpos i by A78,A93,AMI_3:10,SCMPDS_2:47
      .=s4.intpos i by A87,A91,A92;
  end;
A94: now
    let k be Nat;
    assume that
A95: k<>n1 and
A96: k<>n2 and
A97: 1<=k and
A98: k <= len f3;
A99: k+n0<>md by A95;
A100: k+n0 >= n0+1 by A97,XREAL_1:6;
A101: k+n0<>m4 by A96;
    thus f3.k=s4.intpos(n0+k) by A25,A97,A98
      .=s1.intpos(n0+k) by A16,A90,A99,A101,A100,XXREAL_0:2
      .=f1.k by A55,A56,A24,A97,A98;
  end;
A102: m4=n0+n2;
  then
A103: f3.n2=s1.intpos md by A25,A84,A48,A66
    .=f1.n1 by A55,A56,A24,A20,A27,A21;
A104: t2.a1=Exec(j9,t3).a1 by A64,A76,SCMPDS_7:31
    .=s.a1 by A71,A69,A80,AMI_3:10,SCMPDS_2:47;
  thus s1.a=Exec(j0,t2).a by A83,A77,SCMPDS_7:31
    .=0 by A11,A82,A78,AMI_3:10,SCMPDS_2:47;
  thus s1.a1=Exec(j0,t2).a1 by A83,A77,SCMPDS_7:31
    .=s.a1 by A104,A78,A18,AMI_3:10,SCMPDS_2:47;
A105: m4 > 4 by A72,XXREAL_0:2;
A106: t2.a4=Exec(j9,t3).a4 by A64,A76,SCMPDS_7:31
    .=m4 by A68,A69,A105,AMI_3:10,SCMPDS_2:47;
A107: t2.intpos m4=Exec(j9,t3).intpos m4 by A64,A76,SCMPDS_7:31
    .=t3.DataLoc(t3.a2,0) by A69,SCMPDS_2:47
    .=t3.intpos (md+0) by A75,SCMP_GCD:1
    .=s4.intpos md by A11,A16,A85,XXREAL_0:2;
A108: now
    per cases;
    suppose
      m4=md;
      hence s1.intpos m4=s4.intpos md by A84;
    end;
    suppose
A109:  m4<>md;
      thus s1.intpos m4=Exec(j0,t2).intpos m4 by A83,A77,SCMPDS_7:31
        .=s4.intpos md by A107,A78,A109,AMI_3:10,SCMPDS_2:47;
    end;
  end;
  then f3.n1=s1.intpos m4 by A25,A20,A27,A21
    .=f1.n2 by A55,A56,A24,A48,A66,A102;
  then f3,f1 are_fiberwise_equipotent by A56,A24,A20,A27,A48,A66,A103,A94,
SCPISORT:3;
  then f2,f1 are_fiberwise_equipotent by A45,CLASSES1:76;
  hence f,f1 are_fiberwise_equipotent by A54,A42,A58,FINSEQ_2:9;
  take m4;
  thus s1.a4=Exec(j0,t2).a4 by A83,A77,SCMPDS_7:31
    .=m4 by A106,A78,A19,AMI_3:10,SCMPDS_2:47;
A110: m3=s2.a3-1 by A10,A29;
  hence md <= m4 by A9,A10,A11,A12,A13,A14,A28,A22,A23,A38,A42,A44,A24,A26,Lm25
,A2,A4,A5,A6,A7;
  thus m4 <= s.a4 by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38,A42,A44,A24,A26
,Lm25,A2,A4,A5,A6,A7;
A111: s2.a3=md+1 by A8,A10,Lm27,A1;
  hereby
    let i be Nat;
    assume that
A112: md<=i and
A113: i < m4;
    per cases;
    suppose
A114: i=md;
      then s2.a3 <= m4 by A111,A113,INT_1:7;
      hence
      s1.intpos m4 >= s1.intpos i by A114,A84,A9,A10,A11,A12,A13,A14,A28,A22
,A110,A23,A38,A42,A44,A24,A26,A108,Lm25,A2,A4,A5,A6,A7;
    end;
    suppose
A115: i<>md;
      then md < i by A112,XXREAL_0:1;
      then s2.a3 <= i by A10,A29,INT_1:7;
      then s4.intpos md >= s4.intpos i
     by A9,A10,A11,A12,A13,A14,A28,A22,A110,A23,A38,A42,A44,A24,A26,A113,Lm25,
A2
,A4,A5,A6,A7;
      hence s1.intpos m4 >= s1.intpos i by A17,A108,A90,A112,A115,XXREAL_0:2;
    end;
  end;
  hereby
    let i be Nat;
    assume that
A116: m4 < i and
A117: i <= s.a4;
A118: md < i by A46,A116,XXREAL_0:2;
    s4.intpos md <= s4.intpos i by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38
,A42,A44,A24,A26,A116,A117,Lm25,A2,A4,A5,A6,A7;
    hence s1.intpos m4 <= s1.intpos i by A17,A108,A90,A118,XXREAL_0:2;
  end;
  hereby
    let i be Nat;
    assume that
A119: i >= n0+1 and
A120: i < s.a2 or i > s.a4;
A121: i >= 8 by A16,A119,XXREAL_0:2;
A122: now
      per cases by A120;
      case
A123:   i < s.a2;
        s.a2 < s2.a3 by A29,XREAL_1:29;
        hence i < s2.a3 by A123,XXREAL_0:2;
      end;
      case
        i > s.a4;
        hence i > s2.a4 by A8,Lm27,A1;
      end;
    end;
A124: s2.intpos i = (Initialize s2).intpos i by SCMPDS_5:15;
A125:  for i be Nat st i >= n0+1 &
      (i < (Initialize s2).a3 or i > (Initialize s2).a4)
       holds IExec(WH3,P2,Initialize s2).intpos i = (Initialize s2).intpos i
              by A9,A10,A11,A12,A13,A14,A28,A22,A110,A23,A38,A42,A44,A24,A26
,Lm25,A2,A4,A5,A6,A7;
  i<>md & i<>m4
    proof
      per cases by A120;
      suppose
        i< s.a2;
        hence thesis by A9,A10,A11,A12,A13,A14,A28,A22,A30,A23,A38,A42,A44,A24
,A26,Lm25,A2,A4,A5,A6,A7;
      end;
      suppose
        i > s.a4;
        hence thesis by A22,A46,A65,XXREAL_0:2;
      end;
    end;
    hence s1.intpos i = s4.intpos i by A16,A90,A119,XXREAL_0:2

      .=s2.intpos i by A119,A122,A125,A5,A6,A124
      .=s.intpos i by A8,A121,Lm27,A1;
  end;
end;

theorem
  Partition is halt-free shiftable;

Lm28: for s being 0-started State of SCMPDS,
p0,n being Nat holds card QuickSort(n,p0)=57 &
(p0 >= 7 implies QuickSort(n,p0) is_halting_on s,P
 & ex f,g
be FinSequence of INT st len f=n & f is_FinSequence_on s,p0 & len g = n & g
is_FinSequence_on IExec(QuickSort(n,p0),P,s),p0
 & f,g are_fiberwise_equipotent &
g is_non_decreasing_on 1,n)
proof
  set b1=DataLoc(0,1);
  reconsider Pt=Partition as halt-free shiftable Program of SCMPDS;
  let s be 0-started State of SCMPDS,p0,n be Nat;
A1: Initialize s = s by MEMSTR_0:44;
  set pn=p0+n;

  set l1= (GBP,2):=(SBP,pn+1), l2= SubFrom(GBP,2,SBP,pn), l3= (GBP,2):=(SBP,pn

), l4= (GBP,4):=(SBP,pn+1), l5= (SBP,pn+3):=(SBP,pn+1), l6= (SBP,pn+1):=(GBP,4)
  , l7= (SBP,pn+2):=(GBP,4), l8= AddTo(SBP,pn+1,-1), l9= AddTo(SBP,pn+2,1), l0=
  AddTo(GBP,1,2), lb= Load AddTo(GBP,1,-2), L5= l5 ';' l6 ';' l7 ';' l8 ';' l9
';' l0, TR= l3 ';' l4 ';' Pt ';' L5, IF4= if>0(GBP,2,TR,lb),
  WB4= l1 ';' l2 ';' IF4, WH4= while>0(GBP,1,WB4);
  set m1= GBP:=0, m2= SBP:=1, m3= (SBP,pn):=(p0+1), m4= (SBP,pn+1):=pn, M4= m1
  ';' m2 ';' m3 ';' m4;
  set s1=IExec(M4,P,s), a=GBP, P1 = P;
A2: 7+n >= 7 by NAT_1:11;
A3: card L5= card (l5 ';' l6 ';' l7 ';' l8 ';' l9 )+1 by SCMP_GCD:4
    .= card (l5 ';' l6 ';' l7 ';' l8)+1+1 by SCMP_GCD:4
    .= 4+1+1 by Th4;
A4: card WB4=card (l1 ';' l2) + card IF4 by AFINSQ_1:17
    .=2+card IF4 by SCMP_GCD:5
    .=2+(card TR +card lb +2) by SCMPDS_6:65
    .=2+(card TR +1 +2) by COMPOS_1:54
    .=2+(card (l3 ';' l4 ';' Pt)+ card L5+1+2) by AFINSQ_1:17
    .=2+(card (l3 ';' l4) + card Pt + card L5+1+2) by AFINSQ_1:17
    .=2+(2+ 38 + card L5+1+2) by Th9,SCMP_GCD:5
    .=51 by A3;
  thus card QuickSort(n,p0)=card M4 + card WH4 by AFINSQ_1:17
    .=4 + card WH4 by Th4
    .=4 + (51+2) by A4,SCMPDS_8:17
    .=57;
  assume
A5: p0 >= 7;
  then pn >= 7+n by XREAL_1:6;
  then
A6: pn >= 7 by A2,XXREAL_0:2;

A7: for t be State of SCMPDS,Q
   for m1 be Nat st t.a=0 & t.SBP=m1 holds

IExec(l3 ';' l4,Q,Initialize t).a2=t.intpos(m1+pn)
 & IExec(l3 ';' l4,Q,Initialize t).a4=t.intpos(m1+pn+
  1) & for i be Nat st i <> 2 & i <> 4
   holds IExec(l3 ';' l4,Q,Initialize t).intpos i=t.intpos i

  proof
    let t be State of SCMPDS, Q;
    let m1 be Nat;
    set t0=Initialize t, t2=IExec(l3 ';' l4,Q,Initialize t),
    t3=Exec(l3, t0), mp=m1+pn,
    Q0 = Q;
    assume that
A8: t.a=0 and
A9: t.SBP=m1;
A10: t0.a =0 by A8,SCMPDS_5:15;
    then
A11: DataLoc(t0.a,2)=intpos (0+2) by SCMP_GCD:1;
    then t3.a=0 by A10,AMI_3:10,SCMPDS_2:47;
    then
A12: DataLoc(t3.a,4)=intpos (0+4) by SCMP_GCD:1;
A13: t0.SBP =m1 by A9,SCMPDS_5:15;
    then
A14: t3.SBP=m1 by A11,AMI_3:10,SCMPDS_2:47;
    mp >= 0+7 by A6,XREAL_1:7;
    then mp+1 >= 7+1 by XREAL_1:6;
    then mp+1 > 2 by XXREAL_0:2;
    then
A15: t3.intpos(mp+1)=t0.intpos(mp+1) by A11,AMI_3:10,SCMPDS_2:47
      .=t.intpos(mp+1) by SCMPDS_5:15;

A16: t3.a2=t0.DataLoc(t0.SBP,pn) by A11,SCMPDS_2:47
      .=t0.intpos mp by A13,SCMP_GCD:1
      .=t.intpos mp by SCMPDS_5:15;
    thus t2.a2=Exec(l4, t3).a2 by SCMPDS_5:42
      .=t.intpos mp by A16,A12,AMI_3:10,SCMPDS_2:47;
    thus t2.a4=Exec(l4, t3).a4 by SCMPDS_5:42
      .=t3.DataLoc(t3.SBP,pn+1) by A12,SCMPDS_2:47
      .=t.intpos(mp+1) by A14,A15,SCMP_GCD:1;
    hereby
      let i be Nat;
      assume that
A17:  i<>2 and
A18:  i <> 4;
      thus t2.intpos i =Exec(l4, t3).intpos i by SCMPDS_5:42
        .=t3.intpos i by A12,A18,AMI_3:10,SCMPDS_2:47
        .=t0.intpos i by A11,A17,AMI_3:10,SCMPDS_2:47
        .=t.intpos i by SCMPDS_5:15;
    end;
  end;

A19: for t being State of SCMPDS,Q
   for m,m1 be Nat st t.a=0 & t.SBP=m1 &

m1=m+1 holds IExec(L5,Q,Initialize t).a=0 & IExec(L5,Q,Initialize t).SBP=m1+2
 & IExec(L5,Q,Initialize t).intpos (m1+pn

)=t.intpos (m1+pn) & IExec(L5,Q,Initialize t).intpos (m1+pn+1)=t.a4-1
 & IExec(L5,Q,Initialize t).intpos (
  m1+pn+2)=t.a4+1 & IExec(L5,Q,Initialize t).intpos (m1+pn+3)
  =t.intpos (m1+pn+1)
   & for i be
  Nat st i >= 8 & i < m1+pn
     holds IExec(L5,Q,Initialize t).intpos i=t.intpos i

  proof
    let t be State of SCMPDS,Q;
    let m,m1 be Nat;
    assume that
A20: t.a=0 and
A21: t.SBP=m1 and
A22: m1=m+1;

    set t0=Initialize t, t1=IExec(L5,Q,Initialize t), Q0 = Q,
    t2=IExec(l5 ';' l6 ';' l7 ';' l8 ';' l9,Q,Initialize t),
t3=IExec(l5 ';' l6 ';' l7 ';' l8,Q,Initialize t),
t4=IExec(l5 ';' l6 ';' l7, Q,Initialize t),
    t5= IExec(l5 ';' l6,Q,Initialize t), t6=Exec(l5,t0), mp=m1+pn;

A23: mp+3 <> mp+1;
    m1 >= 1 by A22,NAT_1:11;
    then
A24: mp >= 1+7 by A6,XREAL_1:7;
    then
A25: mp+1 >= 8+1 by XREAL_1:6;
    then
A26: mp+1 > 4 by XXREAL_0:2;
A27: mp+1 > 1 by A25,XXREAL_0:2;
A28: mp+0 <> mp+2;
A29: mp > 1 by A24,XXREAL_0:2;
A30: mp+1 <> mp+2;
A31: t0.SBP =m1 by A21,SCMPDS_5:15;
    then
A32: DataLoc(t0.SBP,pn+3)=intpos (mp+3) by SCMP_GCD:1;
A33: now
      let i be Nat;
      assume i<>mp+3;
      hence t6.intpos i=t0.intpos i by A32,AMI_3:10,SCMPDS_2:47
        .=t.intpos i by SCMPDS_5:15;
    end;
    mp+0 <> mp+3;
    then
A34: t6.intpos mp=t.intpos mp by A33;
A35: mp+1 <> mp+2;
A36: mp+3 <> mp+2;
A37: mp+3 >= 8+3 by A24,XREAL_1:6;
    then
A38: mp+3 > 1 by XXREAL_0:2;
    mp+3 > 1 by A37,XXREAL_0:2;
    then
A39: t6.SBP=m1 by A21,A33;
    then
A40: DataLoc(t6.SBP,pn+1)=intpos (mp+1) by SCMP_GCD:1;
A41: now
      let i be Nat;
      assume
A42:  i<>mp+1;
      thus t5.intpos i=Exec(l6, t6).intpos i by SCMPDS_5:42
        .=t6.intpos i by A40,A42,AMI_3:10,SCMPDS_2:47;
    end;
    mp+1 > 1 by A25,XXREAL_0:2;
    then
A43: t5.SBP=m1 by A39,A41;
    then
A44: DataLoc(t5.SBP,pn+2)=intpos (mp+2) by SCMP_GCD:1;
A45: now
      let i be Nat;
      assume
A46:  i<>mp+2;
      thus t4.intpos i=Exec(l7, t5).intpos i by SCMPDS_5:41
        .=t5.intpos i by A44,A46,AMI_3:10,SCMPDS_2:47;
    end;
    t6.intpos (mp+3)=t0.DataLoc(t0.SBP,pn+1) by A32,SCMPDS_2:47
      .=t0.intpos(m1+(pn+1)) by A31,SCMP_GCD:1
      .=t.intpos (mp+1) by SCMPDS_5:15;
    then t5.intpos(mp+3)=t.intpos(mp+1) by A41,A23;
    then
A47: t4.intpos(mp+3)=t.intpos(mp+1) by A45,A36;
A48: mp+3 > 4 by A37,XXREAL_0:2;
    then
A49: t6.a4=t.a4 by A33;
A50: mp+2 >= 8+2 by A24,XREAL_1:6;
    then
A51: mp+2 > 1 by XXREAL_0:2;
    mp+2 > 1 by A50,XXREAL_0:2;
    then
A52: t4.SBP=m1 by A43,A45;
    then
A53: DataLoc(t4.SBP,pn+1)=intpos (mp+1) by SCMP_GCD:1;
A54: now
      let i be Nat;
      assume
A55:  i<>mp+1;
      thus t3.intpos i=Exec(l8, t4).intpos i by SCMPDS_5:41
        .=t4.intpos i by A53,A55,AMI_3:10,SCMPDS_2:48;
    end;
    m1+pn+1 > 1 by A25,XXREAL_0:2;
    then
A56: t3.SBP=m1 by A52,A54;
    then
A57: DataLoc(t3.SBP,pn+2)=intpos (mp+2) by SCMP_GCD:1;
A58: now
      let i be Nat;
      assume
A59:  i<>mp+2;
      thus t2.intpos i=Exec(l9, t3).intpos i by SCMPDS_5:41
        .=t3.intpos i by A57,A59,AMI_3:10,SCMPDS_2:48;
    end;
A60: t6.a=0 by A20,A33;
    then
A61: t5.a=0 by A41;
    then t4.a=0 by A45;
    then t3.a=0 by A54;
    then
A62: t2.a=0 by A58;
    then
A63: DataLoc(t2.a,1)=intpos (0+1) by SCMP_GCD:1;
    mp+2 > 1 by A50,XXREAL_0:2;
    then
A64: t2.SBP=m1 by A56,A58;
A65: now
      let i be Nat;
      assume i<>1;
      then
A66:  intpos i <> DataLoc(t2.a,1) by A62,AMI_3:10,SCMP_GCD:1;
      thus t1.intpos i=Exec(l0, t2).intpos i by SCMPDS_5:41
        .=t2.intpos i by A66,SCMPDS_2:48;
    end;
    hence t1.a=0 by A62;
A67: mp+0 <> mp+2;
    mp+0 <> mp+1;
    then t5.intpos mp=t.intpos mp by A34,A41;
    then
A68: t4.intpos mp=t.intpos mp by A45,A67;
    thus t1.SBP=Exec(l0, t2).SBP by SCMPDS_5:41
      .=m1+2 by A64,A63,SCMPDS_2:48;
    mp+0 <> mp+1;
    then t3.intpos mp=t.intpos mp by A68,A54;
    then t2.intpos mp=t.intpos mp by A58,A28;
    hence t1.intpos mp=t.intpos mp by A65,A29;
A69: mp+1 <> mp+2;
    t4.intpos(mp+2)=Exec(l7, t5).intpos(mp+2) by SCMPDS_5:41
      .=t5.DataLoc(t5.GBP,4) by A44,SCMPDS_2:47
      .=t5.intpos(0+4) by A61,SCMP_GCD:1
      .=t.a4 by A49,A41,A26;
    then
A70: t3.intpos(mp+2)=t.a4 by A54,A30;
    t5.intpos (mp+1)=Exec(l6, t6).intpos(mp+1) by SCMPDS_5:42
      .=t6.DataLoc(t6.GBP,4) by A40,SCMPDS_2:47
      .=t6.intpos(0+4) by A60,SCMP_GCD:1
      .=t.a4 by A33,A48;
    then
A71: t4.intpos (mp+1)=t.a4 by A45,A69;
    t3.intpos(mp+1)=Exec(l8, t4).intpos(mp+1) by SCMPDS_5:41
      .=t.a4+-1 by A71,A53,SCMPDS_2:48
      .=t.a4-1;
    then t2.intpos(mp+1)=t.a4-1 by A58,A35;
    hence t1.intpos(mp+1)=t.a4-1 by A65,A27;
    t2.intpos(mp+2)=Exec(l9, t3).intpos(mp+2) by SCMPDS_5:41
      .=t.a4+1 by A70,A57,SCMPDS_2:48;
    hence t1.intpos(mp+2)=t.a4+1 by A65,A51;
A72: mp+3 <> mp+2;
    mp+3 <> mp+1;
    then t3.intpos(mp+3)=t.intpos(mp+1) by A47,A54;
    then t2.intpos(mp+3)=t.intpos(mp+1) by A58,A72;
    hence t1.intpos(mp+3)=t.intpos(mp+1) by A65,A38;
    hereby
A73:  mp <= mp+3 by NAT_1:11;
A74:  mp <= mp+2 by NAT_1:11;
A75:  mp <= mp+1 by NAT_1:11;
      let i be Nat;
      assume that
A76:  i >= 8 and
A77:  i < mp;
      i > 1 by A76,XXREAL_0:2;
      hence t1.intpos i=t2.intpos i by A65
        .=t3.intpos i by A58,A77,A74
        .=t4.intpos i by A54,A77,A75
        .=t5.intpos i by A45,A77,A74
        .=t6.intpos i by A41,A77,A75
        .=t.intpos i by A33,A77,A73;
    end;
  end;

A78: for t be 0-started State of SCMPDS,Q
    for m,m1,md be Nat,n4 be Integer,
       f1,f2 be FinSequence of INT
        st t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos(m1+pn)=md &
           md >= p0+1 & n4=t.intpos(m1+pn+1) & n4-md > 0 &
           n4 <= pn & f1 is_FinSequence_on t,p0 & len f1=n &
           f2 is_FinSequence_on IExec(TR,Q,t),p0 & len f2=n
 holds IExec(TR,Q,t).a=0 & IExec(TR,Q,t).a1=m1+2 &
    md= IExec(TR,Q,t).intpos(m1+pn)
   & n4=IExec(TR,Q,t).intpos (m1+pn+3)
   & (for j be Nat st 1<=j & j<m1 holds IExec(TR,Q,t).
  intpos(pn+j)=t.intpos(pn+j)) & f1,f2 are_fiberwise_equipotent &
  ex m4 be Nat st md <= m4 & m4 <= n4
 & m4-1=IExec(TR,Q,t).intpos (m1+pn+1) & m4+
  1=IExec(TR,Q,t).intpos (m1+pn+2) &
   (for i be Nat st md<=i & i < m4
     holds IExec(TR,Q,t).intpos m4 >=
       IExec(TR,Q,t).intpos i)
 & (for i be Nat st m4 < i & i <= n4
  holds IExec(TR,Q,t).intpos m4 <=
     IExec(TR,Q,t).intpos i)
 & for j be Nat st p0+1<=j & j<md or n4<j & j <= p0+n
   holds IExec(TR,Q,t).intpos j = t.intpos j
  proof
    let t be 0-started State of SCMPDS, Q;
    let m,m1,md be Nat,n4 be Integer, f1,f2 be
    FinSequence of INT;
A79: Initialize t = t by MEMSTR_0:44;
    set t1=IExec(TR,Q,t), lPt=l3 ';' l4 ';' Pt,
    t2=IExec(lPt,Q,t), Q2 = Q,
    t4=IExec(l3 ';' l4,Q,t), mp=m1+pn, Q4 = Q;
A80: t4.a = (Initialize t4).a by SCMPDS_5:15;
A81: t4.a2 = (Initialize t4).a2 by SCMPDS_5:15;
A82: t4.a4 = (Initialize t4).a4 by SCMPDS_5:15;
A83: t4.a1 = (Initialize t4).a1 by SCMPDS_5:15;
    set tp=IExec(Pt,Q4,Initialize t4);
    assume that
A84: t.a=0 and
A85: t.SBP=m1 and
A86: m1=m+1 and
A87: t.intpos mp=md and
A88: md >= p0+1 and
A89: n4=t.intpos (mp+1) and
A90: n4-md > 0 and
A91: n4 <= pn;
A92: t4.a=0 by A7,A84,A85,A79;
    assume that
A93: f1 is_FinSequence_on t,p0 and
A94: len f1=n;
A95: p0+1 >= 7+1 by A5,XREAL_1:6;
A96:    now
      let i be Nat;
      assume that
A97:  1 <= i and
A98:  i <= len f1;
      p0+i >= p0+1 by A97,XREAL_1:6;
      then
A99:  p0+i >= 8 by A95,XXREAL_0:2;
      then
A100:  p0+i > 2 by XXREAL_0:2;
A101:  p0+i > 4 by A99,XXREAL_0:2;
      thus f1.i=t.intpos(p0+i) by A93,A97,A98
        .=t4.intpos(p0+i) by A7,A84,A85,A100,A101,A79;
    end;
A102: t4.a4=n4 by A7,A84,A85,A89,A79;
A103: t4.a4=t.intpos(mp+1) by A7,A84,A85,A79;
A104: t4.a2=t.intpos mp by A7,A84,A85,A79;
    then Pt is_closed_on Initialize t4,Q4 by A5,A87,A88,A92,Th10,A80,A81;
    then
A105: Pt is_closed_on t4,Q4 by SCMPDS_6:125;
     Pt is_halting_on Initialize t4,Q4 by A5,A87,A88,A104,A92,Th10,A80,A81;
     then
A106: Pt is_halting_on t4,Q4 by SCMPDS_6:126;
    then
A107: lPt is_closed_on t,Q by A105,A79,SCPISORT:9;
    assume that
A108: f2 is_FinSequence_on IExec(TR,Q,t),p0 and
A109: len f2=n;
    consider f4 be FinSequence of INT such that
A110: len f4=n and

A111: for i be Nat st 1<=i & i <= len f4 holds f4.i=tp.
    intpos (p0+i) by SCPISORT:1;

A112: f1 is_FinSequence_on Initialize t4,p0
 proof let i be Nat;
  assume  1 <= i & i <= len f1;
   then f1.i=t4.intpos(p0+i) by A96;
  hence thesis by SCMPDS_5:15;
 end;
A113: f4 is_FinSequence_on tp,p0 by A111;
    then consider m4 be Nat such that
A114: m4=tp.a4 and
A115: md <= m4 and
A116: m4 <= t4.a4 and
A117: for i be Nat st md<=i & i < m4 holds tp.intpos m4 >=
    tp.intpos i and
A118: for i be Nat st m4 < i & i <= t4.a4 holds tp.intpos
    m4 <= tp.intpos i and
A119: for i be Nat st i >= p0+1 & (i < t4.a2 or i > t4.a4)
    holds tp.intpos i = (Initialize t4).intpos i
     by A5,A87,A88,A89,A90,A91,A94,A104,A103,A92,A112,A110,Th11,A80,A81,A82;

    tp.a=0 by A5,A87,A88,A89,A90,A91,A94,A104,A103,A92,A112,A110,A113,Th11,A80
,A81,A82;

    then
A120: t2.a=0 by A105,A106,SCPISORT:7;
A121: lPt is_halting_on t,Q by A105,A106,A79,SCPISORT:9;

    tp.a1=t4.a1 by A5,A87,A88,A89,A90,A91,A94,A104,A103,A92,A112,A110,A113,Th11
,A80,A81,A82,A83;

    then
A122: t2.SBP=t4.a1 by A105,A106,SCPISORT:7
      .=m1 by A7,A84,A85,A79;
    then
A123: IExec(L5,Q2,Initialize t2).intpos mp=t2.intpos mp by A19,A86,A120;

    IExec(L5,Q2,Initialize t2).a=0 by A19,A86,A120,A122;
    hence t1.a=0 by A107,A121,SCPISORT:6;
    IExec(L5,Q2,Initialize t2).SBP=m1+2 by A19,A86,A120,A122;
    hence t1.a1=m1+2 by A107,A121,SCPISORT:6;

A124: IExec(L5,Q2,Initialize t2).intpos (mp+3)=t2.intpos (mp+1)
 by A19,A86,A120,A122;
A125: IExec(L5,Q2,Initialize t2).intpos (mp+2)=t2.a4+1 by A19,A86,A120,A122;
A126: IExec(L5,Q2,Initialize t2).intpos (mp+1)=t2.a4-1 by A19,A86,A120,A122;
A127: 1+pn > pn by XREAL_1:29;
A128: m1 >= 1 by A86,NAT_1:11;
    then mp >= 1+pn by XREAL_1:6;
    then
A129: mp > pn by A127,XXREAL_0:2;
    then
A130: mp > t4.a4 by A91,A102,XXREAL_0:2;
    then
A131: m4 < mp by A116,XXREAL_0:2;
A132: dom f2 = Seg n by A109,FINSEQ_1:def 3;
A133: now
      let i be Nat;
      reconsider a = i as Nat;
      assume
A134: i in dom f2;
      then
A135: 1 <= i by A132,FINSEQ_1:1;
      then p0+i >= p0+1 by XREAL_1:6;
      then
A136: p0+i >= 8 by A95,XXREAL_0:2;
A137: i <= n by A132,A134,FINSEQ_1:1;
      then p0+i <= pn by XREAL_1:6;
      then
A138: p0+i < mp by A129,XXREAL_0:2;
      thus f2.i = t1.intpos(p0+a) by A108,A109,A135,A137
        .=IExec(L5,Q2,Initialize t2).intpos(p0+a) by A107,A121,SCPISORT:6
        .=t2.intpos (p0+a) by A19,A86,A120,A122,A136,A138
        .=tp.intpos (p0+a) by A105,A106,SCPISORT:7
        .=f4.i by A110,A111,A135,A137;
    end;
A139: mp >= 1+7 by A6,A128,XREAL_1:7;
    then
A140: mp > 4 by XXREAL_0:2;
A141: mp+1 > mp by XREAL_1:29;
    then
A142: mp+1 > t4.a4 by A130,XXREAL_0:2;
A143: pn >= p0 by NAT_1:11;
    then
A144: mp >= p0+1 by A128,XREAL_1:7;
    then
A145: mp+1 >= p0+1 by A141,XXREAL_0:2;
A146: mp+1 >= 8+1 by A139,XREAL_1:6;
    then
A147: mp+1 > 4 by XXREAL_0:2;
A148: t4.intpos mp = (Initialize t4).intpos mp by SCMPDS_5:15;
A149: t4.intpos (mp+1) = (Initialize t4).intpos (mp+1) by SCMPDS_5:15;
    mp > 2 by A139,XXREAL_0:2;
    hence md=t4.intpos mp by A7,A84,A85,A87,A140,A79
      .=tp.intpos mp by A119,A144,A130,A148
      .=IExec(L5,Q2,Initialize t2).intpos mp by A105,A106,A123,SCPISORT:7
      .=t1.intpos mp by A107,A121,SCPISORT:6;
    mp+1 > 2 by A146,XXREAL_0:2;
    hence n4=t4.intpos (mp+1) by A7,A84,A85,A89,A147,A79
      .=tp.intpos (mp+1) by A119,A145,A142,A149
      .=IExec(L5,Q2,Initialize t2).intpos (mp+3) by A105,A106,A124,SCPISORT:7
      .=t1.intpos (mp+3) by A107,A121,SCPISORT:6;
    hereby
      let j be Nat;
      assume that
A150: 1<=j and
A151: j<m1;
A152: pn+j < mp by A151,XREAL_1:6;
      pn+j >= pn+1 by A150,XREAL_1:6;
      then pn+j > pn by A127,XXREAL_0:2;
      then
A153: pn+j > t4.a4 by A91,A102,XXREAL_0:2;
A154: pn+j >= p0+1 by A143,A150,XREAL_1:7;
A155: pn+j >= 1+7 by A6,A150,XREAL_1:7;
      then
A156: pn+j > 2 by XXREAL_0:2;
A157: pn+j > 4 by A155,XXREAL_0:2;
A158: t4.intpos (pn+j) = (Initialize t4).intpos (pn+j) by SCMPDS_5:15;
      thus t1.intpos(pn+j)=IExec(L5,Q2,Initialize t2).intpos(pn+j)
       by A107,A121,SCPISORT:6
        .=t2.intpos (pn+j) by A19,A86,A120,A122,A155,A152
        .=tp.intpos (pn+j) by A105,A106,SCPISORT:7
        .=t4.intpos (pn+j) by A119,A154,A153,A158
        .=t.intpos(pn+j) by A7,A84,A85,A156,A157,A79;
    end;

    f1,f4 are_fiberwise_equipotent by A5,A87,A88,A89,A90,A91,A94,A104,A103,A92
,A112,A110,A113,Th11,A80,A81,A82;

    hence f1,f2 are_fiberwise_equipotent by A109,A110,A133,FINSEQ_2:9;
    take m4;
    thus md <= m4 & m4 <= n4 by A7,A84,A85,A89,A115,A116,A79;
    thus m4-1=t2.a4-1 by A114,A105,A106,SCPISORT:7
      .=t1.intpos (mp+1) by A107,A121,A126,SCPISORT:6;
    thus m4+1=t2.a4+1 by A114,A105,A106,SCPISORT:7
      .=t1.intpos (mp+2) by A107,A121,A125,SCPISORT:6;
A159: md >= 8 by A88,A95,XXREAL_0:2;
    then
A160: m4 >= 8 by A115,XXREAL_0:2;
    hereby
A161: tp.intpos m4=t2.intpos m4 by A105,A106,SCPISORT:7
        .=IExec(L5,Q2,Initialize t2).intpos m4 by A19,A86,A120,A122,A131,A160
        .=t1.intpos m4 by A107,A121,SCPISORT:6;
      let i be Nat;
      assume that
A162: md<=i and
A163: i < m4;
A164: i < mp by A131,A163,XXREAL_0:2;
A165: i >= 8 by A159,A162,XXREAL_0:2;
      tp.intpos i=t2.intpos i by A105,A106,SCPISORT:7
        .=IExec(L5,Q2,Initialize t2).intpos i by A19,A86,A120,A122,A164,A165
        .=t1.intpos i by A107,A121,SCPISORT:6;
      hence t1.intpos m4 >= t1.intpos i by A117,A162,A163,A161;
    end;
    hereby
A166: tp.intpos m4=t2.intpos m4 by A105,A106,SCPISORT:7
        .=IExec(L5,Q2,Initialize t2).intpos m4 by A19,A86,A120,A122,A131,A160
        .=t1.intpos m4 by A107,A121,SCPISORT:6;
      let i be Nat;
      assume that
A167: m4 < i and
A168: i <= n4;
A169: i < mp by A89,A103,A130,A168,XXREAL_0:2;
      i >= md by A115,A167,XXREAL_0:2;
      then
A170: i >= 8 by A159,XXREAL_0:2;
      tp.intpos i=t2.intpos i by A105,A106,SCPISORT:7
        .=IExec(L5,Q2,Initialize t2).intpos i by A19,A86,A120,A122,A169,A170
        .=t1.intpos i by A107,A121,SCPISORT:6;
      hence t1.intpos m4 <= t1.intpos i by A102,A118,A167,A168,A166;
    end;
    hereby
      let j be Nat;
      assume that
A171: p0+1<=j & j<md or n4<j & j <= pn;
A172: now
        per cases by A171;
        suppose
A173:     p0+1<=j & j<md;

          hence j >= p0+1 & (j < t4.a2 or j > t4.a4) by A7,A84,A85,A87,A79;

          md < mp by A115,A131,XXREAL_0:2;
          hence j < mp by A173,XXREAL_0:2;
        end;
        suppose
A174:     n4<j & j <= pn;
          n4 >= md by A102,A115,A116,XXREAL_0:2;
          then j >= md by A174,XXREAL_0:2;
          hence j >= p0+1 by A88,XXREAL_0:2;
          thus j < t4.a2 or j > t4.a4 by A7,A84,A85,A89,A174,A79;
          thus j < mp by A129,A174,XXREAL_0:2;
        end;
      end;
      then
A175: j >= 8 by A95,XXREAL_0:2;
      then
A176: j > 2 by XXREAL_0:2;
A177: j > 4 by A175,XXREAL_0:2;
A178: t4.intpos j = (Initialize t4).intpos j by SCMPDS_5:15;
      thus t1.intpos j=IExec(L5,Q2,Initialize t2).intpos j
       by A107,A121,SCPISORT:6
        .=t2.intpos j by A19,A86,A120,A122,A172,A175
        .=tp.intpos j by A105,A106,SCPISORT:7
        .=t4.intpos j by A119,A172,A178
        .=t.intpos j by A7,A84,A85,A176,A177,A79;
    end;
  end;

A179: for t be State of SCMPDS,Q
  for m be Nat st t.a=0 & t.SBP=m holds
  IExec(l1 ';' l2,Q,Initialize t).a2=t.intpos (m+pn+1)-t.intpos (m+pn)
   & for i be Nat st i <> 2
 holds IExec(l1 ';' l2,Q,Initialize t).intpos i=t.intpos i

  proof
    let t be State of SCMPDS,Q;
    let m be Nat;
    assume that
A180: t.a=0 and
A181: t.SBP=m;
    set t0=Initialize t,
     t1=IExec(l1 ';' l2, Q,Initialize t), t2=Exec(l1, t0), mp=m+pn;

A182: t0.a =0 by A180,SCMPDS_5:15;
    then
A183: DataLoc(t0.a,2)=intpos (0+2) by SCMP_GCD:1;
    then t2.a=0 by A182,AMI_3:10,SCMPDS_2:47;
    then
A184: DataLoc(t2.a,2)=intpos (0+2) by SCMP_GCD:1;
A185: t0.SBP =m by A181,SCMPDS_5:15;
    then
A186: t2.SBP=m by A183,AMI_3:10,SCMPDS_2:47;
    mp >= 0+7 by A6,XREAL_1:7;
    then mp > 2 by XXREAL_0:2;
    then
A187: t2.intpos mp=t0.intpos mp by A183,AMI_3:10,SCMPDS_2:47
      .=t.intpos mp by SCMPDS_5:15;
A188: t2.a2=t0.DataLoc(t0.SBP,pn+1) by A183,SCMPDS_2:47
      .=t0.intpos (m+(pn+1)) by A185,SCMP_GCD:1
      .=t.intpos (mp+1) by SCMPDS_5:15;
    thus t1.a2 =Exec(l2, t2).a2 by SCMPDS_5:42
      .=t2.a2-t2.DataLoc(t2.SBP,pn) by A184,SCMPDS_2:50
      .=t.intpos (mp+1)-t.intpos mp by A186,A188,A187,SCMP_GCD:1;
    hereby
      let i be Nat;
      assume
A189: i <> 2;
      thus t1.intpos i=Exec(l2, t2).intpos i by SCMPDS_5:42
        .=t2.intpos i by A184,A189,AMI_3:10,SCMPDS_2:50
        .=t0.intpos i by A183,A189,AMI_3:10,SCMPDS_2:47
        .=t.intpos i by SCMPDS_5:15;
    end;
  end;
A190: pn+1 >= 7+1 by A6,XREAL_1:6;

A191: for t be 0-started State of SCMPDS,Q
   for m be Nat st t.a=0 & t.SBP=m & t.
intpos (m+pn+1) <= t.intpos (m+pn) holds IExec(WB4,Q,t).a=0
 & IExec(WB4,Q,t).a1=m-2
  & (for j be Nat st 1<=j & j<m
  holds IExec(WB4,Q,t).intpos(pn+j)=t.
  intpos(pn+j)) & for j be Nat st 1<=j & j <= n
   holds IExec(WB4,Q,t).
  intpos (p0+j) = t.intpos (p0+j)
  proof
    let t be 0-started State of SCMPDS,Q;
    let m be Nat;
    set mp=m+pn, t1=IExec(l1 ';' l2,Q,t), Q1 = Q;
A192: Initialize t = t by MEMSTR_0:44;
    assume that
A193: t.a=0 and
A194: t.SBP=m and
A195: t.intpos (mp+1) <= t.intpos mp;
A196: t1.a1=m by A179,A193,A194,A192;
A197: t1.a2=t.intpos (mp+1)-t.intpos mp by A179,A193,A194,A192;
    then
A198: t1.a2 <= 0 by A195,XREAL_1:47;
    set li=AddTo(GBP,1,-2), t0=Initialize t1;
A199: lb is_halting_on t1,Q1 by SCMPDS_6:21;
A200: t1.a=0 by A179,A193,A194,A192;
    then
A201: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:1;
A202: t0.a=0 by A200,SCMPDS_5:15;
    then
A203: DataLoc(t0.a,1)=intpos (0+1) by SCMP_GCD:1;
A204: lb is_closed_on t1,Q1 by SCMPDS_6:20;
    then
A205: IF4 is_halting_on t1,Q1 by A201,A198,A199,SCMPDS_6:69;
A206: IF4 is_closed_on t1,Q1 by A201,A198,A204,A199,SCMPDS_6:69;
A207: now
      let x;
A208: (Initialize t1).GBP = t1.GBP by SCMPDS_5:15;
A209: (Initialize t1).DataLoc(t1.GBP,2) = t1.DataLoc(t1.GBP,2) by SCMPDS_5:15;
      thus IExec(WB4,Q,t).x = IExec(IF4,Q1,Initialize t1).x
                by A206,A205,SCPISORT:7
        .=IExec(lb,Q1,Initialize t1).x
         by A195,A197,A201,A208,A209,SCMPDS_6:74,XREAL_1:47
        .=Exec(li,t0).x by SCMPDS_5:40;
    end;
A210: now
      let i be Nat;
      assume i <> 1;
      then
A211: intpos i <> DataLoc(t0.a,1) by A202,AMI_3:10,SCMP_GCD:1;
      thus IExec(WB4,Q,t).intpos i=Exec(li,t0).intpos i by A207
        .=t0.intpos i by A211,SCMPDS_2:48
        .=t1.intpos i by SCMPDS_5:15;
    end;
    hence IExec(WB4,Q,t).a=0 by A200;
    thus IExec(WB4,Q,t).a1=Exec(li,t0).a1 by A207
      .=t0.a1+-2 by A203,SCMPDS_2:48
      .=t0.a1-2
      .=m-2 by A196,SCMPDS_5:15;
    hereby
      let j be Nat;
      assume that
A212: 1<=j and
      j<m;
      pn+j >= pn+1 by A212,XREAL_1:6;
      then
A213: pn+j >= 8 by A190,XXREAL_0:2;
      then
A214: pn+j > 2 by XXREAL_0:2;
      pn+j > 1 by A213,XXREAL_0:2;
      hence IExec(WB4,Q,t).intpos(pn+j)=t1.intpos(pn+j) by A210
        .=t.intpos(pn+j) by A179,A193,A194,A214,A192;
    end;
    hereby
      let j be Nat;
      assume that
A215: 1<=j and
      j<=n;
A216: p0+1 >= 7+1 by A5,XREAL_1:6;
      p0+j >= p0+1 by A215,XREAL_1:6;
      then
A217: p0+j >= 8 by A216,XXREAL_0:2;
      then
A218: p0+j > 2 by XXREAL_0:2;
      p0+j > 1 by A217,XXREAL_0:2;
      hence IExec(WB4,Q,t).intpos(p0+j)=t1.intpos(p0+j) by A210
        .=t.intpos(p0+j) by A179,A193,A194,A218,A192;
    end;
  end;
A219: for t be State of SCMPDS,Q
  for m1,md be Nat st t.a=0 & t.SBP=m1 &
  t.intpos(m1+pn)=md & md >= p0+1 & t.intpos(m1+pn+1)-md > 0 holds TR
  is_closed_on t,Q & TR is_halting_on t,Q

  proof
    let t be State of SCMPDS,Q;
    let m1,md be Nat;
    set lPt=l3 ';' l4 ';' Pt, t2=IExec(l3 ';' l4,Q,Initialize t),
    mp=m1+pn, Q2 = Q;
A220: t2.a = (Initialize t2).a by SCMPDS_5:15;
A221: t2.a2 = (Initialize t2).a2 by SCMPDS_5:15;
    assume that
A222: t.a=0 and
A223: t.SBP=m1 and
A224: t.intpos mp=md and
A225: md >= p0+1 and
    t.intpos (mp+1)-md > 0;
A226: t2.a=0 by A7,A222,A223;
A227: t2.a2=t.intpos mp by A7,A222,A223;
    then Pt is_halting_on Initialize t2,Q2 by A5,A224,A225,A226,Th10,A220,A221;
    then
A228: Pt is_halting_on t2,Q2 by SCMPDS_6:126;
     Pt is_closed_on Initialize t2,Q2 by A5,A224,A225,A227,A226,Th10,A220,A221;
     then
A229: Pt is_closed_on t2,Q2 by SCMPDS_6:125;
    then
A230: lPt is_halting_on t,Q by A228,SCPISORT:9;
    lPt is_closed_on t,Q by A229,A228,SCPISORT:9;
    hence thesis by A230,SCPISORT:8;
  end;

A231: for t be 0-started State of SCMPDS,Q
   for m,m1,md be Nat,n4 be Integer, f1,

f2 be FinSequence of INT st t.a=0 & t.SBP=m1 & m1=m+1 & t.intpos(m1+pn)=md & md

>= p0+1 & n4=t.intpos(m1+pn+1) & n4-md > 0 & n4 <= pn & f1 is_FinSequence_on t,

p0 & len f1=n & f2 is_FinSequence_on IExec(WB4,Q,t),p0 & len f2=n
 holds IExec(WB4,Q,t).a=0 & IExec(WB4,Q,t).a1=m1+2 &
md=IExec(WB4,Q,t).intpos(m1+pn)
 & n4=IExec(WB4,Q,t).intpos (m1+pn+3) &
  (for j be Nat st (1<=j & j<m1)
 holds IExec(WB4,Q,t).intpos(pn+j)=t.intpos(pn+j)) &
 f1,f2 are_fiberwise_equipotent & ex m4 be

Nat st md <= m4 & m4 <= n4
 & m4-1=IExec(WB4,Q,t).intpos (m1+pn+1) & m4
  +1=IExec(WB4,Q,t).intpos (m1+pn+2)
   & (for i be Nat st md<=i & i < m4
  holds IExec(WB4,Q,t).intpos m4 >=
  IExec(WB4,Q,t).intpos i)
   & (for i be Nat st m4 < i & i <= n4
 holds IExec(WB4,Q,t).intpos m4 <=
 IExec(WB4,Q,t).intpos i)

& for j be Nat st p0+1<=j & j<md or n4<j & j <= p0+n
 holds IExec(WB4,Q,t).intpos j = t.intpos j

  proof

    let t be 0-started State of SCMPDS,Q;
    let m,m1,md be Nat,n4 be Integer, f1,f2 be
    FinSequence of INT;
A232: Initialize t = t by MEMSTR_0:44;
    set mp=m1+pn, t1=IExec(l1 ';' l2,Q,t), Q1 = Q;
    assume that
A233: t.a=0 and
A234: t.SBP=m1 and
A235: m1=m+1 and
A236: t.intpos mp=md and
A237: md >= p0+1 and
A238: n4=t.intpos (mp+1) and
A239: n4-md > 0 and
A240: n4 <= pn;
A241: t1.a2 > 0 by A179,A233,A234,A236,A238,A239,A232;
A242: mp >= 0+7 by A6,XREAL_1:7;
    then mp > 2 by XXREAL_0:2;
    then
A243: t1.intpos mp=md by A179,A233,A234,A236,A232;
    assume that
A244: f1 is_FinSequence_on t,p0 and
A245: len f1=n;
A246: p0+1>= 7+1 by A5,XREAL_1:6;
    now
      let i be Nat;
      assume that
A247: 1 <= i and
A248: i <= len f1;
      p0+i >= p0+1 by A247,XREAL_1:6;
      then p0+i >= 8 by A246,XXREAL_0:2;
      then
A249: p0+i > 2 by XXREAL_0:2;
      thus f1.i=t.intpos(p0+i) by A244,A247,A248
        .= t1.intpos(p0+i) by A179,A233,A234,A249,A232;
    end;
    then
A250: f1 is_FinSequence_on t1,p0;
    mp+1 >= 7+1 by A242,XREAL_1:6;
    then mp+1 > 2 by XXREAL_0:2;
    then
A251: n4=t1.intpos (mp+1) by A179,A233,A234,A238,A232;
A252: t1.a=0 by A179,A233,A234,A232;
    then
A253: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:1;
A254: t1.SBP=m1 by A179,A233,A234,A232;
    then
A255: TR is_halting_on t1,Q1 by A219,A237,A239,A243,A251,A252;
A256: TR is_halting_on Initialize t1,Q1
    proof
      Q1+*stop TR halts_on Initialize Initialize t1 by A255,SCMPDS_6:def 3;
     hence thesis by SCMPDS_6:def 3;
    end;
A257: (Initialize t1).GBP = t1.GBP by SCMPDS_5:15;
A258: (Initialize t1).DataLoc(t1.GBP,2) = t1.DataLoc(t1.GBP,2) by SCMPDS_5:15;
A259: TR is_closed_on t1,Q1 by A219,A237,A239,A254,A243,A251,A252;
A260: TR is_closed_on Initialize t1,Q1
     proof
  for k being Nat holds
   IC Comput(Q1+*stop TR,Initialize Initialize t1,k) in dom stop TR
             by A259,SCMPDS_6:def 2;
      hence thesis by SCMPDS_6:def 2;
     end;
    then
A261: IF4 is_halting_on Initialize t1,Q1
        by A253,A241,A257,A258,A256,SCMPDS_6:68;
A262: IF4 is_halting_on t1,Q1
    proof
      Q1+*stop IF4 halts_on Initialize Initialize t1 by A261,SCMPDS_6:def 3;
     hence thesis by SCMPDS_6:def 3;
    end;
    assume that
A263: f2 is_FinSequence_on IExec(WB4,Q,t),p0 and
A264: len f2=n;
A265: IF4 is_closed_on Initialize t1,Q1
 by A253,A241,A257,A258,A256,A260,SCMPDS_6:68;
A266: IF4 is_closed_on t1,Q1
  proof
  for k being Nat holds
   IC Comput(Q1+*stop IF4,Initialize Initialize t1,k) in dom stop IF4
           by A265,SCMPDS_6:def 2;
   hence thesis by SCMPDS_6:def 2;
  end;

A267: now
      let x;
      thus IExec(WB4,Q,t).x = IExec(IF4,Q1,Initialize t1).x
           by A266,A262,SCPISORT:7
        .=IExec(TR,Q1,Initialize t1).x
         by A253,A241,Th1,A257,A258,A260,A256;
    end;
    now
      let i be Nat;
      assume that
A268: 1 <= i and
A269: i <= len f2;
      thus f2.i=IExec(WB4,Q,t).intpos(p0+i)
      by A263,A268,A269
        .= IExec(TR,Q1,Initialize t1).intpos(p0+i) by A267;
    end;
    then
A270: f2 is_FinSequence_on IExec(TR,Q1,Initialize t1),p0;

A271: (Initialize t1).SBP = t1.SBP by SCMPDS_5:15;
A272: (Initialize t1).a = t1.a by SCMPDS_5:15;
A273: (Initialize t1).intpos(m1+pn) = t1.intpos(m1+pn) by SCMPDS_5:15;
A274: (Initialize t1).intpos(m1+pn+1) = t1.intpos(m1+pn+1) by SCMPDS_5:15;
A275: f1 is_FinSequence_on Initialize t1,p0
   proof let i be Nat;
    assume 1 <= i & i <= len f1;
     then f1.i=t1.intpos(p0+i) by A250;
    hence thesis by SCMPDS_5:15;
   end;

    IExec(TR,Q1,Initialize t1).a=0
     by A78,A235,A237,A239,A240,A245,A264,A254,A243,A251,A252,A270,A271,A272,
A273,A274
,A275;
    hence IExec(WB4,Q,t).a=0 by A267;

    consider m4 be Nat such that
A276: md <= m4 and
A277: m4 <= n4 and
A278: m4-1=IExec(TR,Q1,Initialize t1).intpos (mp+1) and
A279: m4+1=IExec(TR,Q1,Initialize t1).intpos (mp+2) and
A280: for i be Nat st md<=i & i < m4
holds IExec(TR,Q1,Initialize t1).
    intpos m4 >= IExec(TR,Q1,Initialize t1).intpos i and

A281: for i be Nat st m4 < i & i <= n4
holds IExec(TR,Q1,Initialize t1).
    intpos m4 <= IExec(TR,Q1,Initialize t1).intpos i and

A282: for j be Nat st p0+1<=j & j<md or n4<j & j <= p0+n
holds IExec(TR,Q1,Initialize t1).intpos j = (Initialize t1).intpos j
 by A78,A235,A237,A239,A240,A245,A264,A254,A243,A251,A252,A270,A271,A272,A273,
A274,A275;

A283: for j be Nat st p0+1<=j & j<md or n4<j & j <= p0+n
holds IExec(TR,Q1,Initialize t1).intpos j = t1.intpos j
 proof let j be Nat;
  assume p0+1<=j & j<md or n4<j & j <= p0+n;
   then IExec(TR,Q1,Initialize t1).intpos j = (Initialize t1).intpos j
              by A282;
  hence thesis by SCMPDS_5:15;
 end;
    IExec(TR,Q1,Initialize t1).a1=m1+2
    by A78,A235,A237,A239,A240,A245,A264,A254,A243,A251,A252,A270,A271,A272,
A273,A274
,A275;

    hence IExec(WB4,Q,t).a1=m1+2 by A267;

    md=IExec(TR,Q1,Initialize t1).intpos mp
    by A78,A235,A237,A239,A240,A245,A264,A254,A243,A251,A252,A270,A271,A272,
A273,A274
,A275;

    hence md=IExec(WB4,Q,t).intpos mp by A267;

    n4=IExec(TR,Q1,Initialize t1).intpos (mp+3)
    by A78,A235,A237,A239,A240,A245,A264,A254,A243,A251,A252,A270,A271,A272,
A273,A274
,A275;

    hence n4=IExec(WB4,Q,t).intpos (mp+3) by A267;
    hereby
      let j be Nat;
      assume that
A284: 1<=j and
A285: j<m1;
      pn+j >= pn+1 by A284,XREAL_1:6;
      then pn+j >= 8 by A190,XXREAL_0:2;
      then
A286: pn+j > 2 by XXREAL_0:2;
      thus IExec(WB4,Q,t).intpos(pn+j)=
      IExec(TR,Q1,Initialize t1).intpos(pn+j) by A267

        .=(Initialize t1).intpos(pn+j)
         by A78,A235,A237,A239,A240,A245,A264,A254,A243,A251,A252,A270,A284
,A285,A271,A272,A273,A274,A275
        .=t1.intpos(pn+j) by SCMPDS_5:15

        .=t.intpos(pn+j) by A179,A233,A234,A286,A232;
    end;

    thus f1,f2 are_fiberwise_equipotent by A78,A235,A237,A239,A240,A245,A264
,A254,A243,A251,A252,A270,A271,A272,A273,A274,A275;

    take m4;
    thus md <= m4 & m4 <= n4 by A276,A277;
    thus m4-1=IExec(WB4,Q,t).intpos (mp+1) by A267,A278;
    thus m4+1=IExec(WB4,Q,t).intpos (mp+2) by A267,A279;
    hereby
      let i be Nat;
      assume that
A287: md<=i and
A288: i < m4;
      IExec(TR,Q1,Initialize t1).intpos m4 >=
      IExec(TR,Q1,Initialize t1).intpos i by A280,A287,A288;
      then IExec(WB4,Q,t).intpos m4 >=
      IExec(TR,Q1,Initialize t1).intpos i
       by A267;
      hence IExec(WB4,Q,t).intpos m4 >=
      IExec(WB4,Q,t).intpos i by A267;
    end;
    hereby
      let i be Nat;
      assume that
A289: m4 < i and
A290: i <= n4;
      IExec(TR,Q1,Initialize t1).intpos m4 <=
      IExec(TR,Q1,Initialize t1).intpos i by A281,A289,A290;
      then IExec(WB4,Q,t).intpos m4 <=
      IExec(TR,Q1,Initialize t1).intpos i
       by A267;
      hence IExec(WB4,Q,t).intpos m4 <=
      IExec(WB4,Q,t).intpos i by A267;
    end;
    hereby
      let j be Nat;
      assume that
A291: p0+1<=j & j<md or n4<j & j <= p0+n;
      now
        per cases by A291;
        suppose
          p0+1<=j & j<md;
          hence p0+1<=j;
        end;
        suppose
          n4<j & j <= p0+n;
          then j >= m4 by A277,XXREAL_0:2;
          then j >= md by A276,XXREAL_0:2;
          hence j >= p0+1 by A237,XXREAL_0:2;
        end;
      end;
      then j >= 8 by A246,XXREAL_0:2;
      then
A292: j > 2 by XXREAL_0:2;
      thus IExec(WB4,Q,t).intpos j =
        IExec(TR,Q1,Initialize t1).intpos j by A267
        .=t1.intpos j by A283,A291
        .=t.intpos j by A179,A233,A234,A292,A232;
    end;
  end;
  consider f be FinSequence of INT such that
A293: len f=n and
A294: f is_FinSequence_on s,p0 by SCPISORT:2;
A295: pn+2 >= 7+2 by A6,XREAL_1:6;
A296: s1.a=0 & s1.a1=1 & s1.intpos(pn+1)=p0+1 & s1.intpos(pn+2)=pn & for i
  be Nat st i >= 8 & i <= pn holds s1.intpos i=s.intpos i
  proof
    set t2=IExec(m1 ';' m2 ';' m3,P,s),
    t3=IExec(m1 ';' m2,P,s), t4=Exec(m1, s);
A297: t4.a =0 by SCMPDS_2:45;
A298: t3.a=Exec(m2, t4).a by SCMPDS_5:42
      .=0 by A297,SCMPDS_2:45,SCMP_GCD:3;
A299: t3.SBP=Exec(m2, t4).SBP by SCMPDS_5:42
      .=1 by SCMPDS_2:45;
    then
A300: DataLoc(t3.SBP,pn)=intpos (pn+1) by SCMP_GCD:1;
A301: t2.a=Exec(m3,t3).a by SCMPDS_5:41
      .=0 by A298,A300,AMI_3:10,SCMPDS_2:46;
A302: t2.intpos (pn+1)=Exec(m3,t3).intpos (pn+1) by SCMPDS_5:41
      .=p0+1 by A300,SCMPDS_2:46;
A303: pn+2 > 1 by A295,XXREAL_0:2;
A304: pn+1 > 1 by A190,XXREAL_0:2;
A305: t2.SBP=Exec(m3,t3).SBP by SCMPDS_5:41
      .=1 by A299,A300,A304,AMI_3:10,SCMPDS_2:46;
    then
A306: DataLoc(t2.SBP,pn+1)=intpos (pn+(1+1)) by SCMP_GCD:1;
    thus s1.a=Exec(m4,t2).a by SCMPDS_5:41
      .=0 by A301,A306,AMI_3:10,SCMPDS_2:46;
    thus s1.a1=Exec(m4,t2).SBP by SCMPDS_5:41
      .=1 by A305,A306,A303,AMI_3:10,SCMPDS_2:46;
A307: pn+2 > pn+1 by XREAL_1:6;
    thus s1.intpos (pn+1)=Exec(m4,t2).intpos (pn+1) by SCMPDS_5:41
      .=p0+1 by A302,A306,A307,AMI_3:10,SCMPDS_2:46;
    thus s1.intpos (pn+2)=Exec(m4,t2).intpos (pn+2) by SCMPDS_5:41
      .=pn by A306,SCMPDS_2:46;
A308: for i being Nat st i >= 8 holds t4.intpos i = s.intpos i
           by AMI_3:10,SCMPDS_2:45;
A309: now
      let i be Nat;
      assume
A310: i >= 8;
      then
A311: i > 1 by XXREAL_0:2;
      thus t3.intpos i =Exec(m2, t4).intpos i by SCMPDS_5:42
        .=t4.intpos i by A311,AMI_3:10,SCMPDS_2:45
        .=s.intpos i by A308,A310;
    end;
A312: now
      let i be Nat;
      assume that
A313: i >= 8 and
A314: i <=pn;
A315: pn+1 > pn by XREAL_1:29;
      thus t2.intpos i =Exec(m3, t3).intpos i by SCMPDS_5:41
        .=t3.intpos i by A300,A314,A315,AMI_3:10,SCMPDS_2:46
        .=s.intpos i by A309,A313;
    end;
A316: pn+2 > pn+0 by XREAL_1:6;
      let i be Nat;
      assume that
A317: i >= 8 and
A318: i <=pn;
      thus s1.intpos i =Exec(m4, t2).intpos i by SCMPDS_5:41
        .=t2.intpos i by A306,A318,A316,AMI_3:10,SCMPDS_2:46
        .=s.intpos i by A312,A317,A318;
  end;
  now
A319: p0+1 >= 7+1 by A5,XREAL_1:6;
    let i be Nat;
    assume that
A320: 1 <= i and
A321: i <= len f;
A322: p0+i <= pn by A293,A321,XREAL_1:6;
    p0+i >= p0+1 by A320,XREAL_1:6;
    then
A323: p0+i >= 8 by A319,XXREAL_0:2;
    thus f.i=s.intpos(p0+i) by A294,A320,A321
      .=s1.intpos(p0+i) by A296,A323,A322;
  end;
  then
A324: f is_FinSequence_on s1,p0;
  consider g be FinSequence of INT such that
A325: len g=n and
A326: g is_FinSequence_on IExec(QuickSort(n,p0),P,s),p0
 by SCPISORT:2;
A327: b1=intpos(0+1) by SCMP_GCD:1;
A328: for t be State of SCMPDS,Q
   for m,md be Nat st t.a=0 & t.SBP=m & t
  .intpos(m+pn)=md & (md >= p0+1 or t.intpos(m+pn+1)-md <= 0) holds WB4
  is_closed_on t,Q & WB4 is_halting_on t,Q
  proof
    let t be State of SCMPDS,Q;
    let m,md be Nat;
    set mp=m+pn, t1=IExec(l1 ';' l2,Q,Initialize t), Q1 = Q;
    assume that
A329: t.a=0 and
A330: t.SBP=m and
A331: t.intpos mp=md and
A332: md >= p0+1 or t.intpos(mp+1)-md <= 0;
A333: t1.a2=t.intpos (mp+1)-t.intpos mp by A179,A329,A330;
A334: t1.a=0 by A179,A329,A330;
    then
A335: DataLoc(t1.a,2)=intpos(0+2) by SCMP_GCD:1;
    per cases;
    suppose
A336: t1.DataLoc(t1.a,2) > 0;
A337: mp >= 0+7 by A6,XREAL_1:7;
      then mp+1 >= 7+1 by XREAL_1:6;
      then mp+1 > 2 by XXREAL_0:2;
      then
A338: t1.intpos(mp+1)-md > 0 by A179,A329,A330,A331,A333,A335,A336;
A339: t1.SBP=m by A179,A329,A330;
      mp > 2 by A337,XXREAL_0:2;
      then
A340: t1.intpos mp=md by A179,A329,A330,A331;

      then
A341: TR is_halting_on t1,Q1
 by A219,A179,A329,A330,A331,A332,A334,A335,A336,A339,A338;

A342: (Initialize t1).DataLoc(t1.a,2) = t1.DataLoc(t1.a,2) by SCMPDS_5:15;
A343: (Initialize t1).a = t1.a by SCMPDS_5:15;

A344: TR is_closed_on t1,Q1
 by A219,A179,A329,A330,A331,A332,A334,A335,A336,A339,A340,A338;

A345: TR is_halting_on Initialize t1,Q1
  proof
     Q1+*stop TR halts_on Initialize Initialize t1 by A341,SCMPDS_6:def 3;
   hence thesis by SCMPDS_6:def 3;
  end;
A346: TR is_closed_on Initialize t1,Q1
  proof
   for k being Nat holds
   IC Comput(Q1+*stop TR,Initialize Initialize t1,k) in dom stop TR
            by A344,SCMPDS_6:def 2;
   hence thesis by SCMPDS_6:def 2;
  end;
      then
A347: IF4 is_halting_on Initialize t1,Q1 by A336,A345,A342,A343,SCMPDS_6:68;
A348: IF4 is_halting_on t1,Q1
        proof
         Q1+*stop IF4 halts_on Initialize Initialize t1 by A347,SCMPDS_6:def 3;
         hence thesis by SCMPDS_6:def 3;
        end;
A349:   IF4 is_closed_on Initialize t1,Q1 by A336,A346,A345,A342,A343
,SCMPDS_6:68;
      IF4 is_closed_on t1,Q1
       proof
  for k being Nat holds
   IC Comput(Q1+*stop IF4,Initialize Initialize t1,k) in dom stop IF4
         by A349,SCMPDS_6:def 2;
        hence thesis by SCMPDS_6:def 2;
       end;
      hence thesis by A348,SCPISORT:9;
    end;
    suppose
A350: t1.DataLoc(t1.a,2) <= 0;
A351: lb is_halting_on t1,Q1 by SCMPDS_6:21;
A352: lb is_closed_on t1,Q1 by SCMPDS_6:20;
      then
A353: IF4 is_halting_on t1,Q1 by A350,A351,SCMPDS_6:69;
      IF4 is_closed_on t1,Q1 by A350,A352,A351,SCMPDS_6:69;
      hence thesis by A353,SCPISORT:9;
    end;
  end;

A354:
  now let t be 0-started State of SCMPDS, Q;
    let f1,f2 be FinSequence of INT, k1,k2,y1,yn be
    Nat;
    set mm=2*k1+1, md=p0+y1, n4=p0+yn;
    assume that
A355: t.a=0 and
A356: mm=t.b1 and
A357: k2=pn+2*k1+1 and
A358: md=t.intpos k2 and
A359: n4=t.intpos(k2+1) and
A360: 1 <= y1 & yn <= n or y1 >= yn;
    set mp=mm+pn;
A361: md=t.intpos mp by A357,A358;
    now
      per cases by A360;
      case
        1 <= y1 & yn <= n;
        hence p0+1 <= md by XREAL_1:6;
      end;
      case
        y1 >= yn;
        then md >= t.intpos (mp+1) by A357,A359,XREAL_1:6;
        hence t.intpos (mp+1) -md <= 0 by XREAL_1:47;
      end;
    end;
    hence WB4 is_closed_on t,Q & WB4 is_halting_on t,Q
     by A328,A327,A355,A356,A361;
    consider f3 be FinSequence of INT such that
A362: len f3=n and
A363: for i be Nat st 1<=i & i <= len f3 holds f3.i=t.
    intpos( p0+i) by SCPISORT:1;
    consider f4 be FinSequence of INT such that
A364: len f4=n and
A365: for i be Nat st 1<=i & i <= len f4
     holds f4.i=IExec(WB4,Q,t).intpos(p0+i) by SCPISORT:1;
A366: f4 is_FinSequence_on IExec(WB4,Q,t),p0 by A365;
A367: f3 is_FinSequence_on t,p0 by A363;
    hereby
      per cases;
      suppose
        t.intpos (mp+1) <= t.intpos mp;

        hence
        IExec(WB4,Q,t).a=t.a &
        for j be Nat st 1<=j & j<mm holds
        IExec(WB4,Q,t).intpos(pn+j)=t.intpos(pn+j)
        by A191,A327,A355,A356;

      end;
      suppose
A368:   t.intpos (mp+1) > t.intpos mp;
        then
A369:   n4-md > 0 by A357,A358,A359,XREAL_1:50;
A370:   n4 <= pn by A357,A358,A359,A360,A368,XREAL_1:6;
        p0+1 <= md by A357,A358,A359,A360,A368,XREAL_1:6;

        hence
        IExec(WB4,Q,t).a=t.a &
        for j be Nat st 1<=j & j<mm holds

IExec(WB4,Q,t).intpos(pn+j)=t.intpos(pn+j)
 by A231,A327,A355,A356,A357,A359,A361,A362,A367,A364,A366,A369,A370;

      end;
    end;
    hereby
      assume y1>=yn;
      then
A371: t.intpos (mp+1) <= t.intpos mp by A357,A358,A359,XREAL_1:6;
      hence IExec(WB4,Q,t).b1=2*k1+1-2 by A191,A327,A355,A356
        .=2*k1-1;

      thus for j be Nat st 1<=j & j <= n
      holds IExec(WB4,Q,t).intpos
      (p0+j) = t.intpos (p0+j) by A191,A327,A355,A356,A371;

    end;
A372: k2=mp by A357;


set s = Initialize s1,
    a = GBP,
    c = 0,
    m = p0,
    i = 1,
    I = WB4,
    P = P1,
    pn = p0+n,
    m1 = pn+1;
thus
y1<yn implies IExec(I,Q,t).DataLoc(c,i)=2*k1+3
 & (for j be Nat
st 1<=j & j<y1 or yn<j & j <= n
 holds IExec(I,Q,t).intpos(m+j) = t.intpos (m+
j)) & (ex ym be Nat st y1 <= ym & ym <= yn
 & m+y1=IExec(I,Q,t).intpos
k2 & m+ym-1=IExec(I,Q,t).intpos (k2+1) &
m+ym+1=IExec(I,Q,t).intpos (k2+2)
 & m+yn=
IExec(I,Q,t).intpos (k2+3) &
 (for j be Nat st y1 <= j & j < ym holds
IExec(I,Q,t).intpos (m+j) <=
IExec(I,Q,t).intpos (m+ym)) &
 (for j be Nat
st ym < j & j <= yn holds IExec(I,Q,t).intpos (m+j)
 >= IExec(I,Q,t).intpos (m+ym)))
    proof
      assume
A373: y1<yn;
      then
A374: p0+1 <= md by A360,XREAL_1:6;
      n4 > md by A373,XREAL_1:6;
      then
A375: n4-md > 0 by XREAL_1:50;
A376: n4 <= pn by A360,A373,XREAL_1:6;

      hence
      IExec(WB4,Q,t).b1=2*k1+1+2
       by A231,A327,A355,A356,A357,A359,A361,A362,A367,A364,A366,A375,A374

        .=2*k1+3;
      consider m4 be Nat such that
A377: md <= m4 and
A378: m4 <= n4 and
A379: m4-1=IExec(WB4,Q,t).intpos (mp+1) and
A380: m4+1=IExec(WB4,Q,t).intpos (mp+2) and

A381: for i be Nat st md<=i & i < m4
holds IExec(WB4,Q,t).
      intpos m4 >= IExec(WB4,Q,t).intpos i and

A382: for i be Nat st m4 < i & i <= n4
holds IExec(WB4,Q,t)
      . intpos m4 <= IExec(WB4,Q,t).intpos i and

A383: for j be Nat st p0+1<=j & j<md or n4<j & j <= p0+n

holds IExec(WB4,Q,t).intpos j = t.intpos j
 by A231,A327,A355,A356,A357,A358,A359,A362,A367,A364,A366,A375,A374,A376;

      hereby
        let j be Nat;
        assume 1<=j & j<y1 or yn<j & j <= n;

        then p0+1<=p0+j & p0+j<md or n4<p0+j & p0+j <= p0+n by XREAL_1:6;

        hence IExec(WB4,Q,t).intpos(p0+j) = t.intpos (p0+j) by A383;
      end;
      m4-p0 >= y1 by A377,XREAL_1:19;
      then reconsider ym=m4-p0 as Element of NAT by INT_1:3;
      take ym;
      m4=p0+ym;
      hence y1 <= ym & ym <= yn by A377,A378,XREAL_1:6;

      thus md=IExec(WB4,Q,t).intpos k2
       by A231,A327,A355,A356,A358,A359,A372,A362,A367,A364,A366,A375,A374,A376
;

      thus p0+ym-1=IExec(WB4,Q,t).intpos (k2+1) by A357,A379;
      thus p0+ym+1=IExec(WB4,Q,t).intpos (k2+2) by A357,A380;

      thus n4=IExec(WB4,Q,t).intpos (k2+3)
       by A231,A327,A355,A356,A358,A359,A372,A362,A367,A364,A366,A375,A374,A376
;

      hereby
        let j be Nat;
        assume that
A384:   y1 <= j and
A385:   j < ym;
A386:   p0+j < p0+ym by A385,XREAL_1:6;
        p0+y1 <= p0+j by A384,XREAL_1:6;

        hence
        IExec(WB4,Q,t).intpos (p0+j) <=
        IExec(WB4,Q,t).intpos (p0+ym)
         by A381,A386;

      end;
      hereby
        let j be Nat;
        assume that
A387:   ym < j and
A388:   j <= yn;
A389:   p0+j <= p0+yn by A388,XREAL_1:6;
        p0+ym < p0+j by A387,XREAL_1:6;

        hence
        IExec(WB4,Q,t).intpos (p0+j) >=
        IExec(WB4,Q,t).intpos (p0+ym)
         by A382,A389;

      end;
    end;
    hereby
      assume that
A390: f1 is_FinSequence_on t,p0 and
A391: f2 is_FinSequence_on IExec(WB4,Q,t),p0 and
A392: len f1=n and
A393: len f2=n;
      per cases;
      suppose
A394:   t.intpos (mp+1) <= t.intpos mp;
A395:   dom f1 = Seg n by A392,FINSEQ_1:def 3;
        now
          let i be Nat;
          reconsider a = i as Nat;
          assume
A396:     i in dom f1;
          then
A397:     1 <= i by A395,FINSEQ_1:1;
A398:     i <= n by A395,A396,FINSEQ_1:1;
          hence f1.i = t.intpos(p0+a) by A390,A392,A397

            .=IExec(WB4,Q,t).intpos(p0+a)
            by A191,A327,A355,A356,A394,A397,A398

            .=f2.i by A391,A393,A397,A398;
        end;
        hence f1,f2 are_fiberwise_equipotent by A392,A393,FINSEQ_2:9;
      end;
      suppose
A399:   t.intpos (mp+1) > t.intpos mp;
        then
A400:   n4-md > 0 by A357,A358,A359,XREAL_1:50;
A401:   n4 <= pn by A357,A358,A359,A360,A399,XREAL_1:6;
        p0+1 <= md by A357,A358,A359,A360,A399,XREAL_1:6;

        hence
        f1,f2 are_fiberwise_equipotent by A231,A327,A355,A356,A357,A359,A361
,A390,A391,A392,A393,A400,A401;

      end;
    end;
  end;
A402: (Initialize s1).GBP = s1.GBP by SCMPDS_5:15;
A403: (Initialize s1).intpos (pn+1) = s1.intpos (pn+1) by SCMPDS_5:15;
A404: (Initialize s1).intpos((pn+1)+1) = s1.intpos((pn+1)+1) by SCMPDS_5:15;
A405: (Initialize s1).DataLoc(0,1) = s1.DataLoc(0,1) by SCMPDS_5:15;
A406: WH4 is_closed_on Initialize s1,P by A327,A354,A296,Lm5,A402,A403,A404,
A405;
A407: WH4 is_closed_on s1,P
    proof
  for k being Nat holds
   IC Comput(P+*stop WH4,Initialize Initialize s1,k) in dom stop WH4
            by A406,SCMPDS_6:def 2;
     hence thesis by SCMPDS_6:def 2;
    end;
A408:  WH4 is_halting_on Initialize s1,P by A327,A354,A296,Lm5,A402,A403,A404,
A405;
A409:  WH4 is_halting_on s1,P
   proof
     P+*stop WH4 halts_on Initialize Initialize s1 by A408,SCMPDS_6:def 3;
    hence thesis by SCMPDS_6:def 3;
   end;
  hence QuickSort(n,p0) is_halting_on s,P by A407,A1,SCPISORT:9;
  take f,g;
  thus len f=n & f is_FinSequence_on s,p0 & len g=n & g is_FinSequence_on
  IExec(QuickSort(n,p0),P,s),p0 by A293,A294,A325,A326;
  now
    let i be Nat;
    assume that
A410: 1 <= i and
A411: i <= len g;
    thus g.i=IExec(M4 ';' WH4,P,s).intpos(p0+i)
     by A326,A410,A411
      .=IExec(WH4,P1,Initialize s1).intpos(p0+i) by A409,A407,SCPISORT:7;
  end;
  then
A412:  g is_FinSequence_on IExec(WH4,P1,Initialize s1),p0;
A413: (Initialize s1).GBP = s1.GBP by SCMPDS_5:15;
A414: (Initialize s1).DataLoc(0,1) = s1.DataLoc(0,1) by SCMPDS_5:15;
A415: (Initialize s1).intpos (pn+1) = s1.intpos (pn+1) by SCMPDS_5:15;
A416: (Initialize s1).intpos((pn+1)+1) = s1.intpos((pn+1)+1) by SCMPDS_5:15;
 f is_FinSequence_on Initialize s1,p0
     proof let i be Nat;
      assume 1 <= i & i <= len f;
       then f.i=s1.intpos(p0+i) by A324;
      hence thesis by SCMPDS_5:15;
     end;
 hence thesis
     by Lm3,A325,A293,A412,A414,A327,A296,A413,A415,A416,A354;
end;

begin :: The Basic Property of Quick Sort and Its Correctness

theorem
  card QuickSort(n,p0)=57 by Lm28;

theorem
  for p0,n being Nat st p0 >= 7 holds QuickSort(n,p0) is
  parahalting
proof
  let p0,n be Nat;
  assume
A1:  p0 >= 7;
  for s be State of SCMPDS,P
   holds QuickSort(n,p0) is_halting_on s,P
   proof let s be State of SCMPDS,P;
    QuickSort(n,p0) is_halting_on Initialize s,P by A1,Lm28;
    hence thesis by SCMPDS_6:126;
   end;
  hence thesis by SCMPDS_6:21;
end;

theorem
  for s being 0-started State of SCMPDS,p0,n being Nat st p0 >= 7
ex f,g be FinSequence of INT st len f=n & f is_FinSequence_on s,p0 & len g = n
  & g is_FinSequence_on IExec(QuickSort(n,p0),P,s),p0 & f,g
  are_fiberwise_equipotent & g is_non_decreasing_on 1,n by Lm28;

